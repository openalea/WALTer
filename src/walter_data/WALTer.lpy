# -*- coding: utf-8 -*-

### Importation de libraries
from __future__ import division
import random
from math import sqrt, exp, pi, floor, ceil, asin, acos, cos, sin, tan, log
from openalea.plantgl.all import *
import openalea.plantgl.all as pgl
import pandas as pd
import numpy as np

import sys
import os
import uuid
import json


pj = os.path.join
data_dir = os.getcwd()
inputdir = pj(data_dir, 'input')
#from my_own_functions import *

# setup params if and only if not defined as Lsys args
try:
  params = params
except NameError:
  params = {}

# create a fake lsystem for forcing cuting branchs in end eac (see tes_cut_module.py)
lpy_cut_bug = False
if lpy_cut_bug:
  from openalea.lpy import Lsystem
  fake_rule = """
  Fake:
    produce Fake"""
  fake_lsys = Lsystem()
  fake_lsys.addRule(fake_rule)

  def force_cut(lstring):
    fake_lsys.axiom = lstring
    return fake_lsys.iterate()


### Importations de fichiers annexes ###

### Rayonnement ###
#from vplants.fractalysis.light.directLight import diffuseInterception      #Importation de Fractalysis : obsolete

from walter.light import caribu_scene

# CPL
from collections import defaultdict

# Date

import datetime

# Liste des modules utilis�s par la suite dans le mod�le :

# Plan de semis dans lequel on sp�cifie le nombre de plantes et espacement entre les plantes
module Seed

# Diff�rents organes qui vont suivre des lois de production "propres"
module Apex
module Bud_primord
module Bud
module Bud_R
module Apex_R


module Leaf
module Internode

module Sheath
module Blade

module Peduncle
module Ear

# Module "d'insertion de branche" dans lequel on va faire �voluer les r�gles de r�gression de talles
module CutPointBud
module CutPointBlade

### REPRESENTATION DES ORGANES


#Param�tres de mise � l'�chelle pour que 1=1 dans chacune des directions
scalex = 0.5
scaley = 1
scalez = 0.5

#########################

#Importation des figures cr��es dans des scenes
scene_house  =  Scene(pj(inputdir,'organ_shapes', 'Pentagon_up.bgeom'))
scene_square =  Scene(pj(inputdir,'organ_shapes','Square_up_volume.bgeom'))

Sheath_geo = Scaled(Vector3(scalex,scaley,scalez),scene_square[0].geometry)
Blade_geo  = Scaled(Vector3(scalex,scaley,scalez),scene_house[0].geometry)

WALTer_version = "v2.0"
WALTer_build = 23112017

##########################################
####     BUILDING OUR SIMULATION      ####
##########################################
expe_related         = "Sensitivity_Analysis"
densite              = 150
CARIBU_state         = "enabled"
rep                  = 1
write_debug_PAR = False

var_register1 = ["expe_related","densite","CARIBU_state","rep", "write_debug_PAR"]

for key, value, in params.iteritems():
  if key in var_register1:
    exec(key+"=value")


hazard_plant_xy = True
hazard_plant_azi = True
hazard_axis = True
hazard_organ = True
hazard_emerg = True

var_register_hazard = ["hazard_plant_xy","hazard_plant_azi","hazard_axis","hazard_organ","hazard_emerg"]

for key, value, in params.iteritems():
  if key in var_register_hazard:
    exec(key+"=value")


hazard_driver = {"plant_azi" : hazard_plant_azi, "plant_xy" : hazard_plant_xy, "axis" : hazard_axis, "organ" : hazard_organ, "emerg" : hazard_emerg}


write_lscene = False
write_lstring = False

which_output_files = pd.read_csv(pj(data_dir, "which_output_files.csv"), sep="\t")
write_output_file = {"GAI":which_output_files.GAIp[0], "Peraxes":which_output_files.Peraxes[0], "Proba":which_output_files.Proba[0], "Apex_Sirius":which_output_files.Apex_sirius[0], "Apex":which_output_files.Apex[0], "Apex_R":which_output_files.Apex_R[0], "Blade":which_output_files.Blade[0], "Internode":which_output_files.Internode[0], "Sheath":which_output_files.Sheath[0], "Ear":which_output_files.Ear[0], "Peduncle":which_output_files.Peduncle[0], "PAR_per_axes":which_output_files.PAR_per_axes[0], "Lstring":which_output_files.Lstring[0], "Lscene":which_output_files.Lscene[0]}
print "ce qu'on ecrit:", write_output_file["Lscene"]


#########################

#Phyllochron adjustment
def phyll_adjust(geno):
  if sowing_DOY >= SDSA:
    phyllo = Phl[geno]
  else:
    phyllo = Phl[geno] * (1 - Rp * min(sowing_DOY,SDWS))
  return phyllo

def adapting_crop_area(density, area_min, area_max, dist_inter, opt_plt_nb):
  #print "density : ",density, "opt : ",opt_plt_nb, "area_max", area_max
  if density < (opt_plt_nb/area_max):
    area_temp = area_max
    plt_nb_temp = density*area_temp
  #elif (opt_plt_nb/area_max) < density < 55:
  #  area_temp = (50/density)
  #  plt_nb_temp = density*area_temp
  elif density > (opt_plt_nb/area_min):
    area_temp = area_min
    plt_nb_temp = density*area_temp
  else:
    #a = (area_max - area_min)/((opt_plt_nb/area_max) - (opt_plt_nb/area_min))
    #b = area_min - a*(opt_plt_nb/area_min)
    #area = a * density + b
    area_temp = (opt_plt_nb/density)
    plt_nb_temp = density*area_temp
  nb_rang = int(ceil(sqrt(area_temp)/dist_inter))
  dy = nb_rang * dist_inter
  dx = (area_temp/dy)
  nb_plante_par_rang = int(plt_nb_temp/nb_rang)
  dist_intra = dx/nb_plante_par_rang
  nplant_peupl = int(nb_rang*nb_plante_par_rang)
  crop_scheme["dx"] = dx
  crop_scheme["dy"] = dy
  crop_scheme["surface_sol"] = dx*dy
  crop_scheme["nb_rang"] = nb_rang
  crop_scheme["nb_plante_par_rang"] = nb_plante_par_rang
  crop_scheme["dist_intra_rang"] = dist_intra
  crop_scheme["nplant_peupl"] = nplant_peupl
  crop_scheme["real_density"] = nplant_peupl/crop_scheme["surface_sol"]
  crop_scheme["map_middle_y"] = ((crop_scheme["nb_rang"] * (crop_scheme["dist_inter_rang"])*100) + (crop_scheme["dist_inter_rang"])*100)/2
  crop_scheme["map_middle_x"] = ((crop_scheme["nb_plante_par_rang"] * (crop_scheme["dist_intra_rang"])*100) + (crop_scheme["dist_intra_rang"])*100)/2



#def crop_conception2(densite, dx, dy, dist_inter_rang, area_max):
#  if dx*dy > area_max:
#    print "ATTENTION LES DIMENSIONS DE LA PARCELLE SONT TROP GRANDES!"
#    dx, dy = sqrt(area_max)-0.01, sqrt(area_max)-0.01
#  nb_rang_m2 = 1/dist_inter_rang
#  nb_plante_par_rang_m2 = densite/nb_rang_m2
#  crop_scheme["nb_rang"] = int(floor(dx*nb_rang_m2))
#  crop_scheme["nb_plante_par_rang"] = int(floor(dy*nb_plante_par_rang_m2))
#  crop_scheme["dist_intra_rang"] = dy/crop_scheme["nb_plante_par_rang"]
#  crop_scheme["nplant_peupl"] = crop_scheme["nb_plante_par_rang"]*crop_scheme["nb_rang"]
#  print crop_scheme
#  return crop_scheme

def design_crop_Darwinkel(area, density):
  nb_rang = floor(sqrt(area * density))
  nb_plant_par_rang = ceil(sqrt(area * density))
  d_intra = sqrt(area/(nb_rang*nb_plant_par_rang))
  dx = nb_rang*d_intra
  dy = nb_plant_par_rang*d_intra
  nplant_peupl = nb_rang*nb_plant_par_rang
  crop_scheme["nb_rang"] = int(nb_rang)
  crop_scheme["nb_plante_par_rang"] = int(nb_plant_par_rang)
  crop_scheme["dist_inter_rang"] = d_intra
  crop_scheme["dist_intra_rang"] = d_intra
  crop_scheme["dx"] = dx
  crop_scheme["dy"] = dy
  crop_scheme["nplant_peupl"] = int(nplant_peupl)
  crop_scheme["real_density"] = nplant_peupl/area
  crop_scheme["surface_sol"] = dx*dy
  crop_scheme["map_middle_y"] = ((crop_scheme["nb_rang"] * (crop_scheme["dist_inter_rang"])*100) + (crop_scheme["dist_inter_rang"])*100)/2
  crop_scheme["map_middle_x"] = ((crop_scheme["nb_plante_par_rang"] * (crop_scheme["dist_intra_rang"])*100) + (crop_scheme["dist_intra_rang"])*100)/2
  return crop_scheme

def design_crop_mesh_for_nplants (density, nb_plt_utiles, dist_border_x, dist_border_y):
  nb_rang_utiles = floor(sqrt(nb_plt_utiles))
  nb_plant_par_rang_utiles = ceil(sqrt(nb_plt_utiles))
  d_intra = sqrt(1/density)
  d_inter = d_intra
  nb_rang = nb_rang_utiles + ceil((dist_border_x/100)/d_inter) + ceil((dist_border_x/100)/d_inter)
  nb_plant_par_rang = nb_plant_par_rang_utiles + ceil((dist_border_y/100)/d_intra) + ceil((dist_border_y/100)/d_intra)
  dx = nb_rang*d_inter
  dy = nb_plant_par_rang*d_intra
  nplant_peupl = nb_rang*nb_plant_par_rang
  crop_scheme["area"] = dx*dy
  crop_scheme["nb_rang"] = int(nb_rang)
  crop_scheme["nb_plante_par_rang"] = int(nb_plant_par_rang)
  crop_scheme["dist_inter_rang"] = d_intra
  crop_scheme["dist_intra_rang"] = d_intra
  crop_scheme["dx"] = dx
  crop_scheme["dy"] = dy
  crop_scheme["nplant_peupl"] = int(nplant_peupl)
  crop_scheme["real_density"] = nplant_peupl/crop_scheme["area"]
  crop_scheme["surface_sol"] = dx*dy
  crop_scheme["map_middle_y"] = ((crop_scheme["nb_rang"] * (crop_scheme["dist_inter_rang"])*100) + (crop_scheme["dist_inter_rang"])*100)/2
  crop_scheme["map_middle_x"] = ((crop_scheme["nb_plante_par_rang"] * (crop_scheme["dist_intra_rang"])*100) + (crop_scheme["dist_intra_rang"])*100)/2
  return crop_scheme


# Setting experimental informations
experimental_conditions = {
"Sreten":{"sowing_date" : datetime.date(1998,10,15), "year" : "1999","location" : "Grignon", "dist_inter_rang" : 0.175, "genotype" : ["Soissons"], "Ln_final":{"Soissons":11}},
"Rim1-1":{"sowing_date" : datetime.date(2007,9,25), "year" : "2008","location" : "Grignon", "dist_inter_rang" : 0.175, "genotype" : ["Soissons"], "Ln_final":{"Soissons":11}},
"Rim1-2":{"sowing_date" : datetime.date(2007,11,12), "year" : "2008","location" : "Grignon", "dist_inter_rang" : 0.175, "genotype" : ["Soissons"], "Ln_final":{"Soissons":11}},
"Rim2-1":{"sowing_date" : datetime.date(2008,9,30), "year" : "2009","location" : "Grignon", "dist_inter_rang" : 0.175, "genotype" : ["Soissons"], "Ln_final":{"Soissons":11}},
"Rim2-2":{"sowing_date" : datetime.date(2008,11,17), "year" : "2009","location" : "Grignon", "dist_inter_rang" : 0.175, "genotype" : ["Soissons"], "Ln_final":{"Soissons":11}},
"Jillian":{"sowing_date" : datetime.date(2003,10,16), "year" : "2004","location" : "Grignon", "dist_inter_rang" : 0.175, "genotype" : ["Soissons"], "Ln_final":{"Soissons":11}},
"Jessica":{"sowing_date" : datetime.date(2005,10,27), "year" : "2006","location" : "Bertheloot_2005", "dist_inter_rang" : 0.175, "genotype" : ["Soissons"], "Ln_final":{"Soissons":11.3}},
"Mariem":{"sowing_date" : datetime.date(2010,10,26), "year" : "1901","location" : "Grignon", "dist_inter_rang" : 0.175, "genotype" : ["Maxwell"] , "Ln_final":{"Maxwell":11.3}},
"Darwinkel":{"sowing_date" : datetime.date(1976,10,19), "year" : "1977","location" : "Lelystad", "dist_inter_rang" : 0.175, "genotype" : ["Lely"], "Ln_final":{"Lely":11}},
"Darwinkel_temp":{"sowing_date" : datetime.date(2013,10,19), "year" : "1901","location" : "Grignon", "dist_inter_rang" : 0.175, "genotype" : ["Maxwell"], "Ln_final":{"Maxwell":11}},
"Wheatamix-2014":{"sowing_date" : datetime.date(2013,10,31), "year" : "2014","location" : "Grignon", "dist_inter_rang" : 0.175, "genotype" : ["Soissons"], "Ln_final":{"Soissons":11}},
"Ouitamics-2014":{"sowing_date" : datetime.date(2013,10,30), "year" : "2014","location" : "Gif_sur_Yvette", "dist_inter_rang" : 0.15, "genotype" : ["Soissons","Apache", "Renan", "Caphorn", "A208", "A210", "F236", "A398"], "Ln_final":{"Soissons":11,"Apache":11, "Renan":11, "Caphorn":11, "A208":11, "A210":11, "F236":11, "A398":11}},
"None":{"sowing_date" : datetime.date(2013,10,15), "year" : "2014","location" : "Gif_sur_Yvette", "dist_inter_rang" : 0.1, "genotype" : ["Soissons","Maxwell"], "Ln_final":{"Soissons":11,"Maxwell":11}},
"Mariem_mean":{"sowing_date" : datetime.date(1900,10,26), "year" : "1901","location" : "Grignon_mean10", "dist_inter_rang" : 0.175, "genotype" : ["Maxwell"] , "Ln_final":{"Maxwell":11}},
"Darwinkel_Grignon_mean":{"sowing_date" : datetime.date(1900,10,19), "year" : "1901","location" : "Grignon_mean10", "genotype" : ["Maxwell"], "Ln_final":{"Maxwell":11}},
"Darwinkel_mean":{"sowing_date" : datetime.date(1900,10,19), "year" : "1901","location" : "Lelystad_mean10", "dist_inter_rang" : 0.175, "genotype" : ["Maxwell"], "Ln_final":{"Maxwell":11.3}
},
"Sparkes_2001":{"sowing_date" : datetime.date(2000,10,17), "year" : "2001","location" : "Nottingham","dist_inter_rang" :0.135, "genotype" : ["Maxwell"], "Ln_final":{"Maxwell":11}},
"Sparkes_2002":{"sowing_date" : datetime.date(2001,10,4), "year" : "2002","location" : "Nottingham","dist_inter_rang" :0.135, "genotype" : ["Maxwell"], "Ln_final":{"Maxwell":11}},
"Sparkes_2003":{"sowing_date" : datetime.date(2002,9,20), "year" : "2003","location" : "Nottingham","dist_inter_rang" :0.135, "genotype" : ["Maxwell"], "Ln_final":{"Maxwell":11}},
"Association" : {"sowing_date" : datetime.date(2013,10,30),"year" : "2014","location" : "Gif_sur_Yvette", "dist_inter_rang" : 0.175, "genotype" : ["Gigant_Maxwell","Darwinkel_Maxwell"] , "Ln_final":{"Gigant_Maxwell":11,"Darwinkel_Maxwell":11}},
"Sensitivity_Analysis" : {"sowing_date" : datetime.date(1900,10,15),"year" : "1901","location" : "Climat_moy_AS", "dist_inter_rang" : 0.175, "genotype" : ["Maxwell"] , "Ln_final":{"Maxwell":11.3}},
}

liste_expe = experimental_conditions.keys()

## CARIBU
infinity_CARIBU = 0              # En booleen 0 : False 1: True
nb_azimuth = 5
nb_zenith = 4

dico_latitudes = {'Gif_sur_Yvette': 48.5, 'Le_Pin_aux_Haras': 48.7, 'Lelystad': 52.5,'Lelystad_mean10': 52.5, 'Le_Rheu': 48.1,'Alenya': 42.6,'Bertheloot_2005' : 48.8, 'Grignon': 48.8, 'Grignon_mean10' : 48.8, 'Grignon_mean18' : 48.8, 'Colmar': 48.1, 'Fagniere': 49, 'Clermont': 45.7, "Nottingham" : 52.9, "Climat_max_AS" : 48.8, "Climat_min_AS" :48.8 ,"Climat_moy_AS" : 48.8}

# Moyennes sur 10/18ans disponibles sur Grignon : { "Grignon_mean10" "Grignon_mean18"}
# Pour Lelystad on a plusieurs variantes : Lelystad, Lelystad_plusundemi, Lelystad_plusun

########################################

crop_ccptn = "Mesh_for_nplants"
area_targeted = 1
nb_rang = 1

var_register0 = ["crop_ccptn", "infinity_CARIBU"]

for key, value, in params.iteritems():
  if key in var_register0:
    exec(key+"=value")


if crop_ccptn == "classical":
  nb_plt_temp = 1
  nb_rang = 1
  dist_inter_rang = experimental_conditions[expe_related]["dist_inter_rang"]
  crop_scheme = {"dist_inter_rang":dist_inter_rang, "density":densite}
  area = nb_plt_temp/crop_scheme["density"]
  dy = nb_rang * dist_inter_rang
  dx = area/dy
  nb_plante_par_rang = int(nb_plt_temp/nb_rang)
  dist_intra = dx/nb_plante_par_rang
  nplant_peupl = int(nb_rang*nb_plante_par_rang)
  dist_border_x = 0.*100 #inside a rang
  dist_border_y = 0.*100 #rang
  crop_scheme["nplant_peupl"] = nplant_peupl
  plant_census = range(1,crop_scheme["nplant_peupl"] + 1)
  crop_scheme["dx"] = dx
  crop_scheme["dy"] = dy
  crop_scheme["surface_sol"] = dx*dy
  crop_scheme["nb_rang"] = nb_rang
  crop_scheme["nb_plante_par_rang"] = nb_plante_par_rang
  crop_scheme["dist_intra_rang"] = dist_intra
  crop_scheme["real_density"] = nplant_peupl/crop_scheme["surface_sol"]
  crop_scheme["map_middle_y"] = ((crop_scheme["nb_rang"] * (crop_scheme["dist_inter_rang"])*100) + (crop_scheme["dist_inter_rang"])*100)/2
  crop_scheme["map_middle_x"] = ((crop_scheme["nb_plante_par_rang"] * (crop_scheme["dist_intra_rang"])*100) + (crop_scheme["dist_intra_rang"])*100)/2
elif crop_ccptn == "neo_Darwinkel":
  area_min, area_max = 1, 13
  dist_inter_rang = experimental_conditions[expe_related]["dist_inter_rang"]
  opt_plt_nb = 10
  crop_scheme = {"dist_inter_rang":dist_inter_rang, "density":densite}
  adapting_crop_area(crop_scheme["density"],area_min, area_max, crop_scheme["dist_inter_rang"], opt_plt_nb)
  dist_border_x = 0.2*100 #inside a rang
  dist_border_y = 0.15*100 #rang
  plant_census = range(1,crop_scheme["nplant_peupl"] + 1)

elif crop_ccptn == "Darwinkel_original":
  area = area_targeted
  dist_border_x = 0.15*100 #inside a rang
  dist_border_y = 0.15*100 #rang
  crop_scheme = {"area" : area, "density" : densite}
  #border_prop = 0.8
  design_crop_Darwinkel(crop_scheme["area"], crop_scheme["density"])
  #dist_border_x = ((crop_scheme["dy"]/crop_scheme["dx"]) * (border_prop/2)) * crop_scheme["dx"] #inside a rang
  #dist_border_y = ((crop_scheme["dx"]/crop_scheme["dy"]) * (border_prop/2)) * crop_scheme["dy"] #rang
  plant_census = range(1,crop_scheme["nplant_peupl"] + 1)
  print "dist_border_x : ",dist_border_x, "dist_border_y : ",dist_border_y

elif crop_ccptn == "Mesh_for_nplants":
  nb_plt_utiles = 50
  dist_border_x = 0.20*100 #inside a rang
  dist_border_y = 0.20*100 #rang 
  crop_scheme = {"density" : densite}
  design_crop_mesh_for_nplants(crop_scheme["density"], nb_plt_utiles , dist_border_x , dist_border_y)
  plant_census = range(1,crop_scheme["nplant_peupl"] + 1)
  print "dist_border_x : ",dist_border_x, "dist_border_y : ",dist_border_y



nb_rangs = crop_scheme["nb_rang"]
nb_plantes = crop_scheme["nplant_peupl"]
dist_inter_rang = crop_scheme["dist_inter_rang"]
dist_intra_rang = crop_scheme["dist_intra_rang"]
dx = crop_scheme["dx"]
dy = crop_scheme["dy"]

genotype_proportion = "random"

var_register_genotype_proportion = ["genotype_proportion"]

for key, value, in params.iteritems():
  if key in var_register_genotype_proportion:
    exec(key+"=value")


geno_nb              = len(experimental_conditions[expe_related]["genotype"])                              # Nombre de g�notypes compris sur la parcelle

crop_genotype = []

for geno in experimental_conditions[expe_related]["genotype"]:
  crop_genotype.append(geno)

################################

SIRIUS_state         = "disabled"
infinity_GAIp        = "True"         # A METTRE EN TEXTE #Infinitisation du couvert pour le calcul du GAI de proximit�
cohorte_max          = 9



# Si SIRIUS n'est pas activ�, le nombre final de feuilles est fix� � la donn�e exp�rimentale. S'il n'y a pas de donn�e exp�rimental il est � 11 par d�faut.

#Initialisation
global param_Ln_final

if SIRIUS_state == "disabled":
  if expe_related in liste_expe:
    param_Ln_final = experimental_conditions[expe_related]["Ln_final"]
  else:
    param_Ln_final = {}

var_register_Ln_final = ["Ln_final_Maxwell","Ln_final_Soissons","Ln_final_Lely","Ln_final_Gigant_Maxwell","Ln_final_Darwinkel_Maxwell","Ln_final_Apache","Ln_final_Renan","Ln_final_Caphorn","Ln_final_A208","Ln_final_A210","Ln_final_F236","Ln_final_A398"]

for key, value, in params.iteritems():
  if key in var_register_Ln_final:
    exec(key+"=value")

try:
  param_Ln_final["Maxwell"] = Ln_final_Maxwell
except NameError:
  pass

try:
  param_Ln_final["Soissons"] = Ln_final_Soissons
except NameError:
  pass

try:
  param_Ln_final["Lely"] = Ln_final_Lely
except NameError:
  pass

try:
  param_Ln_final["Gigant_Maxwell"] = Ln_final_Gigant_Maxwell
except NameError:
  pass

try:
  param_Ln_final["Darwinkel_Maxwell"] = Ln_final_Darwinkel_Maxwell
except NameError:
  pass

try:
  param_Ln_final["Apache"] = Ln_final_Apache
except NameError:
  pass

try:
  param_Ln_final["Renan"] = Ln_final_Renan
except NameError:
  pass

try:
  param_Ln_final["Caphorn"] = Ln_final_Caphorn
except NameError:
  pass

try:
  param_Ln_final["A208"] = Ln_final_A208
except NameError:
  pass

try:
  param_Ln_final["A210"] = Ln_final_A210
except NameError:
  pass

try:
  param_Ln_final["F236"] = Ln_final_F236
except NameError:
  pass

try:
  param_Ln_final["A398"] = Ln_final_A398
except NameError:
  pass


####################
#### PARAMETERS ####
####################

# genotypic parameters are described by python dictionnaries in which the value is associated with the name of the genotype

### SIRIUS PARAMETERS ###

# Final leaf number by SIRIUS
Tvermin             = 0
Tverint             = 8
Tvermax             = 17
Lmax                = 24
Lmin                = 8
DLsat               = 15

# Adjusting phyllochrone to leaf number
Ldecr               = 2
Lincr               = 8
phyllo_decr         = 0.75
phyllo_incr         = 1.25

# Adjusting phyllochron to extreme sowing dates
SDSA = 200                                      # mi-juillet (en DOY)
SDWS = 90                                       # Fin de l'hiver (
Rp = 0.003                                      # decroissement du phyllo 

VAI_Maxwell = 0.00906
VAI_Soissons = 0.00906
VAI_Renan =  0.00456
VAI = {"Maxwell" : VAI_Maxwell, "Gigant_Maxwell" : VAI_Maxwell, "Darwinkel_Maxwell" : VAI_Maxwell, "Soissons" : VAI_Soissons, "Renan" :VAI_Renan}    # Diff�rentes valeurs issues de recalibrations (pour Soissons) He : 0.00906  #Ly : 0.00405  #Lecarpentier :

VBEE_Maxwell =  0.012
VBEE_Soissons = 0.012
VBEE_Renan = 0.012
VBEE = {"Maxwell" :VBEE_Maxwell, "Gigant_Maxwell" :VBEE_Maxwell , "Darwinkel_Maxwell" : VBEE_Maxwell, "Soissons" : VBEE_Soissons, "Renan" : VBEE_Renan}         # Diff�rentes valeurs issues de recalibrations (pour Soissons)  #He : 0.012    #Ly : 0.012    #Lecarpentier : 0.012

SLDL_Maxwell = 1.34
SLDL_Soissons = 1.34
SLDL_Renan = 1.12 
SLDL = {"Maxwell" : SLDL_Maxwell, "Gigant_Maxwell" : SLDL_Maxwell, "Darwinkel_Maxwell" : SLDL_Maxwell, "Soissons" : SLDL_Soissons, "Renan" : SLDL_Renan}           # Diff�rentes valeurs issues de recalibrations (pour Soissons) #He : 1.34     #Ly : 1.467    #Lecarpentier : 

# Final plant height (internodes+peduncle+ear of mainstem)
Param_PlHeight_Maxwell = 55.6155
Param_PlHeight_Soissons = 87.6579
Param_PlHeight_Gigant_Maxwell = 110
Param_PlHeight_Darwinkel_Maxwell = 55.6155

var_registerHeight = ["Param_PlHeight_Maxwell","Param_PlHeight_Soissons","Param_PlHeight_Gigant_Maxwell","Param_PlHeight_Darwinkel_Maxwell"]
  
for key, value, in params.iteritems():
  if key in var_registerHeight:
    exec(key+"=value")

Param_PlHeight = {"Maxwell" : Param_PlHeight_Maxwell, "Gigant_Maxwell" : Param_PlHeight_Gigant_Maxwell, "Darwinkel_Maxwell" : Param_PlHeight_Darwinkel_Maxwell, "Soissons" : Param_PlHeight_Soissons}



## DEVELOPMENT OF VEGETATIVE ORGANS
######################################


# Organ initiation, emergence and elongation
Phl_Maxwell = 99
Phl_Soissons = 87
Phl_Renan = 112


DelayHSToCol = 0.2                                     #temps phyllochronique


ED_I = 1.66 # Duration for internode extension (value extracted directly from ADEL-wheat) (phyllochronic time) | old name : gr_duration_internode
ED_B = 1.6  # Duration for blade extension (phyllochronic time)                                                | old name : gr_duration_blade
ED_FB = 1 # Duration for the extension of the flag blade(phyllochronic time)                                 | old name : gr_duration_flagblade
ED_S = 0.4 # Duration for sheath extension (phyllochronic time)                                                 | old name : gr_duration_sheath
ED_P = 2 # Duration for peduncle extension (phyllochronic time)                                                 | old name : gr_duration_peduncle


# Tiller emergence
Delta_b  = 1            #Delay between the initiation of a bud and the start of its activity (plastochronic unit) | old name : inactive_time_bud

P_T_Maxwell = 0.88
P_T_Soissons = 0.88
P_T = {"Maxwell" : P_T_Maxwell, "Gigant_Maxwell" : P_T_Maxwell, "Darwinkel_Maxwell" : P_T_Maxwell, "Soissons" : P_T_Soissons}  # Probability of emergence of a tiller (except for coleoptil tiller) | old name : tillering_prob

P_CT_Maxwell = 0
P_CT_Soissons = 0
P_CT = {"Maxwell" : P_CT_Maxwell, "Gigant_Maxwell" : P_CT_Maxwell, "Darwinkel_Maxwell" : P_CT_Maxwell, "Soissons" : P_CT_Soissons}              #Probability of emergence of coleoptil tiller | old name : prob_appear_Tc

# Floral transition and final leaf number

Psi_FT = 0 #Thermal time shift between the floral transition of axes belonging to two consecutive cohorts | old name : transiflo_shift_param

Dse_Maxwell_mean = 81
Dse_Maxwell_sd = int(hazard_driver["emerg"]) * 30
Dse_Soissons_mean = 100
Dse_Soissons_sd = int(hazard_driver["emerg"]) * 30
Dse_Thesee_mean = 125
Dse_Thesee_sd = int(hazard_driver["emerg"]) * 30
Dse_Renan_mean = 125
Dse_Renan_sd = int(hazard_driver["emerg"]) * 30

var_registerDSE = ["Dse_Maxwell_mean","Dse_Soissons_mean","Dse_Thesee_mean","Dse_Renan_mean","Dse_Maxwell_sd","Dse_Soissons_sd","Dse_Thesee_sd","Dse_Renan_sd"]

for key, value, in params.iteritems():
  if key in var_registerDSE:
    exec(key+"=value")

Dse = {"Maxwell" : {"mean" : Dse_Maxwell_mean, "sd" : Dse_Maxwell_sd}, "Gigant_Maxwell" : {"mean" : Dse_Maxwell_mean, "sd" : Dse_Maxwell_sd}, "Darwinkel_Maxwell" : {"mean" : Dse_Maxwell_mean, "sd" : Dse_Maxwell_sd}, "Soissons" : {"mean" : Dse_Soissons_mean, "sd" : Dse_Soissons_sd}, "Thesee" : {"mean" : Dse_Thesee_mean, "sd" : Dse_Thesee_sd}, "Renan" : {"mean" :Dse_Renan_mean , "sd" : Dse_Renan_sd}}

N_p_s = 4 #Number of primordia already preformed inside the seed | old name : nb_primord_seed

# Phenology
Delta_hf = 1.3        # Delay between heading and flowering (phyllochronic unit) | old name : delta_epi_flo
Delta_c_GN = 30       # Duration of the critical period determining grain number (days) | old name : duration_critical_period
Delta_hm = 800        # Delay between heading and maturity (in degree-days) | old name : delta_epi_mat
Delta_lflf = 1.39     # Delay between the ligulation of the flag leaf and flowering (phyllochronic units) | old name : delta_ligflagleaf_flo


# Organ final dimensions

## Internode final length

NENC = 98
shp_I_Maxwell = "squared" # Possibilities are: "linear","squared","Homogenous", "Linear", "ExpIncrease", "ExpDecrease"
shp_I_Gigant_Maxwell = "ExpIncrease"
shp_I_Darwinkel_Maxwell = "ExpIncrease"
shp_I_Soissons = "squared"

var_registerShape = ["shp_I_Soissons","shp_I_Maxwell","shp_I_Gigant_Maxwell","shp_I_Darwinkel_Maxwell"]
  
for key, value, in params.iteritems():
  if key in var_registerShape:
    exec(key+"=value")

shp_I = {"Maxwell" : shp_I_Maxwell, "Gigant_Maxwell" : shp_I_Gigant_Maxwell, "Darwinkel_Maxwell" : shp_I_Darwinkel_Maxwell, "Soissons" : shp_I_Soissons} # Shape of the function to determine internode final length



N_I_el_Maxwell = 5
N_I_el_Soissons = 5
N_I_el = {"Maxwell" : N_I_el_Maxwell, "Gigant_Maxwell" :N_I_el_Maxwell , "Darwinkel_Maxwell" : N_I_el_Maxwell, "Soissons" : N_I_el_Soissons } # Number of elongated internodes                               | old name : NENL

### Linear formalism
inc_I_Maxwell = 3.48
inc_I_Soissons = 4.5
inc_I = {"Maxwell" :inc_I_Maxwell , "Gigant_Maxwell" :inc_I_Maxwell , "Darwinkel_Maxwell" :inc_I_Maxwell , "Soissons" : inc_I_Soissons}

### Power formalism
a_I_L_Maxwell = -0.93
a_I_L_Gigant_Maxwell = -0.93
a_I_L_Soissons = 0.79
b_I_L_Maxwell = -0.04
b_I_L_Gigant_Maxwell = -0.04
b_I_L_Soissons = -0.29
a_I_L = {"Maxwell" : a_I_L_Maxwell , "Gigant_Maxwell" : a_I_L_Gigant_Maxwell, "Darwinkel_Maxwell" :a_I_L_Maxwell , "Soissons" :a_I_L_Soissons} #Coefficient for internode final length                | old name : a_internode_squ
b_I_L = {"Maxwell" : b_I_L_Maxwell, "Gigant_Maxwell" :b_I_L_Gigant_Maxwell , "Darwinkel_Maxwell" : b_I_L_Maxwell, "Soissons" : b_I_L_Soissons} #Coefficient for internode final length                | old name : b_internode_squ

## Sheath final length
a_S_L_Maxwell = 0.6919
a_S_L_Gigant_Maxwell = 0.6919
a_S_L_Soissons = 0.6857
b_S_L_Maxwell = -2.6953
b_S_L_Gigant_Maxwell = -2.6953
b_S_L_Soissons = -2.16
a_S_L = {"Maxwell" : a_S_L_Maxwell, "Darwinkel_Maxwell" : a_S_L_Maxwell, "Gigant_Maxwell" : a_S_L_Gigant_Maxwell, "Soissons" : a_S_L_Soissons} # Coefficient for sheath final length                     | old name : a_sheath_length
b_S_L = {"Maxwell" : b_S_L_Maxwell,  "Darwinkel_Maxwell" : b_S_L_Maxwell, "Gigant_Maxwell" : b_S_L_Gigant_Maxwell,"Soissons" : b_S_L_Soissons} # Coefficient for sheath final length (cm)                 | old name : b_sheath_length

## Blade final length
l_c = 0.5                                               #length of the coleoptil at the emergence                    | old name : coleoptil_length
L_B_1_Maxwell = 7
L_B_1_Soissons = 7
L_B_1 = {"Maxwell" : L_B_1_Maxwell, "Darwinkel_Maxwell" : L_B_1_Maxwell, "Gigant_Maxwell" : L_B_1_Maxwell, "Soissons" : L_B_1_Soissons} # Final length of the first blade of each axis (cm)             | old name : first_blade_length

s_B_1_Maxwell = 0.8
s_B_1_Soissons = 0.5
s_B_1 = {"Maxwell" : s_B_1_Maxwell,  "Darwinkel_Maxwell" :s_B_1_Maxwell , "Gigant_Maxwell" : s_B_1_Maxwell,"Soissons" : s_B_1_Soissons} # Final length increment between two successive leaves (bef FT) | old name : incr_Bl

L_B_max_Maxwell = 17.4
L_B_max_Soissons = 22.4

N_B_r_Maxwell = 2
N_B_r_Soissons = 1
N_B_r = {"Maxwell" : N_B_r_Maxwell, "Darwinkel_Maxwell" : N_B_r_Maxwell, "Gigant_Maxwell" : N_B_r_Maxwell, "Soissons" :N_B_r_Soissons} # Number of higher leaves with are smaller than the previous    | old name : nbf_reduce

s_B_f_Maxwell = 0.8
s_B_f_Soissons = 0.92
s_B_f = {"Maxwell" : s_B_f_Maxwell, "Darwinkel_Maxwell" :s_B_f_Maxwell , "Gigant_Maxwell" : s_B_f_Maxwell, "Soissons" : s_B_f_Soissons} # Reduction factor of blade final length w 2 succ leaves        | old name : ratio_flag_blade


## Blade width
b_B_w_Maxwell = -0.3
b_B_w_Soissons = -0.4
a_B_w_Maxwell = 0.099
a_B_w_Soissons = 0.097
b_B_w = {"Maxwell" : b_B_w_Maxwell, "Darwinkel_Maxwell" : b_B_w_Maxwell, "Gigant_Maxwell" : b_B_w_Maxwell, "Soissons" : b_B_w_Soissons} # Coefficient for blade width (cm)                          | old name : b_blade_width

## Fixed dimensions (ear, peduncle, etc.)

d_I_Maxwell = 0.38
d_I_Soissons = 0.2
d_P_Maxwell = 0.25
d_P_Soissons = 0.3
L_P_Maxwell = 22.58
L_P_Soissons = 19.8
d_S_Maxwell = 0.4
d_S_Soissons = 0.32
d_E_Maxwell = 0.4
d_E_Soissons = 0.65
L_E_Maxwell = 7.93
L_E_Soissons = 7.38
d_I = {"Maxwell" : d_I_Maxwell, "Darwinkel_Maxwell" : d_I_Maxwell, "Gigant_Maxwell" : d_I_Maxwell, "Soissons" : d_I_Soissons} # Diameter of the internode  (cm)                                   | old name : internode_diameter
d_P = {"Maxwell" : d_P_Maxwell, "Darwinkel_Maxwell" : d_P_Maxwell, "Gigant_Maxwell" : d_P_Maxwell, "Soissons" : d_P_Soissons} # Diameter of the peduncle (cm)                                     | old name : peduncle_diameter
L_P = {"Maxwell" :L_P_Maxwell , "Darwinkel_Maxwell" : L_P_Maxwell, "Gigant_Maxwell" :L_P_Maxwell , "Soissons" :L_P_Soissons} # Final length of the peduncle (cm)                                | old name : peduncle_length
d_S = {"Maxwell" : d_S_Maxwell, "Darwinkel_Maxwell" : d_S_Maxwell, "Gigant_Maxwell" : d_S_Maxwell, "Soissons" : d_S_Soissons} # Diameter of the sheath (cm)                                   | old name : sheath_diameter
d_E = {"Maxwell" : d_E_Maxwell, "Darwinkel_Maxwell" :d_E_Maxwell , "Gigant_Maxwell" : d_E_Maxwell, "Soissons" : d_E_Soissons} # Diameter of the ear (cm)                                         | old name : ear_diameter
L_E = {"Maxwell" :L_E_Maxwell , "Darwinkel_Maxwell" : L_E_Maxwell, "Gigant_Maxwell" : L_E_Maxwell, "Soissons" : L_E_Soissons} # Final length of the ear (cm)                                     | old name : ear_final_length


# Organ death
# All these parameters are calibrated in order to fit on experimental datas of Mariem Abichou (cv Maxwell) and Jessica Bertheloot (cv Soissons)
n0_sen_Maxwell = 4.75
n0_sen_Soissons =  4.91
n0_sen_Caphorn = 4.76
n1_sen_Maxwell =3.31
n1_sen_Soissons = 3.3
n1_sen_Caphorn = 3.56
n2_sen_Maxwell = 4.5
n2_sen_Soissons =  4.35
n2_sen_Caphorn = 5.19
n3_sen_Maxwell = 0
n3_sen_Soissons = 0
n3_sen_Caphorn = 0
n0_sen = {"Maxwell" : n0_sen_Maxwell,  "Darwinkel_Maxwell" :n0_sen_Maxwell , "Gigant_Maxwell" :n0_sen_Maxwell ,"Soissons" :n0_sen_Soissons, "Caphorn" : n0_sen_Caphorn} # Haun stage of the beginning of the first phase of blade senescence
n1_sen = {"Maxwell" : n1_sen_Maxwell,  "Darwinkel_Maxwell" : n1_sen_Maxwell, "Gigant_Maxwell" : n1_sen_Maxwell,"Soissons" : n1_sen_Soissons, "Caphorn" : n1_sen_Caphorn} # Number of green blades at the end of the first phase of blade senescence
n2_sen = {"Maxwell" : n2_sen_Maxwell,  "Darwinkel_Maxwell" : n2_sen_Maxwell, "Gigant_Maxwell" : n2_sen_Maxwell,"Soissons" :n2_sen_Soissons, "Caphorn" : n2_sen_Caphorn} # Number of green blades at the end of the second phase of blade senescence (only for tillers)
n3_sen = {"Maxwell" :n3_sen_Maxwell , "Darwinkel_Maxwell" : n3_sen_Maxwell, "Gigant_Maxwell" : n3_sen_Maxwell, "Soissons" : n3_sen_Soissons, "Caphorn" :n3_sen_Caphorn } # Number of green blades at the end of blade senescence

t0_sen_Maxwell = 468
t0_sen_Soissons = 468
t0_sen_Caphorn = 382
t1_sen_Maxwell = 691
t1_sen_Soissons = 691
t1_sen_Caphorn = 671
t2_sen_Maxwell = 1131
t2_sen_Soissons = 959
t2_sen_Caphorn = 1050
t3_sen_Maxwell = 2000
t3_sen_Soissons = 1850
t3_sen_Caphorn = 1900
t0_sen = {"Maxwell" : t0_sen_Maxwell,  "Darwinkel_Maxwell" : t0_sen_Maxwell, "Gigant_Maxwell" : t0_sen_Maxwell,"Soissons" :t0_sen_Soissons , "Caphorn" :t0_sen_Caphorn } # Date of the beginning of the blade senescence
t1_sen = {"Maxwell" :t1_sen_Maxwell,  "Darwinkel_Maxwell" : t1_sen_Maxwell, "Gigant_Maxwell" : t1_sen_Maxwell,"Soissons" :t1_sen_Soissons, "Caphorn" :t1_sen_Caphorn } # Date of the end of the first phase of blade senescence
t2_sen = {"Maxwell" : t2_sen_Maxwell, "Darwinkel_Maxwell" : t2_sen_Maxwell, "Gigant_Maxwell" : t2_sen_Maxwell, "Soissons" :t2_sen_Soissons , "Caphorn" : t2_sen_Caphorn} # Date of the second phase of blade senescence (only for tillers)
t3_sen = {"Maxwell" : t3_sen_Maxwell,  "Darwinkel_Maxwell" : t3_sen_Maxwell, "Gigant_Maxwell" : t3_sen_Maxwell,"Soissons" : t3_sen_Soissons, "Caphorn" : t3_sen_Caphorn} # Date of the end of blade senescence

Delta_flsp = 100 #Thermal time delay between the senescence of the flag blade and the beginning of peduncle senescence (en degree-days) | old name : delta_senflagleaf_to_senped


# Plant geometry
Phi_zen_B_Maxwell = 40        # Angle between blade inclination and Y axis | old name : bl_incl_shift
Phi_zen_B_Lely = 40        # Angle between blade inclination and Y axis | old name : bl_incl_shift
Phi_zen_B_Soissons = 40        # Angle between blade inclination and Y axis | old name : bl_incl_shift
Phi_zen_B_Renan = 40        # Angle between blade inclination and Y axis | old name : bl_incl_shift
Phi_zen_B_Gigant_Maxwell = 40        # Angle between blade inclination and Y axis | old name : bl_incl_shift
Phi_zen_B_Darwinkel_Maxwell = 40        # Angle between blade inclination and Y axis | old name : bl_incl_shift
Phi_zen_B_Caphorn = 40        # Angle between blade inclination and Y axis | old name : bl_incl_shift
Phi_zen_B_Apache = 40        # Angle between blade inclination and Y axis | old name : bl_incl_shift
Phi_zen_B_A208 = 40        # Angle between blade inclination and Y axis | old name : bl_incl_shift
Phi_zen_B_A210 = 40        # Angle between blade inclination and Y axis | old name : bl_incl_shift
Phi_zen_B_F236 = 40        # Angle between blade inclination and Y axis | old name : bl_incl_shift
Phi_zen_B_A398 = 40        # Angle between blade inclination and Y axis | old name : bl_incl_shift

Phi_azi_B = 185       # Angle between the azimuth of two consecutive blades | old name : bl_azi_shift
Phi_zen_T = 0         # Angle between the zenith of two consecutive tillers  | old name : till_zen_shift
Phi_azi_T = 40        # Angle between the azimuth of two consecutive tillers | old name : till_azi_shift

Phi_zen_E = 0         # Angle between ear inclination and Y axis | old name : ear_zen_shift
Phi_azi_S = 0         # Angle between seed azimuth and X axis | old name : seed_azi_shift
Phi_zen_S = 0         # Angle between seed inclination and Y axis | old name : seed_zen_shift

# Hazard parameters

# hazard_driver dictionnary will trigger if necessary hazard in different cases:
# if hazard == False : hazard parameter value = 0, if hazard == True, hazard parameter value is set at the value of the parameter

y_position_hazard = int(hazard_driver["plant_xy"]) * 2

if crop_ccptn == "Mesh_for_nplants" or crop_ccptn == "Darwinkel_original":
  x_position_hazard = int(hazard_driver["plant_xy"]) * 2
else:
  x_position_hazard = int(hazard_driver["plant_xy"]) * 3

z_position_hazard = int(hazard_driver["plant_xy"]) * 0

blade_incl_hazard = int(hazard_driver["organ"]) * 5
blade_azi_hazard = int(hazard_driver["organ"]) * 20

till_zen_hazard = int(hazard_driver["axis"]) * 7
till_azi_hazard = int(hazard_driver["axis"]) * 90

plant_azi_hazard = int(hazard_driver["plant_azi"]) * 360


## SELF-ORGANIZED TILLERING RULES
##################################

# Cessation of tillering
GAI_c_Maxwell = 0.59
GAI_c_Soissons = 0.78
GAI_c_Lely = 0.59
GAI_c_Darwinkel_Maxwell = 0.35
GAI_c_Gigant_Maxwell = 0.35
GAI_c_Renan = 0.59
GAI_c_Apache = 0.59
GAI_c_Caphorn = 0.59
GAI_c_A208 = 0.59
GAI_c_A210 = 0.59
GAI_c_F236 = 0.59
GAI_c_A398 = 0.59

var_registerGAI = ["GAI_c_Soissons","GAI_c_Maxwell", "GAI_c_Darwinkel_Maxwell", "GAI_c_Gigant_Maxwell","GAI_c_Lely","GAI_c_Darwinkel_Maxwell","GAI_c_Gigant_Maxwell","GAI_c_Renan","GAI_c_Apache","GAI_c_Caphorn","GAI_c_A208","GAI_c_A210","GAI_c_F236","GAI_c_A398"]

for key, value, in params.iteritems():
  if key in var_registerGAI:
    exec(key+"=value")

GAI_c = {"Maxwell" : GAI_c_Maxwell,  "Darwinkel_Maxwell" : GAI_c_Darwinkel_Maxwell, "Gigant_Maxwell" : GAI_c_Gigant_Maxwell,"Soissons" : GAI_c_Soissons, "Lely" : GAI_c_Lely,"Darwinkel_Maxwell" : GAI_c_Darwinkel_Maxwell,"Gigant_Maxwell" : GAI_c_Gigant_Maxwell,"Renan" : GAI_c_Renan,"Apache" : GAI_c_Apache,"Caphorn" : GAI_c_Caphorn,"A208" : GAI_c_A208,"A210" : GAI_c_A210,"F236" : GAI_c_F236,"A398" : GAI_c_A398} # Green Area Index threshold above which tillering of a plant stops

dGAIp = 1			# Maximal range of plant detection (meter)
L_b_S = 2      # Buried length of the first sheath (in cm) | old name : L_burried


var_registerdGAIp = ["dGAIp"]

for key, value, in params.iteritems():
  if key in var_registerdGAIp:
    exec(key+"=value")



# Tiller death
t_beg_reg_Maxwell = 6.8
t_beg_reg_Darwinkel_Maxwell = 7.8
t_beg_reg_Gigant_Maxwell = 7.8
t_beg_reg_Soissons = 6.8

var_registerT_beg = ["t_beg_reg_Soissons","t_beg_reg_Maxwell","t_beg_reg_Darwinkel_Maxwell","t_beg_reg_Gigant_Maxwell"]

for key, value, in params.iteritems():
  if key in var_registerT_beg:
    exec(key+"=value")

t_beg_reg = {"Maxwell" : t_beg_reg_Maxwell,  "Darwinkel_Maxwell" : t_beg_reg_Darwinkel_Maxwell, "Gigant_Maxwell" : t_beg_reg_Gigant_Maxwell,"Soissons" : t_beg_reg_Soissons} # Date of potentiel beginning of the regression (in Haun Stage unit)

PAR_t_Maxwell = 280000
PAR_t_Soissons = 150000
PAR_t_Lely = 280000
PAR_t_Darwinkel_Maxwell = 100000
PAR_t_Gigant_Maxwell = 100000
PAR_t_Renan = 280000
PAR_t_Apache = 280000
PAR_t_Caphorn = 280000
PAR_t_A208 = 280000
PAR_t_A210 = 280000
PAR_t_F236 = 280000
PAR_t_A398 = 280000

var_registerPARt = ["PAR_t_Soissons","PAR_t_Maxwell", "PAR_t_Darwinkel_Maxwell", "PAR_t_Gigant_Maxwell","PAR_t_Lely","PAR_t_Darwinkel_Maxwell","PAR_t_Gigant_Maxwell","PAR_t_Renan","PAR_t_Apache","PAR_t_Caphorn","PAR_t_A208","PAR_t_A210","PAR_t_F236","PAR_t_A398"]

for key, value, in params.iteritems():
  if key in var_registerPARt:
    exec(key+"=value")

PAR_t = {"Maxwell" : PAR_t_Maxwell,  "Darwinkel_Maxwell" : PAR_t_Darwinkel_Maxwell, "Gigant_Maxwell" : PAR_t_Gigant_Maxwell,"Soissons" : PAR_t_Soissons, "Lely" : PAR_t_Lely,"Darwinkel_Maxwell" : PAR_t_Darwinkel_Maxwell,"Gigant_Maxwell" : PAR_t_Gigant_Maxwell,"Renan" : PAR_t_Renan,"Apache" : PAR_t_Apache,"Caphorn" : PAR_t_Caphorn,"A208" : PAR_t_A208,"A210" : PAR_t_A210,"F236" : PAR_t_F236,"A398" : PAR_t_A398}  # PAR threshold below which a tiller don't survive | old name : PARseuil
Delta_l = 100     #Duration of radiation integration to determine the survival of a tiller (degree-day) | old name : ray_integration


Delta_SGtC = 600                   # Thermal time between the moment a tiller stops growing and its entire removal | old name : delta_stopgr_to_cut
Delta_SGtR = 200                   # Thermal time between the moment a tiller stops growing and the beginning of the reverse growth of leaves | old name : delta_stopgr_to_reg
Delta_Reg = Delta_SGtC - Delta_SGtR # | old name : duration_reg

Delta_prot_Maxwell = 75
Delta_prot_Darwinkel_Maxwell = 25
Delta_prot_Gigant_Maxwell = 25
Delta_prot_Soissons = 50

var_registerDelta_prot = ["Delta_prot_Soissons","Delta_prot_Maxwell", "Delta_prot_Darwinkel_Maxwell", "Delta_prot_Gigant_Maxwell"]

for key, value, in params.iteritems():
  if key in var_registerDelta_prot:
    exec(key+"=value")

Delta_prot = {"Maxwell" : Delta_prot_Maxwell,  "Darwinkel_Maxwell" : Delta_prot_Darwinkel_Maxwell, "Gigant_Maxwell" : Delta_prot_Gigant_Maxwell,"Soissons" : Delta_prot_Soissons}                    # Thermal time interval during which two tillers of the same plant cannot die | old name : duration_plant_protection


# Param�tres communs
#######################

radiation_type    = "diffuse" #or {"diffuse"; "complete"}
PAS               = 24

##

nbj               = 25 + 300                             # Dur�e de la simulation
time_step         = 1.                                   # Temps qui s'�coule   (jour)
Tbase             = 0.                                 


liste_talles = [(1,2),(1,3)]#,(1,4),(1,5),(1,6),(1,7)]



####################
#### VARIABLES  ####
####################

### Globales ###
################

Initialization_count       = 0
nb_voisins_glob            = {}
elapsed_time               = 0                      # Temps �coul� depuis le d�but de la simulation (en jours)
num_j                      = 0                      # Jour actuel
Tempcum                    = 0                      # Temp�ratures cumul�es depuis le d�but de la simulation (degr�s jour)
_Tempcum                   = 0
DOY                        = 0
date_current_day           = 0
#current_PAR                = 0
Temperature                = 0
earliest_plant             = 0
latest_plant               = 0
#datetime.date(2000, 1, 1)

### Locales ###
###############

##### Identification #####
n_init                     = 0                       # Num�ro du phytom�re
tiller_init                = (1,)                    # Num�ro de la talle
num_plante                 = 1                       # Num�ro de la plante cible

##### Variables communes #####
age_init                   = 0                       # Age de l'organe (j)
time_init                  = 0                       # Temps �coul� depuis l'initiation du dernier phytom�re  (j)
nb_j_init                  = 0
sumtemp_init               = 0                       # Somme des temp�ratures accumul�es par l'organe depuis son initiation

##### Dimensions d'organes #####
length_init                = 0.0                    # Taille de l'organe (cm)
width_init                 = 0.0                 # Largeur du limbe (en cm)
diameter_init              = 0.5                      # Diam�tre de l'organe (en cm)
final_length_init          = 0.0                    # Taille finale de l'organe
PAR_init                   = 0                       # Quantit� de Par re�u par l'organe


##### Cin�tique de croissance #####
date_emerg                 = 10000                   # Date d'�mergence de l'organe en temps "global"
gr_init                    = 0

##### Vernalisation #####
vern_rate_init             = 0
vern_prog_init             = 0
Ln_pot_init                = Lmax
Ln_app_init                = Lmax
Ln_final_init              = 100
Lmin_pot_init              = 0

##### Stades de d�veloppement #####
test_res= [True]
real_ts0 = [float("inf")]


### PANDAS DATAFRAME ###

global GAI_dico_df
if CARIBU_state == "enabled":
  GAI_dico_df = {"Init_flag":[], "Elapsed_time":[],"Temp_cum":[],"DOY":[],"Genotype":[],"Num_plante":[],"Surface_plante":[],"Surface_visible":[],"Surface_sol":[],"GAI_tot":[],"GAI_center":[],"GAI_ind":[],"GAI_prox":[],"Position":[], "Weakest_axis":[],"PAR_weakest_axis":[]}
if CARIBU_state == "disabled":
  GAI_dico_df = {"Init_flag":[], "Elapsed_time":[],"Temp_cum":[],"DOY":[],"Genotype":[],"Num_plante":[],"Surface_plante":[],"Surface_visible":[],"Surface_sol":[],"GAI_tot":[],"GAI_center":[],"GAI_ind":[],"GAI_prox":[],"Position":[]}

global Apex_Sirius_dico_df
Apex_Sirius_dico_df = {"Elapsed_time" :[],"Temperature" :[],"Temp_cum" :[], "Daylength" :[], "Num_plante" :[], "Genotype" :[], "PN"  :[], "LN"  :[], "Sumtemp"   :[], "Vern_rate" :[], "Vern_prog" :[], "Vern_flag" :[], "Debut_ppd_flag" :[], "Fin_ppd_flag" :[], "Ln_pot" :[], "Var_L_min" :[],"Ln_app" :[], "Ln_final" :[]}

global Apex_dico_df
Apex_dico_df = {"Elapsed_time" :[], "Temperature" :[], "Temp_cum" :[], "Time_count" :[], "Sum_temp" :[], "Current_PAR" :[], "Num_plante":[],  "Genotype" :[], "Num_talle" :[], "Num_cohorte":[], "Nb_phyto_emi" :[], "Nb_emerged_leaf" :[], "Transiflo_flag" :[], "STOP_init_flag" :[], "Transiflo_DOY" :[],"Ln_final" :[]}

global Apex_R_dico_df
Apex_R_dico_df = {"Elapsed_time" :[], "DOY" : [], "Temperature" :[], "Temp_cum" :[], "Sum_temp" :[], "Num_plante":[], "Genotype" :[], "Num_cohorte":[], "Ln_final":[], "Num_talle" :[], "Date_epiaison" :[], "Epi_DOY" :[], "Date_de_flo" :[], "Mont_flag" :[], "Mont_DOY":[], "Flo_flag" :[], "Flo_DOY" :[], "Death_flag" :[], "Date_de_maturite" : [], "Mat_DOY" : []}

global Blade_df
Blade_dico_df = {"Elapsed_time" :[], "Temp_cum" :[], "Temperature" :[], "Num_plante" :[], "Genotype" :[], "Num_talle" :[], "Num_cohorte" :[], "Num_rang" :[], "Blade_sumtemp" :[], "Blade_width" :[], "Blade_length" :[], "Blade_visible_length" :[], "Blade_final_length" :[], "Blade_visible_surface" :[], "Blade_surface" :[], "Blade_PAR" :[], "Senesc_flag" :[], "Photosynthetic" :[]}

global Internode_dico_df
Internode_dico_df = {"Elapsed_time" :[],  "Temp_cum" :[],  "Temperature" :[],  "Num_plante" :[],  "Genotype" :[],  "Num_talle" :[], "Num_cohorte":[], "Num_rang" :[], "Internode_length" :[],  "Internode_final_length" :[], "Internode_surface" :[], "Internode_PAR" : [], "Photosynthetic" :[]}

global Peduncle_dico_df
Peduncle_dico_df = {"Elapsed_time" :[],  "Temp_cum" :[],  "Temperature" :[],  "Num_plante" :[],  "Genotype" :[],  "Num_talle" :[], "Num_cohorte":[], "Num_rang" :[],"Sum_temp" :[], "Peduncle_length" : [], "Peduncle_final_length" : [], "Peduncle_surface" : [], "Peduncle_PAR" : [], "Photosynthetic" :[]}

global Sheath_dico_df
Sheath_dico_df = {"Elapsed_time" :[],  "Temp_cum" :[],  "Temperature" :[],  "Num_plante" :[],  "Genotype" :[],  "Num_talle" :[] ,"Num_cohorte":[], "Num_rang" :[],"Sheath_sumtemp" :[] ,"Sheath_diameter" :[], "Sheath_length" :[],  "Sheath_final_length" :[], "Sheath_surface" :[], "Sheath_PAR" : [], "Photosynthetic" :[]}

global Ear_dico_df
Ear_dico_df = {"Elapsed_time":[], "Temp_cum" :[], "Num_plante" :[], "Genotype":[], "Num_talle" :[],  "Ear_sumtemp"  :[], "Ear_length" :[], "Ear_surface":[], "Ear_PAR":[], "Photosynthetic" :[], "Emerged" : []}

global Proba_dico_df
Proba_dico_df = {"Elapsed_time":[], "Temperature":[], "Temp_cum":[], "Num_plante":[], "Genotype":[], "Num_talle":[], "Num_rang":[], "Sumtemp":[], "GAI_prox":[], "P_debourr":[]}

global Peraxes_dico_df
Peraxes_dico_df = {"Init_flag":[], "Elapsed_time":[], "DOY":[], "Temperature":[], "Temp_cum":[], "Num_plante":[], "Num_talle":[], "Sheath_max":[], "Collar_height":[], "Dead_collar_height":[], "Delta_H":[], "Visible_leaves_surface":[], "Visible_surface":[], "Stop_growth_flag" : [], "Leaf_contrib_to_GAI" : [], "Stem_contrib_to_GAI" : [], "Ear_contrib_to_GAI" : [], "Peduncle_contrib_to_GAI" : []}

global Debug_PAR_dico_df
Debug_PAR_dico_df = {"Elapsed_time":[], "Temp_cum":[], "Num_plante":[], "Num_talle":[], "Organ_PAR":[], "Organ_type":[], "Num_organe":[], "Organ_surface":[], "Ei":[], "id": [], "tiller_surface": [],"Inc_PAR": []}


if write_output_file["PAR_per_axes"]:
  global PAR_per_axes_dico
  PAR_per_axes_dico = {"Elapsed_time":[], "Temp_cum":[], "Num_plante":[], "Num_talle":[], "Sum_PAR":[], "Inc_PAR":[]}


#######################
###### TABLEAUX #######
#######################

initialization_Flag           = {}
final_blade_length            = {}              # Dico regroupant les tailles finales de tous les limbes par individu, par talle, par phytom�re
current_sheath_length         = {}              # Dico regroupant les tailles actuelles de gaines par individu, par talle, par phytom�re
dead_sheath_length            = {}
current_internode_length      = {}              # Dico regroupant les tailles actuelles de gaines par individu, par talle, par phytom�re
dico_voisins                  = {}              # Dico regroupant la liste de totues les plantes voisines en fonction de la "port�e" du voisinage
maillage                      = []              # Tableau repr�sentant la disposition des individus en nombre de plante
border_plants                 = []
surface_sol                   = {}              # Dico regroupant la surface de sol inh�rente � chaque individu
GAI_prox                      = {}              # Dico regroupant le GAI d'un sous-peuplement constitu� d'une plante cible ainsi que de ses voisins
GAI_ind                       = {}
LNfinal                       = {}              #TODO Attention ce dico est obsolete il faudra le virer pour �purer un peu ce beau code
tiller_death                  = {}              # Dico re�ensant toutes les talles qui doivent mourir (test� � Montaison)
tiller_death_now              = {}              # Dico listant toutes les talles qui sont sens�es mourir � CE PAS DE TEMPS PRECIS
date_emission                 = {}
dico_stades                   = {}
photoperiode                  = []
leaf_emergence                = {}
dead_tillers                  = {}
PAR_intercepted               = {}
axis_census                   = {}
Dse_heterogeneous             = {}
t_beg_reg_ind_Tht             = {}
MSLn_app                      = {}
first_leaf_phase2             = {}
genotype_map                  = {}
plant_map                     = {}


#Scheduling of events

tiller_2_ts0                  = {(1,1):0,(1,2):0,(1,3):0,(1,4):0,(1,5):0,(1,6):0,(1,7):0}
cohort_2_ts0                  = {1: 633, 2: 693, 3: 761, 4: 709, 5: 847, 6: 855, 7: 864, 8: 693, 9: 693, 10: 633, 11: 573}

dico_PAR                      = {}              # Dico dans lequel on stocke les informations de PAR capt� par organe
dico_PAR["Blade"]             = {}                          # On formatte le dico pour qu'il capte des infos concernant les blades
dico_PAR["Sheath"]            = {}
dico_PAR["Internode"]         = {}
dico_PAR["Peduncle"]          = {}
dico_PAR["Ear"]               = {}

#### Pour le calcul du GAI ##########
tiller_surface                    = {}
surface_plante                    = {}              # Dico regroupant les surfaces actuelles de plantes par individu
surface_plante_visible            = {}

Sh_max                            = {}
Hcol_max                          = {}
Hcol_dead                         = {}
delta_H                           = {}
#####################################

future_dead_axes              = {}
dico_PAR_per_axis             = {}
dico_cut_fantom_axes          = {}
dico_cut_dead_blades          = {}
young_tiller                  = {}
youngest_axis                 = {}

# Pour la r�gression des talles
liste_tal                     = {}
axis_order                    = {}
weaker_order                  = {}
weakers_pos                   = {}
weakers                       = {}
youngest_axes                 = {}
weakest_axis                  = {}
plant_shield_indicator        = {}

# Al�atoire :
positions                     = {}
hazard_dict_organ             = {}
hazard_dict_axis              = {}
hazard_dict_plant             = {}


color=[0,4,5,7,8,6,9,10,11]                     # Couleur pour bien diff�rencier les diff�rents g�notypes
organ_type = ["Blade", "Internode", "Sheath","Peduncle", "Ear"]
#organ_type = ["Blade","Sheath","Internode","Peduncle"]

##################################################################################


####################################################################################
############################# DEFINITION DE FONCTION ###############################
####################################################################################

# Disposition des plantes sur la parcelle
def crop_conception(densite, nb_rang, dist_inter_rang, nb_plante_min, nb_plante_max):
  dx = nb_rang*dist_inter_rang
  nb_rang_m2 = 1/dist_inter_rang
  nb_plante_par_rang_m2 = densite/nb_rang_m2
  dist_intra_rang = 1/nb_plante_par_rang_m2
  nb_plt_p_rang_min = nb_min_plt/nb_rang
  nb_plt_p_rang_max = nb_max_plt/nb_rang
  crop_scheme["dx"],crop_scheme["dist_intra_rang"] = dx, dist_intra_rang
  resultats = {}
  if nb_min_plt == nb_max_plt == 1:
    nb_plante_par_rang = 1
    nb_rang = 1
    dx, dy = dist_inter_rang, 1/nb_plante_par_rang_m2
    nplant_peupl = 1
    crop_scheme["dy"] = dy
    crop_scheme["nb_plante_par_rang"], crop_scheme["nplant_peupl"] = int(nb_plante_par_rang), int(nplant_peupl)
  else:
    if round(nb_plt_p_rang_max*dist_intra_rang,2)-round(nb_plt_p_rang_min*dist_intra_rang,2) < 0.01:
      dy = round(nb_plt_p_rang_min*dist_intra_rang,2)
      nb_plante_par_rang = floor(dy * nb_plante_par_rang_m2)
      nplant_peupl = nb_rang * nb_plante_par_rang
      surface_sol = dx * dy
      virtual_density = nplant_peupl / surface_sol
      ecart_de_densite = abs(densite - virtual_density)/densite
      resultats[ecart_de_densite] = (dx,dy)
      crop_scheme["nb_plante_par_rang"], crop_scheme["nplant_peupl"] = int(nb_plante_par_rang), int(nplant_peupl)
    else:
      for dy in np.arange(round(nb_plt_p_rang_min*dist_intra_rang,2), round(nb_plt_p_rang_max*dist_intra_rang,2), 0.01):
        nb_plante_par_rang = floor(dy * nb_plante_par_rang_m2)
        nplant_peupl = nb_rang * nb_plante_par_rang
        surface_sol = dx * dy
        virtual_density = nplant_peupl / surface_sol
        ecart_de_densite = abs(densite - virtual_density)/densite
        resultats[ecart_de_densite] = (round(dx,2),round(dy,2))
    # On r�cup�re la combinaison de dx et dy pour lesquels il y'a le plus faible �cart de densit� !
      dy = round(resultats[min(resultats.keys())][1],2)
      nb_plante_par_rang = floor(dy * nb_plante_par_rang_m2)
      nplant_peupl = nb_rang * nb_plante_par_rang
      crop_scheme["nb_plante_par_rang"], crop_scheme["nplant_peupl"] = int(nb_plante_par_rang), int(nplant_peupl)
    crop_scheme["dy"] = dy
    if min(resultats.keys())*100 > 5:
      print "ATTENTION ERREUR CONSEQUENTE DE PREDICTION DE LA DENSITE"
  crop_scheme["surface_sol"] = dx*dy
  crop_scheme["map_middle_y"] = ((crop_scheme["nb_rang"] * (crop_scheme["dist_inter_rang"])*100) + (crop_scheme["dist_inter_rang"])*100)/2
  crop_scheme["map_middle_x"] = ((crop_scheme["nb_plante_par_rang"] * (crop_scheme["dist_intra_rang"])*100) + (crop_scheme["dist_intra_rang"])*100)/2
  return crop_scheme


# Geographical disposition of all plants on the soil (Sowing)
def plant_disposition(nb_rang, nb_plante_par_rang, dist_inter_rang, dist_intra_rang):
  num_plante = 0
  y = 0
  for rang in range(int(nb_rang)):
    x = 0
    y += (dist_inter_rang * 100)
    prov = []
    for plant_par_rang in range(int(nb_plante_par_rang)):
      x += (dist_intra_rang * 100)
      z = 0.
      num_plante += 1
      plant_map[num_plante] = {"x":x,"y":y}
      prov.append(num_plante)
    maillage.append(prov)
  return(maillage)
  return(plant_map)



# fonction qui permet de centrer les plantes sur le rep�re orthonorm�
def plant_translation(x_plant, y_plant, x_middle, y_middle):
  new_coordinates = {}
  new_coordinates["x"] = x_plant - x_middle
  new_coordinates["y"] = y_plant - y_middle
  return(new_coordinates)

# Physical calculation of daylength
def duree_du_jour(lat, J):
  delta = asin(0.4*sin((2*pi*(J-80))/365))
  lat = (pi * lat)/180
  return 24*(1-(acos(tan(delta)*tan(lat)))/pi)

# Manipulation of meteo table in case of direct radiation
def read_meteo(dico_meteo,start_day,start_hour,PAS):
  val1 = 0
  val2 = 0
  for i in range(PAS):
    mykey = (start_day,start_hour+i)
    #print mykey, i, start_hour
    val1 += dico_meteo[mykey][0]
    val2 += dico_meteo[mykey][1]
  # val1 = RG ; val2 = Rd/Rg
  return val1,val2/PAS

# Choose the neighbours of a plant
def set_neighbour(maillage, nb_rang, nb_plante_par_rang, d_intra, d_inter, dGAIprox, infin):
  #TODO prendre en compte l'alea de positionnement des graines dans la determination des voisins dune plante cible
  voisins=[]
  neighbour_indexes=[]
  ncol = int(round(2*dGAIprox/d_inter)) + 1
  nrow = int(round(2*dGAIprox/d_intra)) + 1
  for j in range(ncol):
    for i in range(nrow):
      delta_j = j - int(round(dGAIprox/d_inter))
      delta_i = i -int(round(dGAIprox/d_intra))
      d_to_cible = sqrt( (delta_j*d_inter)**2 + (delta_i*d_intra)**2 )
      if d_to_cible <= dGAIprox:
        neighbour_indexes.append((delta_j, delta_i))
  nb_voisins_glob[0] = len(neighbour_indexes)
  #####
  num_plante = 0
  for num_col in range(nb_rang):
    for num_ligne in range(nb_plante_par_rang):
      num_plante += 1
      plante_cible = maillage[num_col][num_ligne]
      for (deltaj,deltai) in neighbour_indexes:
        if infin == "True":
          voisins.append( maillage[(num_col+deltaj)%nb_rang][(num_ligne+deltai)%nb_plante_par_rang] )
        else:
          if (0 <= num_col+deltaj < nb_rang) and (0 <= num_ligne+deltai < nb_plante_par_rang):
            voisins.append( maillage[(num_col+deltaj)][(num_ligne+deltai)] )
      dico_voisins[plante_cible] = voisins
      voisins=[]


#SCHEDULING OF EVENTS
########################

# Determining the cohort number of the axis
def cohort_number(tiller):
  return (len(tiller) + sum(tiller)) - 3

def synchrone_correspondance(tiller):
  if tiller == (1,):
    return 1
  else:
    l = 0
    n = 1
    for l in range(1,len(tiller)):
      new_tiller = tiller[0:len(tiller)-1]
      new_n = tiller[-1] + 2 + (n-1)
      #print new_tiller, new_n
      tiller = new_tiller
      n = new_n
      l += 1
      if tiller == (1,):
        return n

def Haun_Stage(Tht, tiller, Ln_final, phyllo, Dse, DelayTipToHS):
  tHS0 = Dse + (synchrone_correspondance(tiller) - 1) * phyllo + DelayTipToHS
  tHSf = tHS0 + Ln_final * phyllo
  if Tht <= tHS0:
    return 0
  elif tHS0 < Tht < tHSf:
    a = 1/phyllo
    b = - (1/phyllo) * tHS0
    return a * Tht + b
  else:
    return Ln_final


def SSI_MS(Tht, Ln_final, phyllo, n0, n1, n3, ts1, ts3, Dse, DelayTipToHS):
  tHS0 = Dse + (synchrone_correspondance((1,)) - 1) * phyllo + DelayTipToHS
  real_ts0 = (Dse + DelayTipToHS) + n0 * phyllo
  real_ts1 = ts1 + (Dse + DelayTipToHS)
  real_ts3 = ts3 + (Dse + DelayTipToHS)
  npot1 = (real_ts1 - tHS0)/phyllo
  s1 = npot1 - n1
  #Premiere phase de senescence
  if Tht < tHS0:
    a = 0
    b = 0
  elif tHS0 <= Tht < real_ts1:
    s0 = 0 #Nombre de feuilles mortes � t0
    a = (s1 - s0)/(real_ts1 - real_ts0)
    b = s1 - a*real_ts1
  #Deuxieme phase de senescence
  elif real_ts1 <= Tht <= real_ts3:
    s3 = Ln_final                #Nombre de feuilles mortes � t2
    a = (s3 - s1)/(real_ts3 - real_ts1)
    b = s3 - a*real_ts3
  elif Tht > real_ts3:
    a = 0
    b = Ln_final
  return max(0,((a * Tht) + b))

def Green_Leaves(Haun_Stage, SSI):
  return Haun_Stage - SSI

Ln_final_dict = {(1,) : 11, (1,1):9, (1,2):8, (1,3):7, (1,4):7, (1,5):6, (1,4):5, (1,6):5, (1,7):4}

def junction_test(Tht, tiller, Ln_final, phyllo, n0, n1, n3, ts1, ts3, Dse, DelayTipToHS, test_res):
  HS_BM = Haun_Stage(Tht, (1,), Ln_final, phyllo, Dse, DelayTipToHS)
  HS_tiller = Haun_Stage(Tht, tiller, Ln_final, phyllo, Dse, DelayTipToHS)
  GL_BM = Green_Leaves(Haun_Stage(Tht, (1,), Ln_final, phyllo, Dse, DelayTipToHS), SSI_MS(Tht, Ln_final, phyllo, n0, n1, n3, ts1, ts3, Dse, DelayTipToHS))
  if HS_BM != 0 and HS_tiller >= GL_BM:
    return False
  else:
    return True

def define_ts0(Tht, tiller, Ln_final, phyllo, n1, n3, ts1, ts3, Dse, DelayTipToHS, test_res):
  if test_res[0]== True:
    test_res[0] = junction_test(Tht, tiller, Ln_final, phyllo, n0, n1, n3, ts1, ts3, Dse, DelayTipToHS, test_res[0])
    real_ts0[0] = Tht
  tiller_2_ts0[tiller] = real_ts0[0]

def SSI_tiller(Tht, tiller, Ln_final, phyllo, n1, n3, ts1, ts3, Dse, DelayTipToHS, test_res):
  tHS0 = Dse + (synchrone_correspondance(tiller) - 1) * phyllo + DelayTipToHS
  define_ts0(Tht, tiller, Ln_final, phyllo, n1, n3, ts1, ts3, Dse, DelayTipToHS, test_res)
  real_ts1 = ts1 + (Dse + DelayTipToHS)
  real_ts3 = ts3 + (Dse + DelayTipToHS)
  npot1 = (real_ts1 - tHS0)/phyllo
  s1 = npot1 - n1
  #Premiere phase de senescence
  if Tht < tHS0:
    a = 0
    b = 0
  elif tHS0 <= Tht < real_ts1:
    s0 = 0 #Nombre de feuilles mortes � t0
    a = (s1 - s0)/(real_ts1 - real_ts0[0])
    b = s1 - a*real_ts1
  #Deuxieme phase de senescence
  elif real_ts1 <= Tht <= real_ts3:
    s3 = Ln_final                #Nombre de feuilles mortes � t2
    a = (s3 - s1)/(real_ts3 - real_ts1)
    b = s3 - a*real_ts3
  elif Tht > real_ts3:
    a = 0
    b = Ln_final
  #~ print "Tht : ", Tht,"Ts0 : ", real_ts0[0]
  return max(0,((a * Tht) + b))

# Emergence date
def leaf_emerg_date(n, tiller, geno, num_plante):
  if tiller == (1,):
    return Dse_heterogeneous[num_plante] + (n-1) * phyll_adjust(geno)
  l = 0
  for l in range(1,len(tiller)):
    new_tiller = tiller[0:len(tiller)-1]
    new_n = tiller[-1] + 2 + (n-1)
    tiller = new_tiller
    n = new_n
    l += 1
    if tiller == (1,):
      return Dse_heterogeneous[num_plante] + (n-1) * phyll_adjust(geno)


def leaves_senesc_date_main_stem(n, Ln_final, phyllo, n0, n1, n3, ts1, ts3, Dse, DelayTipToHS):
  tHS0 = Dse + (synchrone_correspondance((1,)) - 1) * phyllo + DelayTipToHS
  real_ts0 = (Dse + DelayTipToHS) + n0 * phyllo
  real_ts1 = (Dse + DelayTipToHS) + ts1
  real_ts3 = (Dse + DelayTipToHS) + ts3
  npot1 = (real_ts1 - tHS0)/phyllo
  s1 = npot1 - n1
  #Premiere phase de senescence
  if 0 <= n < s1:
    s0 = 0 #Nombre de feuilles mortes � t0
    a = (real_ts1 - real_ts0)/(s1 - s0)
    b = real_ts1 - a*s1
    return (a * n) + b
  elif s1 <= n <= Ln_final:
    s3 = Ln_final                #Nombre de feuilles mortes � t2
    a = (real_ts3 - real_ts1)/(s3 - s1)
    b = real_ts3 - a*s3
    return (a * n) + b

#def leaves_senesc_date_tiller(n, tiller, Ln_final, phyllo, n0, n1, n3, ts1, ts3, Dse, DelayTipToHS):
#  tHS0 = Dse + (synchrone_correspondance(tiller) - 1) * phyllo + DelayTipToHS
#  real_ts0 = cohort_2_ts0[cohort_number(tiller)]
#  real_ts1 = (Dse + DelayTipToHS) + ts1
#  real_ts3 = (Dse + DelayTipToHS) + ts3
#  npot1 = (real_ts1 - tHS0)/phyllo
#  s1 = npot1 - n1
#  #Premiere phase de senescence
#  if 0 <= n < s1:
#    s0 = 0 #Nombre de feuilles mortes � t0
#    a = (real_ts1 - real_ts0)/(s1 - s0)
#    b = real_ts1 - a*s1
#    return (a * n) + b
#  elif s1 <= n <= Ln_final:
#    s3 = Ln_final                #Nombre de feuilles mortes � t2
#    a = (real_ts3 - real_ts1)/(s3 - s1)
#    b = real_ts3 - a*s3
#    return (a * n) + b

def leaves_senesc_date_tiller(n, tiller, Ln_final, phyllo, n0, n1, n2, n3, ts1,ts2, ts3, Dse, DelayTipToHS):
  tHS0 = Dse + (synchrone_correspondance(tiller) - 1) * phyllo + DelayTipToHS
  real_ts0 = cohort_2_ts0[cohort_number(tiller)]
  real_ts1 = (Dse + DelayTipToHS) + ts1
  real_ts2 = (Dse + DelayTipToHS) + ts2
  real_ts3 = (Dse + DelayTipToHS) + ts3
  npot1 = (real_ts1 - tHS0)/phyllo
  npot2 = (real_ts2 - tHS0)/phyllo
  s1 = npot1 - n1
  s2 = npot2 - n2
  #Premiere phase de senescence
  if 0 <= n < s1:
    s0 = 0 #Nombre de feuilles mortes � t0
    a = (real_ts1 - real_ts0)/(s1 - s0)
    b = real_ts1 - a*s1
    return (a * n) + b
  elif s1 <= n < s2:
    a = (real_ts2 - real_ts1)/(s2 - s1)
    b = real_ts2 - a*s2
    return (a * n) + b
  elif s2 <= n <= Ln_final:
    s3 = Ln_final                #Nombre de feuilles mortes � t2
    a = (real_ts3 - real_ts2)/(s3 - s2)
    b = real_ts2 - a*s2
    return (a * n) + b



# Number of emerged leaves
def nb_emerged_leaves(tempcum, tiller, geno, Ln_final):
  if tiller == (1,):
    return min(max(0,((tempcum - Dse_heterogeneous[num_plante])/phyll_adjust(geno)) + 1), Ln_final)
  else:
    tiller_emergence_date = leaf_emerg_date(1, tiller, geno, num_plante)
    return min(max(0,((tempcum - tiller_emergence_date)/phyll_adjust(geno)) + 1), Ln_final)


# Senescence date (in case of knowing the final leaf number of the axis)

#def date_senescence(n, Ln_final, phyllo, n0, n1, n3, t0, t1, t3):
#  n1pot = (t1 - t0)/phyllo
#
#  #Premiere phase de senescence
#  if n <= (n1pot + (n0 - n1)):
#    s0 = 0 #Nombre de feuilles mortes � t0
#    s1 = n1pot + (n0 - n1) #Nombre de feuilles mortes � t1
#
#    a = (t1 - t0) /(s1 - s0)
#    b = ((t0*s1) - (t1*s0))/(s1 - s0)
#
#  #Deuxieme phase de senescence
#  elif (n1pot + (n0 - n1)) < n <= Ln_final:
#    s1 = n1pot + (n0 - n1) #Nombre de feuilles mortes � t1
#    s2 = Ln_final                #Nombre de feuilles mortes � t2
#
#    a = (t3 - t1)/(s2 - s1)
#    b = ((t1*s2) - (t3*s1))/(s2 - s1)
#
#  return a * (n) + b


# Temporary date of senescence (in case of NOT knowing the final leaf number on the axis)
def date_senescence_fake(n, t0):
  #calcul interm�diaires pour la premi�re phase de s�nescence
  #print "/|\ Date de s�nescence douteuse !"
  return t0 + n/0.015

# Setting a delay of floral transition of tiller according to the cohort number
def transiflo_shift(tiller, geno):
  cohort_num = cohort_number(tiller)
  if cohort_num == 1:
    return 10
  elif cohort_num > 1:
    return (cohort_num-1) * (Psi_FT * Pls[geno])
  else:
    return 0


# TILLERING
##############


# Estimating the probability of emergence of a bud (taking into account the GAI)
def proba_debourr(tiller, GAIprox, geno, n, Ln_final):
  if tiller == (1,1):
    return P_CT[geno]
  else:
    #NENC = (Ln_final - liste_geno[geno]["NENL"])+1
    NENC = (Ln_final - 4)
    if GAIprox < GAI_c[geno]:
      if n < NENC:
        return P_T[geno]
      else:
        return 0
    else:
      return 0



# ORGAN FINAL DIMENSIONS
###########################

# Determining a specific blade final length
def FindBlade_length(num_plante, tiller):
  n = 1
  l = 0
  for l in range(1,len(tiller)):
    new_tiller = tiller[0:len(tiller)-1]
    new_n = tiller[-1] + 2 + (n-1)
    tiller = new_tiller
    n = new_n
    l += 1
    if tiller == (1,):
      return final_blade_length[num_plante][tiller][n-1]


### BLADE LENGTH ###

#### USE IT ####


# Calculating the increment during the juvenile phase specifying the length of penultimate bladeTaking into account the effect of temperature)
def incr_repro_penlt_leaf(lg_first_leaf_ph2, lg_penultimate_leaf, nb_leaves_axis):
  remaining_length_to_grow = lg_penultimate_leaf - lg_first_leaf_ph2
  incr = remaining_length_to_grow/nb_leaves_axis
  return incr

def flag_leaf_blade_length(geno, lg_previous_leaf, ratio):
  return lg_previous_leaf * ratio


### SHEATH LENGTH ###

# Calculating sheath final length (from data of blade final length)

def sheath_length(bld_lgt, a_sh_length, b_sh_length):
  return (a_sh_length * bld_lgt) + b_sh_length

### BLADE WIDTH ###

# Calculating blade maximal width (from data of blade final length)
def blade_width(bld_lgt, a_bl_width, b_bl_width):
  return (a_bl_width * bld_lgt) + b_bl_width

#CALCULATION OF THE VISIBLE SURFACE OF A BLADE
def visible_area(length_from_the_top, width_max, total_length):
  if length_from_the_top <= total_length/2:
    current_width = (width_max * length_from_the_top)/total_length/2
    vis_area = (current_width * length_from_the_top) / 2
  elif length_from_the_top > total_length/2:
    triangle_area = width_max * total_length/4
    rectangle_area = (width_max * (length_from_the_top - total_length/2))
    vis_area = triangle_area + rectangle_area
  return vis_area


### INTERNODE FINAL LENGTH ###

# Finding the possible range of a and b values, for a given height and NENL
# these a and b values are used when shape = 'ExpIncrease' or shape = 'ExpDecrease'

def getRangeHeightPar(ranh,ranNENL,rangeno,leaf_nf):        
    l_ear = L_E[rangeno]
    l_short = 0            
    #DETERMINING A'S RANGE, setting a < 0
    alpha_a = (ranNENL+1)**2*(ranNENL+2)*( (ranNENL+2) - (2/3)*(2*ranNENL+3) ) # n�gatif si NENL=5
    beta_a = -4 * (ranNENL+1) * ( l_ear - ranh + l_short*(leaf_nf - ranNENL) ) # est positif quand h > l_ear
    if alpha_a >= 0:
        print 'NENL =  ' + str(ranNENL) + '    unextected NENL?'
        if alpha_a == 0:
            print 'a range problem : division by 0'
            posrange_a = [np.nan, np.nan]
        elif beta_a*alpha_a > 0:
            print 'a range problem : square root of negative number'
            posrange_a = [np.nan, np.nan]
        elif beta_a*alpha_a < 0:
            val_a = -sqrt(-beta_a / alpha_a )            
            posrange_a = [-100, val_a] # would actually be -infinity
    elif alpha_a < 0:
        if beta_a*alpha_a > 0:
            print 'a range problem : square root of negative number'
            posrange_a = [np.nan, np.nan]
        elif beta_a*alpha_a < 0:
            val_a = -sqrt(-beta_a / alpha_a ) # val_a is the value for which delta = 0, a < 0            
            posrange_a = [val_a,0]    
    # DETERMINIG B'S RANGE, setting b > 0    
    alpha_b = (ranNENL+1)**2*(ranNENL+2)*( (ranNENL+2) - (2/3)*(2*ranNENL+3) ) 
    beta_b = (-2/3)*(ranNENL+1)*(ranNENL+2)*(2*ranNENL+3)*( l_ear - ranh + l_short*(leaf_nf - ranNENL) ) 
    if alpha_b >= 0: 
        print 'NENL =  ' + str(ranNENL) + '    unextected NENL?'
        if alpha_b == 0:
            print 'b range problem : division by 0'
            posrange_b = [np.nan, np.nan]
        elif beta_b*alpha_b > 0:
            print 'b range problem : square root of negative number'
            posrange_b = [np.nan, np.nan]
        elif beta_b*alpha_b < 0:
            val_b = -sqrt(-beta_b / alpha_b )            
            posrange_b = [val_b, 100] # would actually be +infinity         
    elif alpha_b < 0: # is what we have for NENL = 5    
        if beta_b*alpha_b > 0:
            print 'b range problem : square root of negative number'
            posrange_b = [np.nan, np.nan]
        elif beta_b*alpha_b < 0:
            val_b = sqrt(-beta_b / alpha_b ) # val_b is the value for which delta = 0, b > 0       
            posrange_b = [0, val_b]        
    return [posrange_a, posrange_b]

# provides a, b or NENL, knowing all of the other parameters and the height (the parameter we want is ppar_of_interest, and we set it as nan)
# used when when shape = 'ExpIncrease' or shape = 'ExpDecrease'

def getHeightPar(ph, pgeno, pa, pb, pNENL, leaf_nf, ppar_of_interest):
    l_ear = L_E[pgeno] 
    l_short = 0    
    if ppar_of_interest == 'a': # knowing h, b and NENL
        p_0 = (pNENL+1)*(pNENL+2)*(2*pNENL+3)*(1/6)
        p_1 = (pNENL+1)*(pNENL+2)*pb
        p_2 = l_ear + (leaf_nf - pNENL)*l_short + (pNENL+1)*pb**2 - ph
        p = [p_0, p_1, p_2]
        roots = np.roots(p)
        return ['a', roots]        
    if ppar_of_interest == 'b': # knowing h, a and NENL
        p_0 = (pNENL+1)
        p_1 = (pNENL+1)*(pNENL+2)*pa
        p_2 = l_ear + (leaf_nf - pNENL)*l_short + (pNENL+1)*(pNENL+2)*(pa**2)*(2*pNENL + 3)*(1/6 ) - ph
        p = [p_0, p_1, p_2]
        roots = np.roots(p)
        return ['b', roots]    
    if ppar_of_interest == 'NENL': # knowing h, a and b 
        p_0 = (pa**2)/3
        p_1 = pa*pb + (pa**2)*(3/2)
        p_2 = pb**2 - l_short + 3*pa*pb + (pa**2)*(13/6)
        p_3 = l_ear + leaf_nf*l_short + pb**2 + 2*pa*pb + pa**2 - ph
        p = [p_0, p_1, p_2, p_3]
        roots = np.roots(p)[np.isreal(np.roots(p))]
        return ['NENL', abs(roots)]


# Calculating internode final length fixing the number of elongated internodes

def EN_fin_length(n, Ln_final, geno, shape, PlHeight):
  n0 = Ln_final - N_I_el[geno]
  rel_rank = n - n0
  l_ear = L_E[geno]
  l_ped = L_P[geno]
  l_short = 0
  if n <= n0:
    return 0.00
  else:
    if shape == "linear":
      if n > Ln_final:
        return L_P[geno]
      else:
        return inc_I[geno] * n - (inc_I[geno] * n0)
    elif shape == "squared":
      a_squ = a_I_L[geno]
      b_squ = b_I_L[geno]
      return (a_squ * rel_rank + b_squ)**2
    elif shape == "Homogenous":
      intH = ( PlHeight - l_ear - l_short*(Ln_final - N_I_el[geno]) ) / (N_I_el[geno] + 1)
      return intH
    elif shape == "Linear":
      if geno == 'Maxwell':
        l_ped = l_ped*(1-(90-PlHeight)*1.3/100)
      if geno == 'Soissons':
        l_ped = l_ped*(1-(110-PlHeight)/100)
      aL = ( l_ped - ( PlHeight - l_ear - l_short*(Ln_final - N_I_el[geno]) )/(N_I_el[geno] + 1) ) * (2/N_I_el[geno])
      bL = l_ped - aL*(N_I_el[geno]+1)
      intL = aL*rel_rank + bL
      return intL
    elif shape == "ExpIncrease":
      aEi = getRangeHeightPar(ranh=PlHeight, ranNENL=N_I_el[geno] ,rangeno=geno, leaf_nf=Ln_final)[0][0]*(3/6)        
      bEi = min(getHeightPar(ph=PlHeight, pgeno=geno, pa=aEi, pb=np.nan, pNENL=N_I_el[geno], leaf_nf=Ln_final, ppar_of_interest='b')[1])  
      intEi = ( aEi*rel_rank + bEi)**2
      return intEi
    elif shape == "ExpDecrease":
      aEd = getRangeHeightPar(ranh=PlHeight, ranNENL=N_I_el[geno] ,rangeno=geno, leaf_nf=Ln_final)[0][0]*(3/6)        
      bEd = max(getHeightPar(ph=PlHeight, pgeno=geno, pa=aEd, pb=np.nan, pNENL=N_I_el[geno], leaf_nf=Ln_final, ppar_of_interest='b')[1])        
      intEd = (aEd*rel_rank + bEd)**2        
      return intEd


#### PHYLLOTAXY #####

def blade_phyllotaxy(n, tiller, num_plante, NENL, Phi_azi_B, blade_azi_hazard):
  hazard_dict_organ[num_plante][tiller][n]["blade_azimuth"] = Phi_azi_B + random.uniform(-blade_azi_hazard, blade_azi_hazard)


# FUNCTIONS EXTRACTED FROM SIRIUS
####################################

# Calcul de l'impact de la vernalisation au temps t
def vrate(Tt,geno):
  if Tt<Tvermin or Tt>Tvermax:
    Vrate = 0
  elif Tt<= Tverint:
    Vrate = (VAI[geno] * Tt + VBEE[geno])
  else:
    Vrate = (VAI[geno] * Tverint + VBEE[geno]) * ((Tvermax - Tt)/(Tvermax - Tverint))
  return Vrate

# INITIALISATION OF THE MODEL
################################

def plasto_seed(delay_sowing_emergence, nb_p_seed):
  return delay_sowing_emergence/nb_p_seed




# YIELD
##########

# Nombre de grains produits
def calc_grain_nb(T, PAR):
  nb_epi_msqu = 592
  photothermal_quotient = PAR/T
  grain_nb =  (2600 + 8510 * photothermal_quotient)/nb_epi_msqu
  return grain_nb

def age_phyto_seed(num_phyto, N_p_s, geno):
  return (N_p_s - num_phyto) * Pls[geno]

############################ REGLER DES PROBLEMES D'ENCODAGE ##############################

def byteify(input):
    if isinstance(input, dict):
        return {byteify(key): byteify(value)
                for key, value in input.iteritems()}
    elif isinstance(input, list):
        return [byteify(element) for element in input]
    elif isinstance(input, unicode):
        return input.encode('utf-8')
    else:
        return input

##########################################################################
#####                EDITING CLASS FOR ORGAN TYPES                   #####
##########################################################################


class Seed:
  def __init__(self, num_plante, geno):
    self.num_plante = num_plante
    self.geno = geno


class Organ_Base:
  def __init__(self, num_plante, geno, tiller, n):
    self.num_plante = num_plante
    self.geno = geno
    self.tiller = tiller
    self.n = n
    self.age = 0
    self.sumtemp = 0
    self.length = 0

class Bud_primord(Organ_Base):
  def __init__(self, num_plante, geno, tiller, n):
    Organ_Base.__init__(self, num_plante, geno, tiller, n)
    #self.tiller_incl = 0
    self.sumtemp = 0
    self.competent_flag = False

class Bud(Organ_Base):
  def __init__(self, num_plante, geno, tiller, n, time):
    Organ_Base.__init__(self, num_plante, geno, tiller, n)
    self.nb_primord = 0
    self.nb_emerg_leaves = 0
    #self.tiller_incl = 0
    self.emerg = False
    self.Ln_final = Ln_final_init
    self.length = length_init
    self.nb_j = nb_j_init
    self.date_transiflo = -1
    self.date_de_flo = 10000
    self.date_epi = 10000
    self.Tmoy = 0
    self.p_debourr = 0
    self.time = 0
    self.Ln_final = Ln_final_init
    self.STOP = False
    self.transiflo = False

class Bud_R(Organ_Base):
  def __init__(self, num_plante, geno, tiller, n):
    Organ_Base.__init__(self, num_plante, geno, tiller, n)
    self.sumtemp = 0
    self.emerg = False
    self.Tmoy = 0
    self.nb_j = 0
    self.Ln_final = 0

class Apex(Organ_Base):
  def __init__(self, num_plante, geno, tiller, n, time):
    Organ_Base.__init__(self, num_plante, geno, tiller, n)
    self.time = time_init
    self.nb_primord = 0
    self.nb_emerg_leaves = 0
    #self.tiller_incl = 0
    self.vrn = False
    self.til_transiflo_count = 0
    self.exit_vrn = False
    self.vern_rate = vern_rate_init
    self.vern_prog = vern_prog_init
    self.Ln_pot = Ln_pot_init
    self.Ln_app = Ln_app_init
    self.Ln_final = Ln_final_init
    self.var_Lmin = Lmin
    self.transiflo = False
    self.photop_flag = False
    self.debut_ppd = False
    self.pn = 0
    self.ln = 0
    self.STOP_init = False
#
#  def iter_attributes(self):
#    return iter(self.__dict__.values())
class Apex_R(Organ_Base):
  def __init__(self, num_plante, geno, tiller, n):
    Organ_Base.__init__(self, num_plante, geno, tiller, n)
    self.mont = False
    self.exit_mont = False
    self.feuille_mont = 100
    self.flo = False
    self.epi = False
    self.date_de_flo = 10000
    self.date_epi = 10000
    self.mat = False
    self.date_mat = 10000
    self.death_flag = False
    self.Ln_final = 0


class CutPointBud():
  def __init__(self, num_plante, geno, tiller):
    self.num_plante = num_plante
    self.geno = geno
    self.tiller = tiller
    self.cut = False
    self.reg_count = 0
    self.count = 0
    self.azimuth = 0
    self.zenith = 0

class CutPointBlade():
  def __init__(self, num_plante, geno, tiller, n):
    self.num_plante = num_plante
    self.geno = geno
    self.tiller = tiller
    self.n = n
    self.cut = False

class Internode(Organ_Base):
  def __init__(self, num_plante, geno, tiller, n):
    Organ_Base.__init__(self, num_plante, geno, tiller, n)
    self.age = 0
    self.croiss = True
    self.length = length_init
    self.Ln_final = Ln_final_init
    self.final_length = final_length_init
    self.gr = gr_init
    self.PAR = PAR_init
    self.diameter = diameter_init
    self.area = 0
    self.state = "not_prohibited"
    self.shift = 0
    self.photosynthetic = True

class Leaf(Organ_Base):
  def __init__(self, num_plante, geno, tiller, n):
    Organ_Base.__init__(self, num_plante, geno, tiller, n)
    self.date_emerg = 1000
    self.transiflo_flag = False

class Blade(Organ_Base):
  def __init__(self, num_plante, geno, tiller, n):
    Organ_Base.__init__(self, num_plante, geno, tiller, n)
    self.PAR = PAR_init
    self.width = width_init
    self.area = 0
    self.senesc_flag = False
    self.photosynthetic = True
    self.visible_length = 0
    self.visible_area = 0
    self.reg_count = 0

class Sheath(Organ_Base):
  def __init__(self, num_plante, geno, tiller, n):
    Organ_Base.__init__(self, num_plante, geno, tiller, n)
    self.diameter = diameter_init
    self.area = 0
    self.PAR = PAR_init
    self.photosynthetic = True

class Ear(Organ_Base):
  def __init__(self, num_plante, geno, tiller, n):
    Organ_Base.__init__(self, num_plante, geno, tiller, n)
    self.age = 0
    self.PAR = 0
    self.length = 0
    self.emerged = False
    self.sumtemp = 0
    self.photosynthetic = True

class Peduncle(Organ_Base):
  def __init__(self, num_plante, geno, tiller, n):
    Organ_Base.__init__(self, num_plante, geno, tiller, n)
    self.age = 0
    self.sumtemp = 0
    self.length = 0
    self.diameter = 0
    self.area = 0
    self.PAR = 0
    self.photosynthetic = True



#################################################################################################################
mod_to_remove = ["[","]", "%", "CutPointBlade", "@M","CutPointBud"]


#### ENREGISTREMENT DES PARAMETRES


location           = experimental_conditions[expe_related]["location"]
year               = experimental_conditions[expe_related]["year"]                            #s'il s'agit d'un fichier m�t�o moyenn�, year = 1901
sowing_date        = experimental_conditions[expe_related]["sowing_date"]

dist_inter_rang = experimental_conditions[expe_related]["dist_inter_rang"]

var_register2 = ["location"]

for key, value, in params.iteritems():
  if key in var_register2:
    exec(key+"=value")

latitude           = dico_latitudes[location]

##########################
# LIRE UN FICHIER METEO  #
##########################

meteo_dF = pd.read_csv(pj(inputdir, "meteo", location + ".csv"), header=9, sep=";")

var_register = ["crop_ccptn","sowing_date","year","latitude","nbj","densite","nb_rang","nb_plantes","area_targeted","geno_nb","SIRIUS_state","infinity_GAIp","nb_azimuth","nb_zenith","dist_inter_rang","N_p_s","l_c","L_b_S","Psi_FT","param_Ln_final","Tbase","Tvermin","Tverint","Tvermax","Lmax","Lmin","Ldecr","Lincr","phyllo_decr","phyllo_incr","DLsat","Delta_b","dGAIp","Delta_l","Delta_c_GN","Delta_hf","Delta_hm","Delta_lflf","Delta_flsp","Delta_SGtR","Delta_SGtC","ED_I","ED_B","ED_FB","ED_S","Phi_zen_B_Maxwell","Phi_zen_B_Lely","Phi_zen_B_Soissons","Phi_zen_B_Renan","Phi_zen_B_Gigant_Maxwell","Phi_zen_B_Darwinkel_Maxwell","Phi_zen_B_Caphorn","Phi_zen_B_Apache","Phi_zen_B_A208","Phi_zen_B_A210","Phi_zen_B_F236","Phi_zen_B_A398","Phi_azi_B","Phi_zen_T","Phi_azi_T","Phi_zen_E","Phi_azi_S","Phi_zen_S","y_position_hazard","x_position_hazard","z_position_hazard","blade_incl_hazard","blade_azi_hazard","till_zen_hazard","till_azi_hazard","Phl_Soissons","Phl_Maxwell","VAI_Soissons","VAI_Maxwell","VBEE_Soissons","VBEE_Maxwell","SLDL_Soissons","SLDL_Maxwell","N_I_el_Soissons","N_I_el_Maxwell","s_B_1_Soissons","s_B_1_Maxwell","N_B_r_Soissons","N_B_r_Maxwell","L_B_1_Soissons","L_B_1_Maxwell","L_B_max_Soissons","L_B_max_Maxwell","s_B_f_Soissons","s_B_f_Maxwell","a_B_w_Soissons","a_B_w_Maxwell","b_B_w_Soissons","b_B_w_Maxwell","a_S_L_Soissons","a_S_L_Gigant_Maxwell","a_S_L_Maxwell","b_S_L_Soissons","b_S_L_Gigant_Maxwell","b_S_L_Maxwell","inc_I_Soissons","inc_I_Maxwell","b_I_L_Soissons","b_I_L_Maxwell","b_I_L_Gigant_Maxwell","a_I_L_Soissons","a_I_L_MAxwell","a_I_L_Gigant_Maxwell","d_I_Soissons","d_I_Maxwell","L_P_Soissons","L_P_Maxwell","d_P_Soissons","d_P_Maxwell","d_E_Soissons","d_E_Maxwell","L_E_Soissons","L_E_Maxwell","d_S_Soissons","d_S_Maxwell","n0_sen_Soissons","n0_sen_Maxwell","n1_sen_Soissons","n1_sen_Maxwell","n2_sen_Soissons","n2_sen_Maxwell","n3_sen_Soissons","n3_sen_Maxwell","t0_sen_Soissons","t0_sen_Maxwell","t1_sen_Soissons","t1_sen_Maxwell","t2_sen_Soissons","t2_sen_Maxwell","t3_sen_Soissons","t3_sen_Maxwell","P_CT_Soissons","P_CT_Maxwell","P_T_Soissons","P_T_Maxwell","nb_plt_utiles","dist_border_x","dist_border_y","nb_plt_temp"]

print 'parms'
print params

for key, value, in params.iteritems():
  if key in var_register:
    print key, value
    exec(key+"=value")

nb_rang = int(nb_rang)

random.seed(rep)

L_B_max = {"Maxwell" : L_B_max_Maxwell, "Darwinkel_Maxwell" : L_B_max_Maxwell, "Gigant_Maxwell" : L_B_max_Maxwell, "Soissons" : L_B_max_Soissons} # Final length of the longest blade each the axis (cm)        | old name : length_penultimate_blade


a_B_w = {"Maxwell" : a_B_w_Maxwell, "Darwinkel_Maxwell" : a_B_w_Maxwell, "Gigant_Maxwell" : a_B_w_Maxwell, "Soissons" : a_B_w_Soissons} # Coefficient for blade width                              | old name : a_blade_width

Phi_zen_B = {"Maxwell" : Phi_zen_B_Maxwell ,"Lely" : Phi_zen_B_Lely,"Soissons" : Phi_zen_B_Soissons,"Renan" : Phi_zen_B_Renan,"Gigant_Maxwell" : Phi_zen_B_Gigant_Maxwell,"Darwinkel_Maxwell" : Phi_zen_B_Darwinkel_Maxwell,"Caphorn" : Phi_zen_B_Caphorn,"Apache" : Phi_zen_B_Apache,"A208" : Phi_zen_B_A208,"A210" : Phi_zen_B_A210,"F236" : Phi_zen_B_F236,"A398" : Phi_zen_B_A398}

tab_top = datetime.date(int(year)-1,9,1)													      # On d�finit la date du d�but du fichier
double_finger = datetime.date(int(year)-1,1,1)                               #Premier janvier
sowing_DOY=(sowing_date-double_finger).days     # DOY du semis

#################################################################################################################
### LE TEMPS QUI PASSE ###
#delta_date = sowing_date - tab_top		                        # Calcule le nombre de jours entre la date de semis et le d�but du fichier
#delta_date.days								                            # Retourne le nombre de jour en integer (c'est l'indice dans le tableau )
date_current_day = sowing_date + datetime.timedelta(elapsed_time) 	        # Date � laquelle nous nous trouvons pour un elapsed_time donn�
DOY = int(date_current_day.strftime('%j'))


Phl = {"Maxwell" : Phl_Maxwell, "Darwinkel_Maxwell" : Phl_Maxwell,"Gigant_Maxwell":Phl_Maxwell, "Soissons" : Phl_Soissons, "Renan" : Phl_Renan}  # Diff�rentes valeurs issues de recalibrations He : 104      #Ly : 113.5    #Lecarpentier :

Pls_Maxwell = phyll_adjust("Maxwell")/2
Pls_Soissons = phyll_adjust("Soissons")/2
Pls_Renan = phyll_adjust("Renan")/2

DelayTipToHS_Maxwell = 0.4125 * phyll_adjust("Maxwell")
DelayTipToHS_Soissons = 0.4125 * phyll_adjust("Soissons")

var_register3 = ["DelayTipToHS_Soissons","DelayTipToHS_Maxwell","Pls_Soissons","Pls_Maxwell"]

for key, value, in params.iteritems():
  if key in var_register3:
    exec(key+"=value")

Pls = {"Maxwell" : Pls_Maxwell, "Darwinkel_Maxwell" : Pls_Maxwell,"Gigant_Maxwell":Pls_Maxwell, "Soissons" : Pls_Soissons, "Renan" : Pls_Renan}
DelayTipToHS = {"Maxwell" : DelayTipToHS_Maxwell, "Darwinkel_Maxwell" : DelayTipToHS_Maxwell, "Gigant_Maxwell" : DelayTipToHS_Maxwell, "Soissons" : DelayTipToHS_Soissons}


if crop_ccptn == "classical":
  crop_scheme = {"dist_inter_rang":dist_inter_rang, "density":densite}
  area = nb_plt_temp/crop_scheme["density"]
  dy = nb_rang * dist_inter_rang
  dx = area/dy
  nb_plante_par_rang = int(nb_plt_temp/nb_rang)
  dist_intra = dx/nb_plante_par_rang
  nplant_peupl = int(nb_rang*nb_plante_par_rang)
  crop_scheme["nplant_peupl"] = nplant_peupl
  plant_census = range(1,crop_scheme["nplant_peupl"] + 1)
  crop_scheme["dx"] = dx
  crop_scheme["dy"] = dy
  crop_scheme["surface_sol"] = dx*dy
  crop_scheme["nb_rang"] = nb_rang
  crop_scheme["nb_plante_par_rang"] = nb_plante_par_rang
  crop_scheme["dist_intra_rang"] = dist_intra
  crop_scheme["real_density"] = nplant_peupl/crop_scheme["surface_sol"]
  crop_scheme["map_middle_y"] = ((crop_scheme["nb_rang"] * (crop_scheme["dist_inter_rang"])*100) + (crop_scheme["dist_inter_rang"])*100)/2
  crop_scheme["map_middle_x"] = ((crop_scheme["nb_plante_par_rang"] * (crop_scheme["dist_intra_rang"])*100) + (crop_scheme["dist_intra_rang"])*100)/2
  print crop_scheme
elif crop_ccptn == "neo_Darwinkel":
  crop_scheme = {"dist_inter_rang":dist_inter_rang, "density":densite}
  adapting_crop_area(crop_scheme["density"],area_min, area_max, crop_scheme["dist_inter_rang"], opt_plt_nb)
  plant_census = range(1,crop_scheme["nplant_peupl"] + 1)
  print crop_scheme

elif crop_ccptn == "Darwinkel_original": 
  area = area_targeted
  crop_scheme = {"area" : area, "density" : densite}
  #border_prop = 0.8
  design_crop_Darwinkel(crop_scheme["area"], crop_scheme["density"])
  #dist_border_x = ((crop_scheme["dy"]/crop_scheme["dx"]) * (border_prop/2)) * crop_scheme["dx"] #inside a rang
  #dist_border_y = ((crop_scheme["dx"]/crop_scheme["dy"]) * (border_prop/2)) * crop_scheme["dy"] #rang
  plant_census = range(1,crop_scheme["nplant_peupl"] + 1)
  print "dist_border_x : ",dist_border_x, "dist_border_y : ",dist_border_y

elif crop_ccptn == "Mesh_for_nplants":
  crop_scheme = {"density" : densite}
  design_crop_mesh_for_nplants(crop_scheme["density"], nb_plt_utiles , dist_border_x , dist_border_y)
  plant_census = range(1,crop_scheme["nplant_peupl"] + 1)
  print "dist_border_x : ",dist_border_x, "dist_border_y : ",dist_border_y



nb_rangs = crop_scheme["nb_rang"] #RESTE !
nb_plantes = crop_scheme["nplant_peupl"]
dist_inter_rang = crop_scheme["dist_inter_rang"]
dist_intra_rang = crop_scheme["dist_intra_rang"]
dx = crop_scheme["dx"]
dy = crop_scheme["dy"]


if genotype_proportion == "equal":
  genotype_list = crop_genotype*int(ceil(crop_scheme["nplant_peupl"]/geno_nb))
  random.shuffle(genotype_list)


# Create a unique ID to the simulation according to a specific combination of parameters value
global folder_name
global out_dir

if len(params) == 0:
  folder_name = "output_debug"
  out_dir = pj(data_dir, "output")
else:
  # If the json file already exists
  if os.path.isfile("index-table.json"):
    # The use of the byteify function kill encoding problems from json importation between unicode and strings 
    
    ID_params = byteify(json.load(open("index-table.json")))
    already_known_ID = False
    
    for id in ID_params.keys():
      
      # If the combination of parameters has already been encountered previously and stored in the json file
      if sorted(ID_params[id].values()) == sorted(params.values()):
        already_known_ID = True
      
    #If the ID of the simulation is already known
    if already_known_ID:
      ID = id
    
    #If the ID of the simulation is not known
    elif not already_known_ID:
      # We choose a random ID
      ID = "id-"+str(uuid.uuid4())
      ID_params = {}
      ID_params[ID] = params
      
      json_2_human = open("from_json_to_humanbeing.txt", "a")
      
      for key, val in params.iteritems():
        json_2_human.write("%s" % ID + "\t" + "%s" % key + "\t" + "%s" % val + "\n")
      json_2_human.write("\n")
      json_2_human.close()
      
      json.dump(ID_params, open("index-table.json", "w"))
      
      
  # If the json file doesnot exists
  elif not os.path.isfile("index-table.json"):
    # We choose a random ID
    ID = "id-"+str(uuid.uuid4())
    ID_params = {}
    ID_params[ID] = params
    
    json_2_human = open("from_json_to_humanbeing.txt", "a")
    
    for key, val in params.iteritems():
      json_2_human.write("%s" % ID + "\t" + "%s" % key + "\t" + "%s" % val + "\n")
    json_2_human.write("\n")
    json_2_human.close()
      
    json.dump(ID_params, open("index-table.json", "w"))
    
  folder_name = ID
  out_dir = pj(data_dir, "output")
  print "ID : ",ID
  #Write the ID of the current simulation in an external file to catch it later un another script
  ID_simul = open("ID_simul.txt","w")
  ID_simul.write(ID)
  ID_simul.close()

try:
  if not os.path.exists(out_dir):
    os.mkdir(out_dir)

  if not os.path.exists(pj(out_dir, folder_name)):
    os.mkdir(pj(out_dir, folder_name))
  if write_output_file["Lscene"]:
    if not os.path.exists(pj(out_dir, folder_name, "Lscenes")):
      os.mkdir(pj(out_dir, folder_name, "Lscenes"))
  
  if write_output_file["Lstring"]:
    if not os.path.exists(pj(out_dir, folder_name, "Lstrings")):
      os.mkdir(pj(out_dir, folder_name, "Lstrings"))
  
except Exception, e:
  print(e)
  pass


def Start(lstring):
  useGroup(1)
  current_PAR = 0
  
  #TODO ici c'est sale, il faut mettre �a dans Seed
  # Initialisation of the dictionnary regrouping Ts0 dates for each tiller
  #for tiller in tiller_2_ts0.keys():
  #  print "tiller : ",tiller, "tiller_2_ts0 : ", tiller_2_ts0
  #  for Tht in range(1, 3000):
  #    define_ts0(Tht, tiller, Ln_final_dict[tiller], phyllo_Maxwell, n1_Maxwell, n3_Maxwell, t1_sen_Maxwell, t3_sen_Maxwell, Dse_mean_Maxwell, DelayTipToHS*phyllo_Maxwell, test_res)
  #  test_res= [True]
  
  #for axis in tiller_2_ts0.keys():
  #  cohort_2_ts0[cohort_number(axis)] = tiller_2_ts0[axis]


#res_sky = 0

def StartEach(lstring):
  #if getIterationNb() % 2 == 0:
  frameDisplay(True)
  
  global Temperature
  global elapsed_time
  global Tempcum
  global date_current_day
  global DOY
  elapsed_time += time_step                    #dj = incr�ment de temps en jours
  date_current_day = sowing_date + datetime.timedelta(elapsed_time) 	        # Date � laquelle nous nous trouvons pour un elapsed_time donn�
  #mean_temperatures[current_day - tab_top).days]                   # Temp�rature moyenne du jour apr�s elapsed time jours pass�s
  if DOY == 365:
    DOY = 1
  else:
    DOY += 1

  try:
    _current_temperature = meteo_dF[(meteo_dF["year"] == date_current_day.year) & (meteo_dF["month"] == date_current_day.month) & (meteo_dF["day"] == date_current_day.day)]['TM']
    current_temperature = _current_temperature[_current_temperature.last_valid_index()]
  except:
    current_temperature = Temperature

  global current_PAR # Daily integrated Incoming radiation in  micromolPAR.m-2
  try:
    _current_PAR = meteo_dF[(meteo_dF["year"] == date_current_day.year) & (meteo_dF["month"] == date_current_day.month) & (meteo_dF["day"] == date_current_day.day)]['PAR']
    current_PAR = _current_PAR[_current_PAR.last_valid_index()]
  except:
    pass

  Temperature = current_temperature              # Temp�rature moyenne du jour apr�s elapsed time jours pass�s
  Tempcum += max(Tbase,Temperature)
  
  print "date : ", date_current_day, "|", location,"|", "Experiment : ", expe_related,"|", "densite : ", densite,"|", "num_jour : ",elapsed_time,"|", "tempcum : ",int(Tempcum),"|", "DOY : ",DOY,"|", "len : ",len(lstring), "|","T : ", current_temperature,"|", "PAR : ", current_PAR
  #daily_seed = rep + elapsed_time
  #random.seed(daily_seed)


def EndEach(lstring, lscene):
  global lpy_cut_bug
  if lpy_cut_bug:
    # Force removal of cut branches to have a consistent indexing between lscene and lstring (see test_cut_module.py)
    lstring = force_cut(lstring)
  # CALCUL DU GAI (� partir de la chaine)
  for num_plt in range(1, crop_scheme["nplant_peupl"] + 1):
    Hcol_max[num_plt] = dict.fromkeys(Hcol_max[num_plt].keys(), 0)
    delta_H[num_plt] = dict.fromkeys(delta_H[num_plt].keys(), 0)
    Hcol_dead[num_plt] = dict.fromkeys(Hcol_dead[num_plt].keys(), 0)
  
  global tiller_surface
  global surface_plante_visible
  global surface_plante
  
  tiller_surface = dict.fromkeys(tiller_surface.keys(), 0)
  surface_plante = dict.fromkeys(surface_plante.keys(), 0)
  surface_plante_visible = dict.fromkeys(surface_plante_visible.keys(), 0)
  
  #Calcul du GAI
  for org_id in range(len(lstring)):
    org = lstring[org_id]
    if org.name in organ_type:
      if org.name == "Blade" and org[0].photosynthetic == True:
        
        # Ancienne methode de calcul du GAI
        surface_plante[org[0].num_plante] += org[0].area
        
        #Nouvelle m�thode de calcul du GAI (uniquement que les parties visibles des feuilles)
        tiller_surface[(org[0].num_plante,org[0].tiller)] += org[0].visible_area
        
      if org.name == "Internode":
        if org[0].photosynthetic == True:
          # Hauteur max du collet (par axe)
          Hcol_max[org[0].num_plante][org[0].tiller] += org[0].length
        
        else:
          # Hauteur du col mort
          Hcol_dead[org[0].num_plante][org[0].tiller] += org[0].length
        
      if org.name == "Peduncle" and org[0].photosynthetic == True:
        #  Delta H (Lepi + Lped) - Lgmax)
        delta_H[org[0].num_plante][org[0].tiller] += org[0].length
        
      if org.name == "Ear" and org[0].photosynthetic == True:
        #  Delta H (Lepi + Lped) - Lgmax)
        delta_H[org[0].num_plante][org[0].tiller] += org[0].length
  
  for num_plt in range(1,crop_scheme["nplant_peupl"] + 1):
    for axis in axis_census[num_plt].keys():
    
      #Calculs
      Sh_max_temp = max([Sh_max[num_plt][axis][x] for x in range(0,max(Sh_max[num_plt][axis].keys()) + 1)])
      Sh_dead_max = max([dead_sheath_length[num_plt][axis][x] for x in range(0,max(dead_sheath_length[num_plt][axis].keys()) + 1)])
      Hcol_max[num_plt][axis] = Hcol_max[num_plt][axis] + Sh_max_temp
      Hcol_dead[num_plt][axis] =  Hcol_dead[num_plt][axis] + Sh_dead_max
      delta_H[num_plt][axis] = max(0, delta_H[num_plt][axis] - Sh_max_temp)
      
      #Calcul de GAI (on ajoute les contributions des autres parties de la plante)
      Peraxes_dico_df["Visible_leaves_surface"].append(tiller_surface[(num_plt,axis)])
      #TODO : transformer ces formules en fonctions � mettre en amont
      leaf_contrib = tiller_surface[(num_plt,axis)]
      stem_contrib = max(0,(Hcol_max[num_plt][axis] - max(L_b_S,Hcol_dead[num_plt][axis])) * d_S[genotype_map[num_plt]] * pi/2)
      peduncle_contrib = max(0,(delta_H[num_plt][axis] - L_E[genotype_map[num_plt]]) * pi/2 * d_P[genotype_map[num_plt]])
      
      if delta_H[num_plt][axis] <= 0:
        tiller_surface[(num_plt,axis)] = leaf_contrib + stem_contrib
        ear_contrib = 0
      elif delta_H[num_plt][axis] > L_E[genotype_map[num_plt]]:
        ear_contrib = L_E[genotype_map[num_plt]] * d_E[genotype_map[num_plt]] * pi/2
        tiller_surface[(num_plt,axis)] = leaf_contrib + stem_contrib + ear_contrib + peduncle_contrib
      elif 0 < delta_H[num_plt][axis] < L_E[genotype_map[num_plt]]:
        ear_contrib = (L_E[genotype_map[num_plt]] - delta_H[num_plt][axis]) * d_E[genotype_map[num_plt]] * pi/2
        tiller_surface[(num_plt,axis)] = leaf_contrib + stem_contrib + ear_contrib
      
      
      #Remplissages de dico de sortie
      if write_output_file["Peraxes"]:
        Peraxes_dico_df["Init_flag"].append(initialization_Flag[num_plt])
        Peraxes_dico_df["Elapsed_time"].append(elapsed_time)
        Peraxes_dico_df["DOY"].append(DOY)
        Peraxes_dico_df["Temperature"].append(Temperature)
        Peraxes_dico_df["Temp_cum"].append(Tempcum)
        Peraxes_dico_df["Num_plante"].append(num_plt)
        Peraxes_dico_df["Num_talle"].append(axis)
        Peraxes_dico_df["Sheath_max"].append(Sh_max_temp)      
        Peraxes_dico_df["Collar_height"].append(Hcol_max[num_plt][axis])
        Peraxes_dico_df["Dead_collar_height"].append(Hcol_dead[num_plt][axis])
        Peraxes_dico_df["Delta_H"].append(delta_H[num_plt][axis])
        Peraxes_dico_df["Visible_surface"].append(tiller_surface[(num_plt,axis)])
        Peraxes_dico_df["Stop_growth_flag"].append(axis_census[num_plt][axis]['Stop_growth_flag'])
        Peraxes_dico_df["Leaf_contrib_to_GAI"].append(leaf_contrib)
        Peraxes_dico_df["Stem_contrib_to_GAI"].append(stem_contrib)
        Peraxes_dico_df["Ear_contrib_to_GAI"].append(ear_contrib)
        Peraxes_dico_df["Peduncle_contrib_to_GAI"].append(peduncle_contrib)
  
#aggregate axes surface per plant
  for key in tiller_surface.keys():
    surface_plante_visible[key[0]] += tiller_surface[key]
  
  # Calcul du GAI de proximit�
  for num_plt in range(1,crop_scheme["nplant_peupl"] + 1):
    surface_peupl = 0
    for num_voisin in dico_voisins[num_plante]:
      surface_peupl += surface_plante_visible[num_voisin]
    GAI_prox[num_plt] = surface_peupl/(nb_voisins_glob[0] * (crop_scheme["dist_inter_rang"]*100)*(crop_scheme["dist_intra_rang"] * 100))  # On multiplie par 100 pour une conversion de m_squ � cm_squ
    GAI_ind[num_plt] = surface_plante_visible[num_plt]/((crop_scheme["dist_inter_rang"]*100)*(crop_scheme["dist_intra_rang"] * 100))
  
  GAI_old = sum(surface_plante.values())/(crop_scheme["nplant_peupl"] * ((crop_scheme["dist_inter_rang"]*100)*(crop_scheme["dist_intra_rang"] * 100)))
  GAI_tot = sum(surface_plante_visible.values())/(crop_scheme["nplant_peupl"] * ((crop_scheme["dist_inter_rang"]*100)*(crop_scheme["dist_intra_rang"] * 100)))
  Surf_center = 0
  for interest_plt in plant_census:
    Surf_center += surface_plante_visible[interest_plt]
  GAI_center = Surf_center/(len(plant_census) * ((crop_scheme["dist_inter_rang"]*100)*(crop_scheme["dist_intra_rang"] * 100)))
  
  
  ##################################
  ##Module de rayonnement : CARIBU #
  ##################################
  
  if write_output_file["Lscene"]:
    if elapsed_time > 40:
      s_save = Scene(lscene)
      s_save.save(pj(out_dir,folder_name, "Lscenes", "lscene-day-"+"%s" % elapsed_time+".bgeom"))
  
  if write_output_file["Lstring"]:
    out_lstring = open(pj(out_dir,folder_name, "Lstrings", "lstring-day-"+"%s" % round(elapsed_time) +".txt"), "w")
    out_lstring.write("%s" % lstring)
  
  #s = Scene(lscene)
  #s.add(lscene)
  #s.save("./lscene-debug.bgeom")
  #print(type(lscene))w<<
  
  ## Pour l'instant on fait QUE du diffus

  if CARIBU_state != "disabled":    #Le module de rayonnement peut �tre activ� ou d�sactiv� {"enabled";"disabled"}
    if type(lscene) != None:
      if len(lscene) > 0:
        if beginning_CARIBU < Tempcum < ending_CARIBU:
          print "The date : ", str(datetime.datetime.now())

          c_scene = caribu_scene(lscene, crop_scheme, current_PAR, nb_azimuth, nb_zenith)
          res_sky= None
          try:
            _, res_sky = c_scene.run(simplify=True, infinite = bool(infinity_CARIBU), direct = True)
          # The outputs are in micromolPAR.m-2 for Ei and Ea, and m2 for area
          # TODO: check these outputs are those expected or should be converted
          except Exception as exception :
            #~ if exception.__class__.__name__ == "CaribuRunError"
            if type(exception).__name__ == "CaribuRunError":
              error_caribu_file = open(pj(out_dir,folder_name, "error_caribu.txt"), "w")
            else:
              error_default_file = open(pj(out_dir,folder_name, "error_default.txt"), "w")
            
            sys.stderr.write(str(exception))
            exit(1)

#          except Exception:
#            print '#'*80
#            print '*'*80
#            print 'ERROR in the run of caribu'
#            print lscene
#            print '*'*80
#            s_save = Scene(lscene)
#            s_save.save("./debug/lscene-day-"+"%s" % elapsed_time+".geom")
#            res_sky = None
          
          if Temperature > 0 and res_sky:
            for num_plt in axis_census.keys():
              for axis in axis_census[num_plt].keys():
                dico_PAR_per_axis[num_plt][axis][round(Tempcum, 1)] = 0
            for id in res_sky['Ei'].keys():
              #if id not in new_lstring: continue
              new_ = lstring[id]
              if ((new_.name == "Blade" and new_[0].photosynthetic == True) or
                 (new_.name in ("Sheath", "Internode", "Peduncle")) or
                 (new_.name == "Ear" and new_[0].emerged)):
                if new_[0].tiller in axis_census[new_[0].num_plante].keys():


                  # TODO: check these outputs are those expected or should be converted
                  if res_sky["Ei"][id] < 0:
                    new_[0].PAR = 0
                  else:
                    new_[0].PAR = res_sky["Ei"][id] * res_sky["area"][id]

                  new_[0].organ_surface = res_sky["area"][id]
                  dico_PAR[new_.name][new_[0].num_plante][new_[0].tiller][new_[0].n] = new_[0].PAR

                  if tiller_surface[(lstring[id][0].num_plante,lstring[id][0].tiller)] < 0.00001:#TODO quand on aura le temps, am�liorer cette rustine
                    dico_PAR_per_axis[lstring[id][0].num_plante][lstring[id][0].tiller][round(Tempcum, 1)] += 0
                  else:
                    dico_PAR_per_axis[lstring[id][0].num_plante][lstring[id][0].tiller][round(Tempcum, 1)] += lstring[id][0].PAR/Temperature/(tiller_surface[(lstring[id][0].num_plante,lstring[id][0].tiller)] *1e-4)
                  if write_debug_PAR == True :
                    Debug_PAR_dico_df["Ei"].append(res_sky["Ei"][id])
                    Debug_PAR_dico_df["Elapsed_time"].append(elapsed_time)
                    Debug_PAR_dico_df["Temp_cum"].append(Temperature)
                    Debug_PAR_dico_df["Organ_type"].append(lstring[id].name)
                    Debug_PAR_dico_df["Num_talle"].append(lstring[id][0].tiller)
                    Debug_PAR_dico_df["Num_plante"].append(lstring[id][0].num_plante)
                    Debug_PAR_dico_df["Num_organe"].append(lstring[id][0].n)
                    Debug_PAR_dico_df["Organ_surface"].append(lstring[id][0].organ_surface)
                    Debug_PAR_dico_df["Organ_PAR"].append(lstring[id][0].PAR)
                    Debug_PAR_dico_df["id"].append(id)
                    Debug_PAR_dico_df["tiller_surface"].append(tiller_surface[(lstring[id][0].num_plante, lstring[id][0].tiller)]*1e-4)
                    Debug_PAR_dico_df["Inc_PAR"].append(current_PAR)

          if write_output_file["PAR_per_axes"] == True:
            for num_plt in axis_census.keys():
              for axis in axis_census[num_plt].keys():
                PAR_per_axes_dico["Elapsed_time"].append(elapsed_time)
                PAR_per_axes_dico["Temp_cum"].append(Tempcum)
                PAR_per_axes_dico["Num_plante"].append(num_plt)
                PAR_per_axes_dico["Num_talle"].append(axis)
                PAR_per_axes_dico["Inc_PAR"].append(current_PAR)
                tt = round(Tempcum, 1)
                PAR_per_axes_dico["Sum_PAR"].append(dico_PAR_per_axis[num_plt][axis].get(tt,0.))

    ### BOUCLE DE REGRESSION DES TALLES ###
    for num_plt in range(1,crop_scheme["nplant_peupl"] + 1):
      #Gestion du d�lai de protection d'une plante entre la mort successive de deux de ses talles
      if plant_shield_indicator[num_plt]["Shield"] == True:
        plant_shield_indicator[num_plt]["count"] += max(0,Temperature)
        if plant_shield_indicator[num_plt]["count"] >= Delta_prot[genotype_map[num_plt]]:
          plant_shield_indicator[num_plt]["Shield"] = False
          plant_shield_indicator[num_plt]["count"] = plant_shield_indicator[num_plt]["count"]%Delta_prot[genotype_map[num_plt]]
      
      weakest_axis = "No"
      PAR = 1
      nb_timestep_fenetre = 1
      PAR_2_write = 1
      
      #Date effective du debut de regression des talles qui d�pend du nombre de feuilles final
      if t_beg_reg_ind_Tht.keys(): #This is a simple and ugly test set to avoid performing the real test (on an empty dict) the first round of simulation before the dict t_beg_reg_ind_Tht fills itself
        #print elapsed_time, "tht beg reg : ",min(t_beg_reg_ind_Tht.values())
        if t_beg_reg_ind_Tht[num_plt] < Tempcum < dico_stades[num_plt][(1,)]["Flo"][1]: 
          #Determining the maximal cohort of the day
          PAR_per_youngest_tiller = (0, float('inf'))
          if len(axis_census[num_plt].values()) > 0: #If at least one axis is composing the plant
            
            # We calculate the highest emergence date of the tiller in order to point the youngest tiller
            date_emergence_max = 0
            for tal in axis_census[num_plt].keys():
              if axis_census[num_plt][tal]["emerg_date"] > date_emergence_max:
                date_emergence_max = axis_census[num_plt][tal]["emerg_date"]
            #date_emergence_max = max(axis_census[num_plt].values())["emerg_date"]
            
            for axis, value in axis_census[num_plt].iteritems():
              if axis != (1,): #No regression is considered on the main stem
                
                # On d�limite les bords de la fen�tre glissante
                min_temp = min(dico_PAR_per_axis[num_plt][axis].keys())
                max_temp = max(dico_PAR_per_axis[num_plt][axis].keys())
                # Considering only the youngest axis
                if(max_temp - min_temp) >= Delta_l and value["emerg_date"] == date_emergence_max and axis_census[num_plt][axis]["Stop_growth_flag"] == False:
                  if dico_PAR_per_axis[num_plt][axis][round(Tempcum, 1)] < PAR_per_youngest_tiller[1]:
                    weakest_axis = axis
                    #for temp in range(min(dico_PAR_per_axis[num_plt][axis].keys(), key=lambda x:abs(x-(max_temp-Delta_l))), max_temp+1):
                    Temp_keys = [t for t in dico_PAR_per_axis[num_plt][axis].keys() if t > max(dico_PAR_per_axis[num_plt][axis].keys()) - Delta_l]
                    PAR = 0            
                    for temp in Temp_keys:
                      PAR += dico_PAR_per_axis[num_plt][axis][temp]
                    nb_timestep_fenetre = len(Temp_keys)
                    #print "num plt : ", num_plt, "weakest_axis",weakest_axis, "PAR moyen: ",PAR/nb_timestep_fenetre, "test mort : ", PAR/nb_timestep_fenetre < PAR_t[genotype_map[num_plt]]
                    if PAR/nb_timestep_fenetre < PAR_t[genotype_map[num_plt]]:
                      PAR_per_youngest_tiller = (axis, dico_PAR_per_axis[num_plt][axis][round(Tempcum, 1)])
                      
            
            if PAR_per_youngest_tiller != (0, float('inf')) and plant_shield_indicator[num_plt]["Shield"] == False:
              plant_shield_indicator[num_plt]["Shield"] = True
              axis_census[num_plt][PAR_per_youngest_tiller[0]]["Stop_growth_flag"] = True 
              axis_census[num_plt][PAR_per_youngest_tiller[0]]["emerg_date"] = 0        
        
      #global GAI_df
      GAI_dico_df['Weakest_axis'].append(weakest_axis)
      GAI_dico_df['PAR_weakest_axis'].append(PAR/nb_timestep_fenetre)
  
  ###### Fin rayonnement
  
  for num in range(1, crop_scheme["nplant_peupl"] + 1):
    GAI_dico_df["Init_flag"].append(initialization_Flag[num])
    GAI_dico_df['Elapsed_time'].append(elapsed_time)
    GAI_dico_df['Temp_cum'].append(Tempcum)
    GAI_dico_df['DOY'].append(DOY)
    GAI_dico_df['Genotype'].append(0)
    GAI_dico_df['Num_plante'].append(num)
    GAI_dico_df['Surface_plante'].append(surface_plante[num])
    GAI_dico_df['Surface_visible'].append(surface_plante_visible[num])
    GAI_dico_df['Surface_sol'].append((crop_scheme["nplant_peupl"] * ((crop_scheme["dist_inter_rang"]*100)*(crop_scheme["dist_intra_rang"] * 100))))
    GAI_dico_df['GAI_tot'].append(GAI_tot)
    GAI_dico_df['GAI_center'].append(GAI_center)
    GAI_dico_df['GAI_ind'].append(GAI_ind[num])
    GAI_dico_df['GAI_prox'].append(GAI_prox[num])

    if num in plant_census:
      GAI_dico_df['Position'].append("center")
    else:
      GAI_dico_df['Position'].append("border")
  
  
  

def End(lstring):
  
  ####################################
  #   ECRITURE DANS DES FICHIERS     #
  ####################################
  print "Aloha"

  if write_output_file["Apex_Sirius"] == True:
    _Apex_Sirius_df = pd.DataFrame(Apex_Sirius_dico_df)
    dF_labels = ["Elapsed_time","Temperature", "Temp_cum", "Daylength", "Num_plante", "Genotype", "PN", "LN", "Sumtemp", "Vern_rate", "Vern_prog", "Vern_flag", "Debut_ppd_flag", "Fin_ppd_flag", "Ln_pot", "Var_L_min","Ln_app", "Ln_final"]
    Apex_Sirius_df = _Apex_Sirius_df.reindex_axis(dF_labels, axis="columns", copy=False)
    Apex_Sirius_df.to_csv(pj(out_dir,folder_name, "Apex_Sirius.csv"), sep="\t", header=True, index=False)

  if write_output_file["Apex"] == True:
    _Apex_df = pd.DataFrame(Apex_dico_df)
    dF_labels = ["Elapsed_time", "Temperature", "Temp_cum", "Time_count", "Sum_temp", "Current_PAR", "Num_plante",  "Genotype", "Num_talle", "Num_cohorte", "Nb_phyto_emi", "Nb_emerged_leaf", "Transiflo_flag", "STOP_init_flag", "Transiflo_DOY","Ln_final"]
    Apex_df = _Apex_df.reindex_axis(dF_labels, axis="columns", copy=False)
    Apex_df.to_csv(pj(out_dir,folder_name, "Apex.csv"), sep="\t", header=True, index=False)

  if write_output_file["Apex_R"] == True:
    _Apex_R_df = pd.DataFrame(Apex_R_dico_df)
    dF_labels = ["Elapsed_time", "DOY", "Temperature", "Temp_cum", "Sum_temp", "Num_plante", "Genotype", "Num_talle", "Num_cohorte", "Ln_final", "Date_epiaison", "Epi_DOY", "Date_de_flo", "Mont_flag", "Mont_DOY", "Flo_flag", "Flo_DOY", "Death_flag", "Date_de_maturite", "Mat_DOY"]
    Apex_R_df = _Apex_R_df.reindex_axis(dF_labels, axis="columns", copy=False)
    Apex_R_df.to_csv(pj(out_dir,folder_name, "Apex_R.csv"), sep="\t", header=True, index=False)

  if write_output_file["Blade"] == True:
    _Blade_df = pd.DataFrame(Blade_dico_df)
    dF_labels = ["Elapsed_time", "Temp_cum" , "Temperature", "Num_plante", "Genotype", "Num_talle", "Num_cohorte", "Num_rang", "Blade_sumtemp", "Blade_width", "Blade_length", "Blade_visible_length","Blade_final_length", "Blade_visible_surface", "Blade_surface", "Blade_PAR", "Senesc_flag" , "Photosynthetic"]
    Blade_df = _Blade_df.reindex_axis(dF_labels, axis="columns", copy=False)
    Blade_df.to_csv(pj(out_dir,folder_name, "Blade.csv"), sep="\t", header=True, index=False)

  if write_output_file["Internode"] == True:
    _Internode_df = pd.DataFrame(Internode_dico_df)
    dF_labels = ["Elapsed_time" ,  "Temp_cum" ,  "Temperature" ,  "Num_plante" ,  "Genotype" ,  "Num_talle", "Num_cohorte", "Num_rang" , "Internode_length" ,  "Internode_final_length" ,  "Internode_surface", "Internode_PAR", "Photosynthetic"]
    Internode_df = _Internode_df.reindex_axis(dF_labels, axis="columns", copy=False)
    Internode_df.to_csv(pj(out_dir,folder_name, "Internode.csv"), sep="\t", header=True, index=False)

  if write_output_file["Peduncle"] == True:
    _Peduncle_df = pd.DataFrame(Peduncle_dico_df)
    dF_labels = ["Elapsed_time", "Temp_cum", "Temperature",  "Num_plante",  "Genotype", "Num_talle", "Num_cohorte", "Num_rang", "Sum_temp", "Peduncle_length", "Peduncle_final_length", "Peduncle_surface", "Peduncle_PAR", "Photosynthetic"]
    Peduncle_df = _Peduncle_df.reindex_axis(dF_labels, axis="columns", copy=False)
    Peduncle_df.to_csv(pj(out_dir,folder_name, "Peduncle.csv"), sep = "\t", header=True, index=False)

  if write_output_file["Sheath"] == True:
    _Sheath_df = pd.DataFrame(Sheath_dico_df)
    dF_labels = ["Elapsed_time" ,  "Temp_cum" ,  "Temperature" ,  "Num_plante" ,  "Genotype" ,  "Num_talle" , "Num_cohorte", "Num_rang" ,"Sheath_sumtemp"  ,"Sheath_diameter" , "Sheath_length" ,  "Sheath_final_length" , "Sheath_surface" , "Sheath_PAR" , "Photosynthetic"]
    Sheath_df = _Sheath_df.reindex_axis(dF_labels, axis="columns", copy=False)
    Sheath_df.to_csv(pj(out_dir,folder_name, "Sheath.csv"), sep="\t", header=True, index=False)

  if write_output_file["Ear"] == True:
    _Ear_df = pd.DataFrame(Ear_dico_df)
    dF_labels = ["Elapsed_time", "Temp_cum" , "Num_plante" ,"Genotype", "Num_talle" , "Ear_sumtemp"  , "Ear_length" ,"Ear_surface", "Ear_PAR", "Photosynthetic", "Emerged"]
    Ear_df = _Ear_df.reindex_axis(dF_labels, axis="columns", copy=False)
    Ear_df.to_csv(pj(out_dir,folder_name, "Ear.csv"), sep="\t", header=True, index=False)

  if write_output_file["Proba"] == True:
    _Proba_df = pd.DataFrame(Proba_dico_df)
    dF_labels = ["Elapsed_time", "Temperature", "Temp_cum", "Num_plante", "Genotype", "Num_talle", "Num_rang", "Sumtemp", "GAI_prox", "P_debourr"]
    Proba_df = _Proba_df.reindex_axis(dF_labels, axis="columns", copy=False)
    Proba_df.to_csv(pj(out_dir,folder_name, "Probabilities.csv"), sep="\t", header=True, index=False)

  if write_output_file["Peraxes"] == True:
    _Peraxes_df = pd.DataFrame(Peraxes_dico_df)
    dF_labels = ["Init_flag","Elapsed_time", "DOY","Temperature", "Temp_cum", "Num_plante", "Num_talle", "Sheath_max", "Collar_height", "Dead_collar_height", "Delta_H", "Visible_leaves_surface", "Visible_surface", "Leaf_contrib_to_GAI","Stem_contrib_to_GAI","Ear_contrib_to_GAI","Peduncle_contrib_to_GAI", "Stop_growth_flag"]
    Peraxes_df = _Peraxes_df.reindex_axis(dF_labels, axis="columns", copy=False)
    Peraxes_df.to_csv(pj(out_dir,folder_name, "Peraxes.csv"), sep="\t", header=True, index=False)

  if write_debug_PAR == True:
    Debug_PAR_df = pd.DataFrame(Debug_PAR_dico_df)
    Debug_PAR_df.to_csv(pj(out_dir,folder_name, "Debug_PAR.csv"), sep="\t", header=True, index=False)

  if write_output_file["PAR_per_axes"] == True:
    PAR_per_axes_df = pd.DataFrame(PAR_per_axes_dico)
    PAR_per_axes_df.to_csv(pj(out_dir,folder_name, "PAR_per_axes.csv"), sep = "\t", header = True, index = False)

  # FICHIER PARAMETRES
  
  fichier_params = open(pj(out_dir,folder_name, "Parameters.csv"), "w")
  fichier_params.write("Parameter" + "\t" + "Genotype" + "\t" + "Value" + "\n" +
                       "WALTer_version" + "\t" + "All" + "\t" + "%s" % WALTer_version + "\n" +
                       "WALTer_build" + "\t" + "All" + "\t" + "%s" % WALTer_build + "\n" +
                       "Related_experiment" + "\t" + "All" + "\t" + "%s" % expe_related + "\n" +
                       "Crop_conception" + "\t" + "All" + "\t" + "%s" % crop_ccptn + "\n" +
                       "Sowing_date" + "\t" + "All" + "\t" + "%s" % sowing_date + "\n" +
                       "Year" + "\t" + "All" + "\t" + "%s" % year + "\n" +
                       "Location" + "\t" + "All" + "\t" + "%s" % location + "\n" +
                       "Latitude" + "\t" + "All" + "\t" + "%s" % latitude + "\n" +
                       "Nbj" + "\t" + "All" + "\t" + "%s" % nbj + "\n" +
                       "rep" + "\t" + "All" + "\t" + "%s" % rep + "\n" +
                       "densite" + "\t" + "All" + "\t" + "%s" % densite + "\n" +
                       "Nb_rang" + "\t" + "All" + "\t" + "%s" % nb_rangs + "\n" +
                       "Nb_plantes" + "\t" + "All" + "\t" + "%s" % nb_plantes + "\n" +
                       "Area_targeted" + "\t" + "All" + "\t" + "%s" % area_targeted + "\n" +
                       "Nb_plantes_utiles" + "\t" + "All" + "\t" + "%s" % crop_scheme["nb_useful_plt"] + "\n" +
                       "dist_border_x" + "\t" + "All" + "\t" + "%s" % dist_border_x + "\n" +
                       "dist_border_y" + "\t" + "All" + "\t" + "%s" % dist_border_y + "\n" +
                       "Genotypes_nb" + "\t" + "All" + "\t" + "%s" % geno_nb + "\n" +
                       "CARIBU_state" + "\t" + "All" + "\t" + "%s" % CARIBU_state + "\n" +
                       "SIRIUS_state" + "\t" + "All" + "\t" + "%s" % SIRIUS_state + "\n" +
                       "Radiation_type" + "\t" + "All" + "\t" + "%s" % radiation_type + "\n" +
                       "infinity_GAIp"  + "\t" + "All" + "\t" + "%s" % infinity_GAIp + "\n" +
                       "infinity_CARIBU" + "\t" + "All" + "\t" + "%s" % infinity_CARIBU + "\n" +
                       "Light_step" + "\t" + "All" + "\t" + "%s" % PAS + "\n" +
                       "nb_azimuth" + "\t" + "All" + "\t" + "%s" % nb_azimuth + "\n" +
                       "nb_zenith" + "\t" + "All" + "\t" + "%s" % nb_zenith + "\n" +
                       "dist_inter_rang" + "\t" + "All" + "\t" + "%s" % dist_inter_rang + "\n" +
                       "dist_intra_rang" + "\t" + "All" + "\t" + "%s" % dist_intra_rang + "\n" +
                       "dx" + "\t" + "All" + "\t" + "%s" % dx  + "\n" +
                       "dy" + "\t" + "All" + "\t" + "%s" % dy  + "\n" +
                       "Hazard_plant_xy" + "\t" + "All" + "\t" + "%s" % hazard_driver["plant_xy"]  + "\n" +
                       "Hazard_plant_azi" + "\t" + "All" + "\t" + "%s" % hazard_driver["plant_azi"]  + "\n" +
                       "Hazard_axis" + "\t" + "All" + "\t" + "%s" % hazard_driver["axis"]  + "\n" +
                       "Hazard_organ" + "\t" + "All" + "\t" + "%s" % hazard_driver["organ"]  + "\n" +
                       "Hazard_emerg" + "\t" + "All" + "\t" + "%s" % hazard_driver["emerg"]  + "\n" +
                       "N_p_s" + "\t" + "All" + "\t" + "%s" % N_p_s + "\n" +
                       "l_c" + "\t" + "%s" % "All" + "\t" + "%s" % l_c + "\n" +
                       "L_b_S" + "\t" + "All" + "\t" + "%s" % L_b_S + "\n" +
                       "Psi_FT" + "\t" + "All" + "\t" + "%s" % Psi_FT + "\n" +
                       "Tbase" + "\t" + "All" + "\t" + "%s" % Tbase + "\n" +
                       "T_vern_min" + "\t" + "All" + "\t" + "%s" % Tvermin + "\n" +
                       "T_vern_opt" + "\t" + "All" + "\t" + "%s" % Tverint + "\n" +
                       "T_vern_max" + "\t" + "All" + "\t" + "%s" % Tvermax + "\n" +
                       "Lmax" + "\t" + "All" + "\t" + "%s" % Lmax + "\n" +
                       "Lmin" + "\t" + "All" + "\t" + "%s" % Lmin + "\n" +
                       "Ldecr" + "\t" + "All" + "\t" + "%s" % Ldecr + "\n" +
                       "Lincr" + "\t" + "All" + "\t" + "%s" % Lincr + "\n" +
                       "phyllo_decr" + "\t" + "All" + "\t" + "%s" % phyllo_decr + "\n" +
                       "phyllo_incr" + "\t" + "All" + "\t" + "%s" % phyllo_incr + "\n" +
                       "DLsat" + "\t" + "All" + "\t" + "%s" % DLsat + "\n" +
                       "Delta_b"  + "\t" + "All" + "\t" + "%s" %  Delta_b + "\n" +
                       "dGAIp"  + "\t" + "All" + "\t" + "%s" % dGAIp + "\n" +
                       "Delta_l"  + "\t" + "All" + "\t" + "%s" % Delta_l + "\n" +
                       "Delta_c_GN" + "\t" + "All" + "\t" + "%s" % Delta_c_GN + "\n" +
                       "Delta_hf" + "\t" + "All" + "\t" + "%s" % Delta_hf   + "\n" +
                       "Delta_hm" + "\t" + "All" + "\t" + "%s" % Delta_hm  + "\n" +
                       "Delta_lflf" + "\t" + "All" + "\t" + "%s" % Delta_lflf + "\n"+
                       "Delta_flsp" + "\t" + "All" + "\t" + "%s" % Delta_flsp + "\n"+
                       "Delta_SGtR" + "\t" + "All" + "\t" + "%s" % Delta_SGtR + "\n"+
                       "Delta_SGtC" + "\t" + "All" + "\t" + "%s" % Delta_SGtC + "\n"+
                       "ED_I" + "\t" + "All" + "\t" + "%s" % ED_I + "\n" +
                       "ED_B" + "\t" + "All" + "\t" + "%s" % ED_B + "\n" +
                       "ED_FB"  + "\t" + "All" + "\t" + "%s" % ED_FB + "\n" +
                       "ED_S" + "\t" + "All" + "\t" + "%s" % ED_S + "\n" +
                       "Phi_azi_B"  + "\t" + "All" + "\t" + "%s" % Phi_azi_B + "\n" +
                       "Phi_zen_T"   + "\t" + "All" + "\t" + "%s" % Phi_zen_T + "\n" +
                       "Phi_azi_T"  + "\t" + "All" + "\t" + "%s" % Phi_azi_T + "\n" +
                       "Phi_zen_E"  + "\t" + "All" + "\t" + "%s" % Phi_zen_E + "\n" +
                       "Phi_azi_S"  + "\t" + "All" + "\t" + "%s" % Phi_azi_S + "\n" +
                       "Phi_zen_S"  + "\t" + "All" + "\t" + "%s" % Phi_zen_S + "\n" +
                       "y_position_hazard"  + "\t" + "All" + "\t" + "%s" % y_position_hazard + "\n" +
                       "x_position_hazard"  + "\t" + "All" + "\t" + "%s" % x_position_hazard + "\n" +
                       "z_position_hazard"  + "\t" + "All" + "\t" + "%s" % z_position_hazard + "\n" +
                       "blade_incl_hazard"  + "\t" + "All" + "\t" + "%s" % blade_incl_hazard + "\n" +
                       "blade_azi_hazard"  + "\t" + "All" + "\t" + "%s" % blade_azi_hazard + "\n" +
                       "till_zen_hazard"  + "\t" + "All" + "\t" + "%s" % till_zen_hazard + "\n" +
                       "till_azi_hazard"  + "\t" + "All" + "\t" + "%s" % till_azi_hazard + "\n" + 
                       "genotype_proportion"  + "\t" + "All" + "\t" + "%s" % genotype_proportion + "\n")

  for geno in crop_genotype:
    fichier_params.write("Phl" + "\t" + "%s" % geno + "\t" + "%s" % Phl[geno] + "\n" +
                         "corrected_Phl" + "\t" + "%s" % geno + "\t" + "%s" % phyll_adjust(geno) + "\n" +
                         "Pls" + "\t" + "%s" % geno + "\t" + "%s" % Pls[geno] + "\n" +
                         "VAI" + "\t" + "%s" % geno + "\t" + "%s" % VAI[geno] + "\n" +
                         "VBEE" + "\t" + geno + "\t" + "%s" % VBEE[geno] + "\n" +
                         "SLDL" + "\t"+ "%s" % geno + "\t"  + "%s" % SLDL[geno] + "\n" +
                         "Dse_mean" + "\t" + "%s" % geno + "\t" + "%s" % Dse[geno]["mean"] + "\n" +
                         "Dse_sd" + "\t" + "%s" %  geno  + "\t" + "%s" % Dse[geno]["sd"] + "\n" +
                         "N_I_el" + "\t" + "%s" %  geno + "\t" + "%s" % N_I_el[geno] + "\n" +
                         "s_B_1" + "\t" + geno + "\t" + "%s" % s_B_1[geno] + "\n" +
                         "N_B_r" + "\t" + "%s" %  geno  + "\t" + "%s" % N_B_r[geno] + "\n" +
                         "L_B_1" + "\t" + "%s" %  geno  + "\t" + "%s" % L_B_1[geno] + "\n" +
                         "L_B_max" + "\t" + "%s" %  geno  + "\t" + "%s" % L_B_max[geno] + "\n" +
                         "s_B_f" + "\t" + "%s" % geno + "\t" + "%s" % s_B_f[geno] + "\n" +
                         "a_B_w" + "\t" + "%s" % geno + "\t" + "%s" % a_B_w[geno] + "\n" +
                         "b_B_w" + "\t" + "%s" % geno + "\t" + "%s" % b_B_w[geno] + "\n" +
                         "a_S_L" + "\t" + "%s" % geno + "\t" + "%s" % a_S_L[geno] + "\n" +
                         "b_S_L" + "\t" + "%s" % geno + "\t" + "%s" % b_S_L[geno] + "\n" +
                         "inc_I"  + "\t" + "%s" % geno + "\t" + "%s" % inc_I[geno] + "\n" +
                         "shape_internode"   + "\t" + "%s" % geno + "\t" + "%s" % shp_I[geno] + "\n" +
                         "b_I_L"   + "\t" + "%s" % geno + "\t" + "%s" % b_I_L[geno] + "\n" +
                         "a_I_L"   + "\t" + "%s" % geno + "\t" + "%s" % a_I_L[geno] + "\n" +
                         "d_I" + "\t" + "%s" % geno + "\t" + "%s" % d_I[geno] + "\n" +
                         "L_P" + "\t" + geno + "\t" + "%s" % L_P[geno] + "\n" +
                         "d_P" + "\t" + "%s" % geno + "\t" + "%s" % d_P[geno] + "\n" +
                         "d_E" + "\t" + "%s" % geno + "\t" + "%s" % d_E[geno] + "\n" +
                         "L_E" + "\t" +  "%s" % geno + "\t" + "%s" % L_E[geno] + "\n" +
                         "d_S" + "\t" + "%s" % geno + "\t" + "%s" % d_S[geno] + "\n" +
                         "n0_sen" + "\t" + "%s" % geno + "\t" + "%s" % n0_sen[geno] + "\n" +
                         "n1_sen" + "\t" + "%s" % geno + "\t" + "%s" % n1_sen[geno] + "\n" +
                         "n2_sen" + "\t" + "%s" % geno + "\t" + "%s" % n2_sen[geno] + "\n" +
                         "n3_sen" + "\t" + "%s" % geno + "\t" + "%s" % n3_sen[geno] + "\n" +
                         "t0_sen" + "\t" + "%s" % geno + "\t" + "%s" % t0_sen[geno] + "\n" +
                         "t1_sen" + "\t" + "%s" % geno + "\t" + "%s" % t1_sen[geno] + "\n" +
                         "t2_sen" + "\t" + "%s" % geno + "\t" + "%s" % t2_sen[geno] + "\n" +
                         "t3_sen" + "\t" + "%s" % geno + "\t" + "%s" % t3_sen[geno] + "\n" +
                         "DelayTipToHS" + "\t" + "%s" % geno + "\t" + "%s" % DelayTipToHS[geno] + "\n" +
                         "P_CT" + "\t" + "%s" %  geno  + "\t" + "%s" % P_CT[geno] + "\n" +
                         "GAI_critique" + "\t"+ "%s" % geno + "\t"  + "%s" % GAI_c[geno] + "\n" +
                         "t_beg_reg"  + "\t" + geno + "\t" + "%s" % t_beg_reg[geno] + "\n" +
                         "Delta_prot" + "\t" + geno + "\t" + "%s" %  Delta_prot[geno] + "\n" +
                         "PAR_t" + "\t" + geno + "\t" + "%s" % PAR_t[geno] + "\n" +
                         "P_T" + "\t" + "%s" %  geno  + "\t" + "%s" % P_T[geno] + "\n" +
                         "Param_PlHeight" + "\t" + "%s" %  geno  + "\t" + "%s" % Param_PlHeight[geno] + "\n" + 
                         "Phi_zen_B" + "\t" + "%s" %  geno  + "\t" + "%s" % Phi_zen_B[geno] + "\n"+
                         "Param_Ln_final" + "\t" + "%s" %  geno  + "\t" + "%s" % param_Ln_final[geno] + "\n")
  fichier_params.close()
  print "Au revoir"
  fichier_individual= open(pj(out_dir,folder_name, "Individual_heterogeneity.csv"), "w")
  fichier_individual.write("Parameter" + "\t" + "Num_plante" + "\t" + "Dse" + "\n" )
  for numplt in range(1,crop_scheme["nplant_peupl"] + 1):
    fichier_individual.write("Dse_ind" + "\t" + "%s" % numplt + "\t" + "%s" % Dse_heterogeneous[numplt] + "\n" )
  fichier_individual.close()

  if write_output_file["GAI"] == True:
    _GAI_df = pd.DataFrame(GAI_dico_df)
    dF_labels = ["Init_flag","Elapsed_time","Temp_cum","DOY","Genotype","Num_plante","Surface_plante","Surface_visible","Surface_sol","GAI_tot","GAI_center","GAI_ind","GAI_prox","Position","Weakest_axis","PAR_weakest_axis"]
    GAI_df = _GAI_df.reindex_axis(dF_labels,  axis="columns", copy=False)
    GAI_df.to_csv(pj(out_dir,folder_name, "GAI.csv"), sep="\t", header=True, index=False)
  

Axiom:Seed

derivation length: int(nbj)
# nbj jours

###########PRODUCTION##########

production:

group 1:
Seed:
  global beginning_CARIBU
  global ending_CARIBU
  
  fichier_parcelle = open(pj(out_dir,folder_name, "Parcelle.csv"), "w")
  
  fichier_parcelle.write("X" + "\t" + "Y" + "\t" + "Num_plante" + "\t" + "Genotype" + "\n")
  
  # Calculates the coordinates of each plant
  plant_disposition(crop_scheme["nb_rang"], crop_scheme["nb_plante_par_rang"], crop_scheme["dist_inter_rang"], crop_scheme["dist_intra_rang"])
  
  xmin = -(crop_scheme["dy"]*100)/2
  xmax = (crop_scheme["dy"]*100)/2
  ymin = -(crop_scheme["dx"]*100)/2
  ymax = (crop_scheme["dx"]*100)/2
  
  #  xmin_center = xmin + ((crop_scheme["dist_intra_rang"] * 100 * nb_plante_par_rang_border) + x_position_hazard)
  #  xmax_center = xmax - ((crop_scheme["dist_intra_rang"] * 100 * nb_plante_par_rang_border) + x_position_hazard)
  #  ymin_center = ymin + ((crop_scheme["dist_inter_rang"]*100 * nb_rang_border) + y_position_hazard)
  #  ymax_center = ymax - ((crop_scheme["dist_inter_rang"]*100 * nb_rang_border) + y_position_hazard)
  #  
  xmin_center = xmin + (dist_border_x + x_position_hazard)
  xmax_center = xmax - (dist_border_x + x_position_hazard)
  ymin_center = ymin + (dist_border_y + y_position_hazard)
  ymax_center = ymax - (dist_border_y + y_position_hazard)
  
  
  print "xmin : ", xmin, "xmax : ", xmax, "xmin_center", xmin_center, "xmax_center", xmax_center
  print "ymin : ", ymin, "ymax : ", ymax, "ymin_center", ymin_center, "ymax_center", ymax_center
  
  for num_plante in range(1,int(crop_scheme["nplant_peupl"]) + 1):
    #Calculation of new coordinats of this plant, taking into account a centering of the crop around the 0
    x = plant_translation(plant_map[num_plante]["x"], plant_map[num_plante]["y"],crop_scheme["map_middle_x"], crop_scheme["map_middle_y"])["x"]
    y = plant_translation(plant_map[num_plante]["x"], plant_map[num_plante]["y"],crop_scheme["map_middle_x"], crop_scheme["map_middle_y"])["y"]
    if genotype_proportion == "random":
      geno = random.choice(crop_genotype)    ## selection geno random
      genotype_map[num_plante] = geno
    elif genotype_proportion == "equal":
      geno = genotype_list[num_plante-1]
      genotype_map[num_plante] = geno
    
    Dse_heterogeneous[num_plante] = max(0,random.normalvariate(Dse[geno]["mean"],Dse[geno]["sd"] ))
    positions[num_plante] = {"x" : x + random.uniform(-x_position_hazard, x_position_hazard) ,"y" : y + random.uniform(-y_position_hazard, y_position_hazard),"z" : 0}
    
    #Determining which plant is in the border, which plant is not
    if positions[num_plante]["x"] <= xmin_center or positions[num_plante]["x"] >= xmax_center:
      border_plants.append(num_plante)
    if num_plante not in border_plants:
      if positions[num_plante]["y"] <= ymin_center or positions[num_plante]["y"] >= ymax_center:
        border_plants.append(num_plante)
    
    #Dictionnary initialisation
    
    ## Individual scale
    initialization_Flag[num_plante] = True
    GAI_prox[num_plante] = 0
    GAI_ind[num_plante] = 0
    tiller_death[num_plante] = {}
    tiller_death_now[num_plante] = (2,)
    dead_tillers[num_plante] = []      
    youngest_axes[num_plante] = []
    weakest_axis[num_plante] = {}
    dico_cut_fantom_axes[num_plante] = {}      
    future_dead_axes[num_plante] = []
    plant_shield_indicator[num_plante] = {"Shield": False, "count": 0.0}
    
    surface_plante[num_plante] = 0.01
    surface_plante_visible[num_plante] = 0.01
    
    surface_sol[num_plante] = crop_scheme["dist_inter_rang"] * crop_scheme["dist_intra_rang"]
    
    ## Axis scale
    ### about emerged organs
    first_leaf_phase2[num_plante] = {}
    first_leaf_phase2[num_plante][tiller_init] = {"num_first_leaf_phase_2" : 0, "length_first_leaf_phase_2" : 0}
    LNfinal[num_plante] = {}
    LNfinal[num_plante][tiller_init] = 0
    axis_census[num_plante] = {}
    axis_census[num_plante][tiller_init] = {"emerg_date" : Dse_heterogeneous[num_plante], "Stop_growth_flag" : False, "Regression_flag" : False}
    
    dico_stades[num_plante] = {}
    dico_stades[num_plante][tiller_init] = {"Age" : 0 ,"Blade_Transiflo" : False, "Transiflo" : [False,10000,0], "Montaison" : [False,10000,0],"Ear_emergence" : False, "Epiaison" : [False,10000,0], "Flo" : [False,10000,0], "Maturite" : [False,10000,0], "Ln_final":"undefined", "End_internode_elongation" : False, "Senescence_flag_leaf" : [False, 10000, 0]}
    
    dico_PAR["Blade"][num_plante] = {}
    dico_PAR["Sheath"][num_plante] = {}
    dico_PAR["Internode"][num_plante] = {}
    dico_PAR["Peduncle"][num_plante] = {}
    dico_PAR["Ear"][num_plante] = {}
    dico_PAR["Blade"][num_plante][tiller_init] = {}
    dico_PAR["Sheath"][num_plante][tiller_init] = {}
    dico_PAR["Internode"][num_plante][tiller_init] = {}
    dico_PAR["Peduncle"][num_plante][tiller_init] = {}
    dico_PAR["Ear"][num_plante][tiller_init] = {}
    dico_PAR_per_axis[num_plante] = {}
    dico_PAR_per_axis[num_plante][tiller_init] = {}
    
    dico_cut_dead_blades[num_plante] = {}
    dico_cut_dead_blades[num_plante][tiller_init] = []
    
    hazard_dict_axis[num_plante] = {}
    hazard_dict_axis[num_plante][tiller_init] = {"tiller_azimuth" : Phi_azi_S + random.randint(0,plant_azi_hazard) , "tiller_zenith" : Phi_zen_S}
    
    ### about initiated organs
    date_emission[num_plante] = {}
    date_emission[num_plante][tiller_init] = Dse_heterogeneous[num_plante]
    Hcol_max[num_plante] = {}
    Hcol_max[num_plante][tiller_init] = 0
    Hcol_dead[num_plante] = {}
    Hcol_dead[num_plante][tiller_init] = 0
    delta_H[num_plante] = {}
    delta_H[num_plante][tiller_init] = 0      
    tiller_surface[(num_plante,tiller_init)] = 0.0
    
    # Phytomer scale
    
    current_sheath_length[num_plante] = {}
    current_sheath_length[num_plante][tiller_init] = {0: l_c}
    dead_sheath_length[num_plante] = {}
    dead_sheath_length[num_plante][tiller_init] = {0:0}
    
    
    current_internode_length[num_plante] = {}
    current_internode_length[num_plante][tiller_init] = {} 
    
    final_blade_length[num_plante] = {}
    final_blade_length[num_plante][tiller_init] = {} 
    
    leaf_emergence[num_plante] = {}
    leaf_emergence[num_plante][tiller_init] = {1: (0,0)}
    
    Sh_max[num_plante] = {}
    Sh_max[num_plante][tiller_init] = {0 : 0.0}
    
    hazard_dict_organ[num_plante] = {}
    hazard_dict_organ[num_plante][tiller_init] = {}
    
    fichier_parcelle.write("%s" % positions[num_plante]["x"] + "\t" + "%s" % positions[num_plante]["y"] + "\t" + "%s" % num_plante + "\t" + "%s" % geno + "\n")
    nproduce  @M(positions[num_plante]["x"],positions[num_plante]["y"],positions[num_plante]["z"])
    
    StA = Apex(num_plante, geno, tiller_init, 0,0)
    StCPB = CutPointBud(num_plante,geno,tiller_init)
    nproduce CutPointBud(StCPB)Apex(StA)
  
  print "border plants : ", border_plants
  
  if border_plants != plant_census: #TODO ajouter un nom plus explicite pour les plantes du centre/bordure.
    for brd_plt in border_plants:
      plant_census.remove(brd_plt)
  print "plant census 2 : ",plant_census
  crop_scheme["nb_useful_plt"] = len(plant_census)
  nb_plantes_utiles = crop_scheme["nb_useful_plt"] 
  print crop_scheme["nb_useful_plt"]," plantes utiles sur ",crop_scheme["nplant_peupl"]
  print "All plants in border : ",border_plants == plant_census
  set_neighbour(maillage, crop_scheme["nb_rang"], crop_scheme["nb_plante_par_rang"], crop_scheme["dist_intra_rang"], crop_scheme["dist_inter_rang"], dGAIp, infinity_GAIp)
  
  #d�terminer la plante la plus pr�coce
  global earliest_plant
  global latest_plant
  global param_Ln_final
  minimal_emergence = min(Dse_heterogeneous.values())
  maximal_emergence = max(Dse_heterogeneous.values())
  
  for key, value in Dse_heterogeneous.iteritems():
    if value == minimal_emergence:
      earliest_plant = key
    if value == maximal_emergence:
      latest_plant = key
  # List phyllochrones of all the genotypes presents within the crop
  all_phyllo = {}
  for g in crop_genotype:
    all_phyllo[phyll_adjust(g)] = g
  longest_phyllo = max(all_phyllo.keys())
  shortest_phyllo = min(all_phyllo.keys())
  earliest_geno = all_phyllo[shortest_phyllo]
  latest_geno = all_phyllo[longest_phyllo]
  if 'beginning_CARIBU' in params:
    beginning_CARIBU = params['beginning_CARIBU']
  else:
    beginning_CARIBU = (leaf_emerg_date(t_beg_reg[genotype_map[earliest_plant]], (1,), earliest_geno, earliest_plant) + 1.6 * shortest_phyllo) - 100
  ending_CARIBU = (leaf_emerg_date(ceil(max(param_Ln_final.values())),(1,), latest_geno, latest_plant) +  2.98 * longest_phyllo) +100
  print "Beginning CARIBU : ",beginning_CARIBU, "Ending CARIBU : ", ending_CARIBU
  useGroup(2)


group 2:


Apex(StA):
  if SIRIUS_state == "disabled":
    StA.Ln_final = int(param_Ln_final[StA.geno])+int(random.random() + param_Ln_final[StA.geno]%1)
    dico_stades[StA.num_plante][(1,)]["Ln_final"] = StA.Ln_final
    t_beg_reg_ind = t_beg_reg[StA.geno] + (11 - dico_stades[StA.num_plante][(1,)]["Ln_final"])
    t_beg_reg_ind_Tht[StA.num_plante] = leaf_emerg_date(t_beg_reg_ind, (1,), StA.geno, StA.num_plante) + 1.6*phyll_adjust(StA.geno) #11 est mis en dur car c'est le nombre de feuille final pour lequel ce param�tre a �t� mis en place � la base
    useGroup(3)
  
  elif SIRIUS_state == "enabled":
    
    global _Tempcum
    global DOY
    
    for day in range(1,300):
      date_current_day = sowing_date + datetime.timedelta(day) 	        # Date � laquelle nous nous trouvons pour un elapsed_time donn�
      _current_temperature = meteo_dF[(meteo_dF["year"] == date_current_day.year) & (meteo_dF["month"] == date_current_day.month) & (meteo_dF["day"] == date_current_day.day)]['TM']
      current_temperature = _current_temperature[_current_temperature.last_valid_index()]
      _Tempcum += max(Tbase,current_temperature)
      DOY = int(date_current_day.strftime('%j'))
      if DOY == 365:
        DOY = 1
      else:
        DOY += 1
      Apex_Sirius_dico_df['Elapsed_time'].append(day)
      Apex_Sirius_dico_df['Temperature'].append(current_temperature)
      Apex_Sirius_dico_df['Temp_cum'].append(_Tempcum)
      Apex_Sirius_dico_df['Daylength'].append(duree_du_jour(latitude,DOY))
      Apex_Sirius_dico_df['Num_plante'].append(StA.num_plante)
      Apex_Sirius_dico_df['Genotype'].append(StA.geno)
      Apex_Sirius_dico_df['PN'].append(StA.pn)
      Apex_Sirius_dico_df['LN'].append(StA.ln)
      Apex_Sirius_dico_df['Sumtemp'].append(StA.sumtemp)
      Apex_Sirius_dico_df['Vern_rate'].append(StA.vern_rate)
      Apex_Sirius_dico_df['Vern_prog'].append(StA.vern_prog)
      Apex_Sirius_dico_df['Vern_flag'].append(StA.vrn)
      Apex_Sirius_dico_df['Debut_ppd_flag'].append(StA.debut_ppd)
      Apex_Sirius_dico_df['Fin_ppd_flag'].append(StA.photop_flag)
      Apex_Sirius_dico_df['Ln_pot'].append(StA.Ln_pot)
      Apex_Sirius_dico_df['Var_L_min'].append(StA.var_Lmin)
      Apex_Sirius_dico_df['Ln_app'].append(StA.Ln_app)
      Apex_Sirius_dico_df['Ln_final'].append(StA.Ln_final)
      if _Tempcum >= Dse_heterogeneous[StA.num_plante]:
        StA.sumtemp += max(Tbase,current_temperature)
        
        if StA.ln < Ldecr:
          StA.ln = phyllo_decr * StA.sumtemp /phyll_adjust(StA.geno)
        elif Ldecr <= StA.ln < Lincr:
          StA.ln = StA.sumtemp /phyll_adjust(StA.geno)
        elif StA.ln >= Lincr:
          StA.ln = phyllo_incr * StA.sumtemp /phyll_adjust(StA.geno)
        
        StA.pn = 2 * StA.ln + 4
        # Vernalisation
        if StA.vrn == False:
          StA.vern_rate = vrate(current_temperature,StA.geno)
          StA.vern_prog += StA.vern_rate
          StA.vern_rate = 0
          if StA.vern_prog >= 1 or StA.pn > Lmax: #la vernalisation progresse
            StA.vrn = True
            StA.var_Lmin = max(StA.var_Lmin, StA.pn)
          else:
            StA.Ln_pot = Lmax - (Lmax - StA.var_Lmin) * StA.vern_prog
            if StA.pn >= StA.Ln_pot:
              StA.vrn = True
              StA.var_Lmin = max((StA.Ln_pot + StA.pn)/2.0, StA.var_Lmin)
        # Photoperiode
        if StA.vrn == True and StA.ln > 1.5:
          if StA.photop_flag == False:
            StA.debut_ppd = True
            if duree_du_jour(latitude,DOY) > DLsat:
              StA.Ln_final = StA.var_Lmin
              StA.photop_flag = True
            else:
              StA.Ln_app = StA.var_Lmin + SLDL[StA.geno] * (DLsat - duree_du_jour(latitude,DOY))
              #Sortie finale de la s�rie de tests
              if 0.5 * StA.Ln_app <= StA.ln: # Sert � d�terminer le nombre de feuilles visibles EDIT (c'est plut�t le nombre de primordia emis)
                StA.photop_flag = True
                StA.Ln_app = StA.Ln_app
                MSLn_app[StA.num_plante] = StA.Ln_app
                
                StA.Ln_final = int(StA.Ln_app)+int(random.random()+StA.Ln_app%1)
                dico_stades[StA.num_plante][(1,)]["Ln_final"] = StA.Ln_final
                
                t_beg_reg_ind = t_beg_reg[StA.geno] + (11 - dico_stades[StA.num_plante][(1,)]["Ln_final"])
                t_beg_reg_ind_Tht[StA.num_plante] = leaf_emerg_date(t_beg_reg_ind, (1,), StA.geno, StA.num_plante) + 1.6*phyll_adjust(StA.geno) #11 est mis en dur car c'est le nombre de feuille final pour lequel ce param�tre a �t� mis en place � la base
    _Tempcum = 0
    date_current_day = sowing_date + datetime.timedelta(2) 	        # Date � laquelle nous nous trouvons pour un elapsed_time donn�
    DOY = int(date_current_day.strftime('%j'))
    useGroup(3)

group 3:

#INITIALISATION DU MODELE 
###########################

Apex(StA):
  global elapsed_time
  global Tempcum
  global DOY
  global date_current_day
  
  
  if StA.n < N_p_s and initialization_Flag[StA.num_plante] == True:
    StA.sumtemp += max(Tbase,Temperature)
    StA.time += max(Tbase,Temperature)
    
    if StA.time >= Pls[StA.geno]:
      StL = Leaf(StA.num_plante, StA.geno, StA.tiller, StA.n + 1)
      StBu_p = Bud_primord(StA.num_plante, StA.geno, StA.tiller, StA.n + 1)
      StBu_p.sumtemp = StA.time%Pls[StA.geno]
      #StBu_p.tiller_incl = StA.tiller_incl
      StI = Internode(StA.num_plante, StA.geno, StA.tiller, StA.n + 1)
      StA.time = StA.time % Pls[StA.geno]
      StL.date_emerg = leaf_emerg_date(StL.n, StL.tiller, StL.geno, StL.num_plante)
      
      # Formatting phytomer scaled dictionnaries
      current_internode_length[StL.num_plante][StL.tiller][StL.n] = 0 
      Sh_max[StA.num_plante][StL.tiller][StL.n] = 0.0
      final_blade_length[StL.num_plante][StL.tiller][StL.n] = 0        # Formater le dico des longueurs finales
      final_blade_length[StL.num_plante][StL.tiller][StL.n] = 0
      current_sheath_length[StL.num_plante][StL.tiller][StL.n] = 0
      dead_sheath_length[StL.num_plante][StL.tiller][StL.n] = 0
      
      hazard_dict_organ[StL.num_plante][StL.tiller][StL.n] = {}
      hazard_dict_organ[StL.num_plante][StL.tiller][StL.n]["blade_inclination"] = Phi_zen_B[StL.geno] + random.uniform(-blade_incl_hazard, blade_incl_hazard)
      
      ### End of dictionnaries formatting ###
      
      blade_phyllotaxy(StL.n, StL.tiller, StL.num_plante, N_I_el[StL.geno], Phi_azi_B, blade_azi_hazard)
      
      StI.azimuth = hazard_dict_organ[StL.num_plante][StL.tiller][StL.n]["blade_azimuth"]
      #print "angle", StI.tiller, "n", StI.n, StI.azimuth
      
      nproduce [Bud_primord(StBu_p)]Internode(StI)[Leaf(StL)]Apex(StA)
      StA.n += 1
    else:
      produce Apex(StA)
      
  elif StA.n >= N_p_s :
    #print "Moi, numero",StA.num_plante,"J'ai fini l'initialisation"
    StA.sumtemp = 0
    StA.time = 0
    initialization_Flag[StA.num_plante] = False
    #lstring_gp3 = open("./WALTer_Lstring_group3.txt", "w")
    #lstring_gp3.close()
  if not np.any(initialization_Flag.values()):
    Tempcum = 0
    date_current_day = sowing_date + datetime.timedelta(elapsed_time)
    DOY = int(date_current_day.strftime('%j'))
    elapsed_time = 0
    useGroup(4)

Bud_primord(StBu_p):
  StBu_p.sumtemp += max(Tbase,Temperature)
  
  if StBu_p.sumtemp >= Delta_b * Pls[StBu_p.geno] and StBu_p.competent_flag == False:
    StBu_p.competent_flag = True
    new_tiller_name = StBu_p.tiller + (StBu_p.n,)
    StBu = Bud(StBu_p.num_plante, StBu_p.geno, new_tiller_name, 0, StBu_p.sumtemp%Pls[StBu_p.geno]) #On discr�tise proprement l'accumulation des temp�ratures en transmettant le surplus de temp�rature stock�e � l'Bud n�oform�
    StBu.sumtemp = StBu_p.sumtemp%Pls[StBu_p.geno]
    StBu.time = StBu_p.sumtemp%Pls[StBu_p.geno]
    
    # TODO : virer cette ligne si inutile ?
    # Formatting dictionnaries
    ## 
    date_emission[StBu.num_plante][new_tiller_name] = Tempcum
    Hcol_max[StBu.num_plante][new_tiller_name] = 0
    Hcol_dead[StBu.num_plante][new_tiller_name] = 0
    delta_H[StBu.num_plante][new_tiller_name] = 0
    tiller_surface[(StBu.num_plante,new_tiller_name)] = 0.0
    dico_cut_dead_blades[StBu.num_plante][new_tiller_name] = []
    
    hazard_dict_organ[StBu.num_plante][new_tiller_name] = {}
    hazard_dict_axis[StBu.num_plante][new_tiller_name] = {}
    hazard_dict_axis[StBu.num_plante][new_tiller_name]["tiller_azimuth"] = Phi_azi_T + random.uniform(-till_azi_hazard, till_azi_hazard)
    hazard_dict_axis[StBu.num_plante][new_tiller_name]["tiller_zenith"] = Phi_zen_T + random.uniform(-till_zen_hazard, till_zen_hazard)
    dico_stades[StBu.num_plante][new_tiller_name] = {"Age" : 0 ,"Blade_Transiflo" : False, "Transiflo" : [False,10000,0], "Montaison" : [False,10000,0],"Ear_emergence" : False, "Epiaison" : [False,10000,0], "Flo" : [False,10000,0], "Maturite" : [False,10000,0], "Ln_final":"undefined", "End_internode_elongation" : False, "Senescence_flag_leaf" : [False, 10000, 0]}
    
    ## Phytomer scaled dictionnaries
    current_internode_length[StBu.num_plante][StBu.tiller] = {}
    Sh_max[StBu.num_plante][StBu.tiller] = {0: 0.0}
    final_blade_length[StBu.num_plante][StBu.tiller] = {}
    current_sheath_length[StBu.num_plante][StBu.tiller] = {0: l_c}
    dead_sheath_length[StBu.num_plante][StBu.tiller] = {0:0.0}
    leaf_emergence[StBu.num_plante][StBu.tiller] = {1: (0,0)}
    
    ### END OF DICTIONNARIES FORMATAGE ###
    
    StCPB = CutPointBud(StBu.num_plante, StBu.geno, StBu.tiller)
    StCPB.tiller = StBu.tiller
    StCPB.tiller_zen = hazard_dict_axis[StCPB.num_plante][StCPB.tiller]["tiller_zenith"]
    
    dico_cut_fantom_axes[StBu.num_plante][StBu.tiller] = False
    produce CutPointBud(StCPB)[Bud(StBu)]

#remettre elapsed_time � 0
# TODO : exporter la lstring produite � la fin du group 3 pour l'importer?

Bud(StBu):
  StBu.nb_emerg_leaves = nb_emerged_leaves(Tempcum, StBu.tiller, StBu.geno, StBu.Ln_final)
  
  StBu.sumtemp += max(Tbase,Temperature)
  StBu.nb_j += time_step
  StBu.age += max(Tbase,Temperature)
  StBu.time += max(Tbase,Temperature)
  
  #Production de phytom�res
  if StBu.time >= Pls[StBu.geno]:
    if GAI_prox[StBu.num_plante] <= GAI_c[geno] or cohort_number(StBu.tiller) < 8: #TODO peut �tre � enlever sui on est encore dans la graine?
      StL = Leaf(StBu.num_plante, StBu.geno, StBu.tiller, StBu.n + 1)
      StBu_p = Bud_primord(StBu.num_plante, StBu.geno, StBu.tiller, StBu.n + 1)
      StBu_p.sumtemp = StBu.time%Pls[StBu.geno]
      StI = Internode(StBu.num_plante, StBu.geno, StBu.tiller, StBu.n + 1)
      StBu.time = StBu.time % Pls[StBu.geno]
      StL.date_emerg = leaf_emerg_date(StL.n, StL.tiller, StL.geno, StL.num_plante)
      
      # Formatting phytomer scaled dictionnaries
      current_internode_length[StL.num_plante][StL.tiller][StL.n] = 0 
      Sh_max[StL.num_plante][StL.tiller][StL.n] = 0.0
      final_blade_length[StL.num_plante][StL.tiller][StL.n] = 0        # Formater le dico des longueurs finales
      final_blade_length[StL.num_plante][StL.tiller][StL.n] = 0
      current_sheath_length[StL.num_plante][StL.tiller][StL.n] = 0
      dead_sheath_length[StL.num_plante][StL.tiller][StL.n] = 0
      
      hazard_dict_organ[StL.num_plante][StL.tiller][StL.n] = {}
      hazard_dict_organ[StL.num_plante][StL.tiller][StL.n]["blade_inclination"] = Phi_zen_B[StL.geno] + random.uniform(-blade_incl_hazard, blade_incl_hazard)
      
      ### End of dictionnaries formatting ###
      
      blade_phyllotaxy(StL.n, StL.tiller, StL.num_plante, N_I_el[StL.geno], Phi_azi_B, blade_azi_hazard)
      StI.azimuth = hazard_dict_organ[StL.num_plante][StL.tiller][StL.n]["blade_azimuth"]
      nproduce [Bud_primord(StBu_p)]Internode(StI)[Leaf(StL)]Bud(StBu)
      StBu.n += 1
    else:
      dico_cut_fantom_axes[StBu.num_plante][StBu.tiller] = True
  else:
    nproduce Bud(StBu)

Leaf(StL):
  StL.sumtemp += max(Tbase,Temperature)
  StL.age += time_step
  produce Leaf(StL)
  

Internode(StI):
  StI.diameter = d_I[StI.geno]
  StI.age += time_step
  StI.sumtemp += max(Tbase,Temperature)
  produce Internode(StI)

group 4:

Apex(StA):
  
  
  #Il ne se passe rien avant emergence
  if Tempcum >= Dse_heterogeneous[StA.num_plante]:
    # Tant que l'axe n'a pas �t� d�sign� pour r�gresser, tout fonctionne normalement
    if StA.tiller in axis_census[StA.num_plante] and axis_census[StA.num_plante][StA.tiller]["Stop_growth_flag"] == True:
      pass
    else:
      StA.age += time_step
      StA.sumtemp += max(Tbase,Temperature)
      StA.time += max(Tbase,Temperature)
      
      # Transition florale du brin-ma�tre
      # TODO possible de d�finir les dimensions des limbes ici?
      if StA.tiller == (1,):
        if StA.n >= StA.Ln_final and StA.transiflo == False: #Si brin-maitre ET nombre final de feuilles atteint on d�clenche la transiflo
          StA.transiflo = True
          dico_stades[StA.num_plante][StA.tiller]["Transiflo"] = [True, Tempcum, DOY]
          for axis in dico_stades[StA.num_plante].keys():
            if axis != (1,):
              dico_stades[StA.num_plante][axis]["Transiflo"][1] = dico_stades[StA.num_plante][(1,)]["Transiflo"][1] + round(transiflo_shift(axis, StA.geno), 2)
          StA.date_de_flo = leaf_emerg_date((StA.Ln_final), StA.tiller, StA.geno, StA.num_plante) + (ED_FB + ED_S + Delta_lflf) * phyll_adjust(StA.geno)
          dico_stades[StA.num_plante][StA.tiller]["Flo"][1] = StA.date_de_flo
          StA.date_epi = StA.date_de_flo - Delta_hf * phyll_adjust(StA.geno)
          dico_stades[StA.num_plante][StA.tiller]["Epiaison"][1] = dico_stades[StA.num_plante][StA.tiller]["Flo"][1] - Delta_hf * phyll_adjust(StA.geno)
          StA.date_mat = dico_stades[StA.num_plante][StA.tiller]["Epiaison"][1] + Delta_hm
          dico_stades[StA.num_plante][StA.tiller]["Maturite"][1] = dico_stades[StA.num_plante][StA.tiller]["Epiaison"][1] + Delta_hm
          StE = Ear(StA.num_plante, StA.geno, StA.tiller, StA.n)
          StE.emerged = True
          StP = Peduncle(StA.num_plante, StA.geno, StA.tiller, StA.n)
          StP.final_length = L_P[StP.geno]
          StAR = Apex_R(StA.num_plante, StA.geno, StA.tiller, StA.n)
          StAR.sumtemp = StA.sumtemp
          StAR.Ln_final = StA.Ln_final
          produce Peduncle(StP)Ear(StE)Apex_R(StAR)
          
      # Transition florale des talles
      elif StA.tiller != (1,) and StA.transiflo == False:
        if Tempcum >= dico_stades[StA.num_plante][StA.tiller]["Transiflo"][1]:
          StA.transiflo = True
          dico_stades[StA.num_plante][StA.tiller]["Transiflo"][0] = True
          dico_stades[StA.num_plante][StA.tiller]["Transiflo"][2] = DOY
          StA.Ln_final = StA.n
          dico_stades[StA.num_plante][StA.tiller]["Ln_final"] = StA.Ln_final
          StA.date_de_flo = leaf_emerg_date((StA.Ln_final), StA.tiller, StA.geno,StA.num_plante) + (ED_FB + ED_S + Delta_lflf) * phyll_adjust(StA.geno)
          dico_stades[StA.num_plante][StA.tiller]["Flo"][1] = StA.date_de_flo
          StA.date_epi = StA.date_de_flo - Delta_hf * phyll_adjust(StA.geno)
          dico_stades[StA.num_plante][StA.tiller]["Epiaison"][1] = dico_stades[StA.num_plante][StA.tiller]["Flo"][1] - Delta_hf * phyll_adjust(StA.geno)
          #if StA.tiller in liste_talles:
            #print StA.tiller , dico_stades[StA.num_plante][StA.tiller]["Epiaison"]
          StA.date_mat = dico_stades[StA.num_plante][StA.tiller]["Epiaison"][1] + Delta_hm
          dico_stades[StA.num_plante][StA.tiller]["Maturite"][1] = dico_stades[StA.num_plante][StA.tiller]["Epiaison"][1] + Delta_hm
          StE = Ear(StA.num_plante, StA.geno, StA.tiller, StA.n)
          StE.emerged = True
          StP = Peduncle(StA.num_plante, StA.geno, StA.tiller, StA.n)
          StP.final_length = L_P[StP.geno]
          StAR = Apex_R(StA.num_plante, StA.geno, StA.tiller, StA.n)
          StAR.sumtemp = StA.sumtemp
          StAR.Ln_final = StA.Ln_final
          produce Peduncle(StP)Ear(StE)Apex_R(StAR)
      
      # Production de primordia
      if StA.transiflo == False and StA.time >= Pls[StA.geno]  :
        StL = Leaf(StA.num_plante, StA.geno, StA.tiller, StA.n + 1)
        StBu_p = Bud_primord(StA.num_plante, StA.geno, StA.tiller, StA.n + 1)
        StBu_p.sumtemp = StA.time % Pls[StA.geno]
        #StBu_p.tiller_incl = StA.tiller_incl
        StI = Internode(StA.num_plante, StA.geno, StA.tiller, StA.n + 1)
        StA.time = StA.time % Pls[StA.geno]
        StL.date_emerg = leaf_emerg_date(StL.n, StL.tiller, StL.geno, StL.num_plante)
        
        # Formatting phytomer scaled dictionnaries
        current_internode_length[StL.num_plante][StL.tiller][StL.n] = 0 
        Sh_max[StA.num_plante][StL.tiller][StL.n] = 0.0
        final_blade_length[StL.num_plante][StL.tiller][StL.n] = 0        # Formater le dico des longueurs finales
        final_blade_length[StL.num_plante][StL.tiller][StL.n] = 0
        current_sheath_length[StL.num_plante][StL.tiller][StL.n] = 0
        dead_sheath_length[StL.num_plante][StL.tiller][StL.n] = 0
        
        hazard_dict_organ[StL.num_plante][StL.tiller][StL.n] = {}
        hazard_dict_organ[StL.num_plante][StL.tiller][StL.n]["blade_inclination"] = Phi_zen_B[StL.geno] + random.uniform(-blade_incl_hazard, blade_incl_hazard)
        
        ### End of dictionnaries formatting ###
        
        blade_phyllotaxy(StL.n, StL.tiller, StL.num_plante, N_I_el[StL.geno], Phi_azi_B, blade_azi_hazard)
        
        StI.azimuth = hazard_dict_organ[StL.num_plante][StL.tiller][StL.n]["blade_azimuth"]
        nproduce [Bud_primord(StBu_p)]Internode(StI)[Leaf(StL)]Apex(StA)
        
        StA.n += 1
      else:
        #Ecriture dans fichiers
        Apex_dico_df['Elapsed_time'].append(elapsed_time)
        Apex_dico_df['Temperature'].append(Temperature)
        Apex_dico_df['Temp_cum'].append(Tempcum)
        Apex_dico_df['Time_count'].append(StA.time)
        Apex_dico_df['Sum_temp'].append(StA.sumtemp)
        Apex_dico_df['Current_PAR'].append(current_PAR)
        Apex_dico_df['Num_plante'].append(StA.num_plante)
        Apex_dico_df['Genotype'].append(StA.geno)
        Apex_dico_df['Num_talle'].append(str(StA.tiller))
        Apex_dico_df['Num_cohorte'].append(cohort_number(StA.tiller))
        Apex_dico_df['Nb_phyto_emi'].append(StA.n)
        if Tempcum  >= Dse_heterogeneous[StA.num_plante]:
          Apex_dico_df['Nb_emerged_leaf'].append(max(leaf_emergence[StA.num_plante][StA.tiller].keys()))
        else:
          Apex_dico_df['Nb_emerged_leaf'].append(0)
        Apex_dico_df['Transiflo_flag'].append(StA.transiflo)
        Apex_dico_df['STOP_init_flag'].append(StA.STOP_init)
        Apex_dico_df['Transiflo_DOY'].append(dico_stades[StA.num_plante][StA.tiller]["Transiflo"][2])
        Apex_dico_df['Ln_final'].append(StA.Ln_final)
        produce Apex(StA)
        
  #Ecriture dans fichiers
  Apex_dico_df['Elapsed_time'].append(elapsed_time)
  Apex_dico_df['Temperature'].append(Temperature)
  Apex_dico_df['Temp_cum'].append(Tempcum)
  Apex_dico_df['Time_count'].append(StA.time)
  Apex_dico_df['Sum_temp'].append(StA.sumtemp)
  Apex_dico_df['Current_PAR'].append(current_PAR)
  Apex_dico_df['Num_plante'].append(StA.num_plante)
  Apex_dico_df['Genotype'].append(StA.geno)
  Apex_dico_df['Num_talle'].append(str(StA.tiller))
  Apex_dico_df['Num_cohorte'].append(cohort_number(StA.tiller))
  Apex_dico_df['Nb_phyto_emi'].append(StA.n)
  if Tempcum  >= Dse_heterogeneous[StA.num_plante]:
    Apex_dico_df['Nb_emerged_leaf'].append(max(leaf_emergence[StA.num_plante][StA.tiller].keys()))
  else:
    Apex_dico_df['Nb_emerged_leaf'].append(0)
  Apex_dico_df['Transiflo_flag'].append(StA.transiflo)
  Apex_dico_df['STOP_init_flag'].append(StA.STOP_init)
  Apex_dico_df['Transiflo_DOY'].append(dico_stades[StA.num_plante][StA.tiller]["Transiflo"][2])
  Apex_dico_df['Ln_final'].append(StA.Ln_final)


Apex_R(StAR):
  
  if StAR.tiller in axis_census[StAR.num_plante] and axis_census[StAR.num_plante][StAR.tiller]["Stop_growth_flag"] == True:
    pass
  else:
    StAR.sumtemp += max(Tbase,Temperature)
    
    #Passage � Montaison
    if StAR.mont == False:
      # TODO : pourquoi ces tests en deux etapes?
      if max(leaf_emergence[StAR.num_plante][StAR.tiller].keys()) >= StAR.Ln_final - 4:
        if Tempcum >= leaf_emerg_date(StAR.Ln_final - 4, StAR.tiller, StAR.geno, StAR.num_plante) + (ED_B + ED_S) * phyll_adjust(StAR.geno): #Test pour savoir si on est � montaison (ligulation de feuille n-4)
          
          # Identification des talles destin�es � mourir
          # TODO : regression � la josette masle, obsolete � enlever
          for axis in leaf_emergence[StAR.num_plante].keys():
            if max(leaf_emergence[StAR.num_plante][axis].keys()) < 4:    # Si le nombre de feuilles sur l'axe est inf�rieur � 3
              tiller_death[StAR.num_plante][dico_stades[StAR.num_plante][axis]["Age"]] = []
              
          for axis in leaf_emergence[StAR.num_plante].keys():
            if max(leaf_emergence[StAR.num_plante][axis].keys()) < 4:    # Si le nombre de feuilles sur l'axe est inf�rieur � 3
              tiller_death[StAR.num_plante][dico_stades[StAR.num_plante][axis]["Age"]].append(axis)
          
          #### Fin de suppression ####
          
          dico_stades[StAR.num_plante][StAR.tiller]["Montaison"] = (True,Tempcum, DOY)
          StAR.mont = True
        
    # Passage � �piaison
    if Tempcum >= dico_stades[StAR.num_plante][StAR.tiller]["Epiaison"][1] and StAR.epi == False:
      dico_stades[StAR.num_plante][StAR.tiller]["Epiaison"][0] = True
      dico_stades[StAR.num_plante][StAR.tiller]["Epiaison"][2] = DOY
      StAR.epi = True
    
    # Passage � floraison
    if Tempcum >= dico_stades[StAR.num_plante][StAR.tiller]["Flo"][1] and StAR.flo == False:
      dico_stades[StAR.num_plante][StAR.tiller]["Flo"][0] = True
      dico_stades[StAR.num_plante][StAR.tiller]["Flo"][2] = DOY
      StAR.flo = True
    
    #Passage � maturit�
    if Tempcum >= dico_stades[StAR.num_plante][StAR.tiller]["Maturite"][1] and StAR.mat == False:
      dico_stades[StAR.num_plante][StAR.tiller]["Maturite"][0] = True
      dico_stades[StAR.num_plante][StAR.tiller]["Maturite"][2] = DOY
      StAR.mat = True
      
    if write_output_file["Apex_R"]:
      Apex_R_dico_df['Elapsed_time'].append(elapsed_time)
      Apex_R_dico_df['DOY'].append(DOY)
      Apex_R_dico_df['Temperature'].append(Temperature)
      Apex_R_dico_df['Temp_cum'].append(Tempcum)
      Apex_R_dico_df['Sum_temp'].append(StAR.sumtemp)
      Apex_R_dico_df['Num_cohorte'].append(cohort_number(StAR.tiller))
      Apex_R_dico_df['Ln_final'].append(StAR.Ln_final)
      Apex_R_dico_df['Num_plante'].append(StAR.num_plante)
      Apex_R_dico_df['Genotype'].append(StAR.geno)
      Apex_R_dico_df['Num_talle'].append(StAR.tiller)
      Apex_R_dico_df['Mont_flag'].append(StAR.mont)
      Apex_R_dico_df['Mont_DOY'].append(dico_stades[StAR.num_plante][StAR.tiller]["Montaison"][2])
      Apex_R_dico_df['Flo_flag'].append(StAR.flo)
      Apex_R_dico_df['Flo_DOY'].append(dico_stades[StAR.num_plante][StAR.tiller]["Flo"][2])
      Apex_R_dico_df['Death_flag'].append(StAR.death_flag)
      Apex_R_dico_df['Date_epiaison'].append(dico_stades[StAR.num_plante][StAR.tiller]["Epiaison"][1])
      Apex_R_dico_df['Epi_DOY'].append(dico_stades[StAR.num_plante][StAR.tiller]["Epiaison"][2])
      Apex_R_dico_df['Date_de_flo'].append(dico_stades[StAR.num_plante][StAR.tiller]["Flo"][1])
      Apex_R_dico_df['Mat_DOY'].append(dico_stades[StAR.num_plante][StAR.tiller]["Maturite"][2])
      Apex_R_dico_df['Date_de_maturite'].append(dico_stades[StAR.num_plante][StAR.tiller]["Maturite"][1])
    produce Apex_R(StAR)

Bud_primord(StBu_p):
  if Tempcum >= Dse_heterogeneous[StBu_p.num_plante]:
    # Tant que l'axe n'a pas �t� d�sign� pour r�gresser, tout fonctionne normalement
    if StBu_p.tiller in axis_census[StBu_p.num_plante] and axis_census[StBu_p.num_plante][StBu_p.tiller]["Stop_growth_flag"] == True:
      pass
    else:
      StBu_p.sumtemp += max(Tbase, Temperature)
      if StBu_p.sumtemp >= Delta_b * Pls[StBu_p.geno] and StBu_p.competent_flag == False:
        StBu_p.competent_flag = True
        new_tiller_name = StBu_p.tiller + (StBu_p.n,)
        StBu = Bud(StBu_p.num_plante, StBu_p.geno, new_tiller_name, 0, StBu_p.sumtemp % Pls[StBu_p.geno]) #On discr�tise proprement l'accumulation des temp�ratures en transmettant le surplus de temp�rature stock�e � l'Bud n�oform�
        StBu.sumtemp = StBu_p.sumtemp % Pls[StBu_p.geno]
        StBu.time = StBu_p.sumtemp % Pls[StBu_p.geno]
        
        # Etape de formatage des dictionnaire (on cr�� un nouveau sous-dico avec le nouvel embanchement)
        #if StBu.n == 0:
        
        # Formatting dictionnaries
        ##
        date_emission[StBu.num_plante][new_tiller_name] = Tempcum
        Hcol_max[StBu.num_plante][new_tiller_name] = 0
        Hcol_dead[StBu.num_plante][new_tiller_name] = 0
        delta_H[StBu.num_plante][new_tiller_name] = 0
        tiller_surface[(StBu.num_plante,new_tiller_name)] = 0.0
        leaf_emergence[StBu.num_plante][StBu.tiller] = {1: (0,0)}
        
        hazard_dict_organ[StBu.num_plante][new_tiller_name] = {}
        hazard_dict_axis[StBu.num_plante][new_tiller_name] = {}
        hazard_dict_axis[StBu.num_plante][new_tiller_name]["tiller_azimuth"] = Phi_azi_T + random.uniform(-till_azi_hazard, till_azi_hazard)
        hazard_dict_axis[StBu.num_plante][new_tiller_name]["tiller_zenith"] = Phi_zen_T + random.uniform(-till_zen_hazard, till_zen_hazard)
        
        dico_cut_dead_blades[StBu.num_plante][new_tiller_name] = []
        
        dico_stades[StBu.num_plante][new_tiller_name] = {"Age" : 0 ,"Blade_Transiflo" : False, "Transiflo" : [False,10000,0], "Montaison" : [False,10000,0],"Ear_emergence" : False, "Epiaison" : [False,10000,0], "Flo" : [False,10000,0], "Maturite" : [False,10000,0], "Ln_final":"undefined", "End_internode_elongation" : False, "Senescence_flag_leaf" : [False, 10000, 0]}
        
        ## Phytomer scaled dictionnaries
        current_internode_length[StBu.num_plante][StBu.tiller] = {}
        Sh_max[StBu.num_plante][StBu.tiller] = {0: 0.0}
        final_blade_length[StBu.num_plante][StBu.tiller] = {}
        current_sheath_length[StBu.num_plante][StBu.tiller] = {0: l_c}
        dead_sheath_length[StBu.num_plante][StBu.tiller] = {0:0.0}
        
        leaf_emergence[StBu.num_plante][StBu.tiller] = {1: (0,0)}
        
        ### END OF DICTIONNARIES FORMATAGE ###
        
        StCPB = CutPointBud(StBu.num_plante, StBu.geno, StBu.tiller)
        StCPB.tiller = StBu.tiller
        StCPB.tiller_zen = hazard_dict_axis[StCPB.num_plante][StCPB.tiller]["tiller_zenith"]
        dico_cut_fantom_axes[StBu.num_plante][StBu.tiller] = False
        produce CutPointBud(StCPB)[Bud(StBu)]

Bud(StBu):
  
  # Tout est inactif jusqu'� l'�mergence de la premi�re feuille de la plante
  if Tempcum >= Dse_heterogeneous[StBu.num_plante]:
    # Tant que l'axe n'a pas �t� d�sign� pour r�gresser, tout fonctionne normalement
    if StBu.tiller in axis_census[StBu.num_plante] and axis_census[StBu.num_plante][StBu.tiller]["Stop_growth_flag"] == True:
      pass
    else:
      StBu.sumtemp += max(Tbase,Temperature)
      StBu.nb_j += time_step
      StBu.age += max(Tbase,Temperature)
      StBu.time += max(Tbase,Temperature)
      
      #Transition florale du bourgeon
      if Tempcum >= dico_stades[StBu.num_plante][StBu.tiller]["Transiflo"][1] and StBu.transiflo == False:
        StBu.transiflo = True
        dico_stades[StBu.num_plante][StBu.tiller]["Transiflo"][0] = True
        dico_stades[StBu.num_plante][StBu.tiller]["Transiflo"][2] = DOY
        StBuR = Bud_R(StBu.num_plante, StBu.geno, StBu.tiller, StBu.n)
        StBuR.nb_j = StBu.nb_j
        StBuR.sumtemp = StBu.sumtemp # TODO on aurait pu le concat�ner en une ligne
        StBu.Ln_final = StBu.n
        StBuR.Ln_final = StBu.Ln_final
        StBuR.emerg = StBu.emerg  # .emerg est un bool�en
        
        # Calcul et stockage des dates de stade
        dico_stades[StBu.num_plante][StBu.tiller]["Ln_final"] = StBu.Ln_final
        StBuR.date_de_flo = leaf_emerg_date((StBu.Ln_final), StBu.tiller, StBu.geno, StBu.num_plante) + (ED_FB + ED_S + Delta_lflf) * phyll_adjust(StBu.geno)
        dico_stades[StBu.num_plante][StBu.tiller]["Flo"][1] = StBuR.date_de_flo
        StBuR.date_epi = StBuR.date_de_flo - (Delta_hf * phyll_adjust(StBuR.geno))
        dico_stades[StBu.num_plante][StBu.tiller]["Epiaison"][1] = StBuR.date_epi
        StE = Ear(StBu.num_plante, StBu.geno, StBu.tiller, StBu.n)
        StP = Peduncle(StBu.num_plante, StBu.geno, StBu.tiller, StBu.n)
        StP.final_length = L_P[StP.geno]
        produce Peduncle(StP)Ear(StE)Bud_R(StBuR)
        
      # Producting vegetative phytomers
      if StBu.time > Pls[StBu.geno] and StBu.transiflo == False:
        if GAI_prox[StBu.num_plante] <= GAI_c[StBu.geno] and cohort_number(StBu.tiller) < cohorte_max:
          StL = Leaf(StBu.num_plante, StBu.geno, StBu.tiller, StBu.n + 1)
          StBu_p = Bud_primord(StBu.num_plante, StBu.geno, StBu.tiller, StBu.n + 1)
          StBu_p.sumtemp = StBu.time % Pls[StBu.geno]
          StI = Internode(StBu.num_plante, StBu.geno, StBu.tiller, StBu.n + 1)
          StBu.time = StBu.time % Pls[StBu.geno]
          StL.date_emerg = leaf_emerg_date(StL.n, StL.tiller, StL.geno, StL.num_plante)
          
          # Formatting phytomer scaled dictionnaries
          current_internode_length[StL.num_plante][StL.tiller][StL.n] = 0
          Sh_max[StL.num_plante][StL.tiller][StL.n] = 0.0
          final_blade_length[StL.num_plante][StL.tiller][StL.n] = 0
          current_sheath_length[StL.num_plante][StL.tiller][StL.n] = 0
          dead_sheath_length[StL.num_plante][StL.tiller][StL.n] = 0
          
          hazard_dict_organ[StL.num_plante][StL.tiller][StL.n] = {}
          hazard_dict_organ[StL.num_plante][StL.tiller][StL.n]["blade_inclination"] = Phi_zen_B[StL.geno] + random.uniform(-blade_incl_hazard, blade_incl_hazard)
          hazard_dict_organ[StL.num_plante][StL.tiller][StL.n]["blade_azimuth"] = Phi_azi_B + random.uniform(-blade_azi_hazard, blade_azi_hazard)
          
          ### End of dictionnaries formatting ###
          
          blade_phyllotaxy(StL.n, StL.tiller, StL.num_plante, N_I_el[StL.geno], Phi_azi_B, blade_azi_hazard)
          
          StI.azimuth = hazard_dict_organ[StL.num_plante][StL.tiller][StL.n]["blade_azimuth"]
          nproduce [Bud_primord(StBu_p)]Internode(StI)[Leaf(StL)]
          StBu.n += 1
        
        else:
          dico_cut_fantom_axes[StBu.num_plante][StBu.tiller] = True  
        
        #C'est aussi le moment de potentiellement �merger
        if Tempcum >= leaf_emerg_date(StBu.tiller[len(StBu.tiller)-1] + 2,StBu.tiller[0:len(StBu.tiller)-1] , StBu.geno, StBu.num_plante) and StBu.emerg == False: #TODO am�liorer la m�thode de calcul comme dans la fonction de synchrone correspondance (n=StBu.tiller[-1], )
          StBu.emerg = True
          StBu.Tmoy = StBu.sumtemp / StBu.nb_j #TODO : OBSOLETE
          
          #if StBu.tiller in liste_talles:
            #StBu.p_debourr = 1
          #else:
            #StBu.p_debourr = 0
          
          # TODO c'est quand m�me sale...
          if type(dico_stades[StBu.num_plante][StBu.tiller]["Ln_final"]) != int:
            StBu.p_debourr = proba_debourr(StBu.tiller, GAI_prox[StBu.num_plante], StBu.geno, StBu.tiller[-1], 100)
          else:
            StBu.p_debourr = proba_debourr(StBu.tiller, GAI_prox[StBu.num_plante], StBu.geno, StBu.tiller[-1], dico_stades[StBu.num_plante][StBu.tiller[0:len(StBu.tiller)-1]]["Ln_final"]) #On consulte le nombre final de feuilles de la talle m�re
          
          # Enregistrement des informations
          if write_output_file["Proba"]:
            Proba_dico_df["Elapsed_time"].append(elapsed_time)
            Proba_dico_df["Temperature"].append(Temperature)
            Proba_dico_df["Temp_cum"].append(Tempcum)
            Proba_dico_df["Num_plante"].append(StBu.num_plante)
            Proba_dico_df["Genotype"].append(StBu.geno)
            Proba_dico_df["Num_talle"].append(str(StBu.tiller[0:len(StBu.tiller)-1]))
            Proba_dico_df["Num_rang"].append(StBu.tiller[-1])
            Proba_dico_df["Sumtemp"].append(StBu.sumtemp)
            Proba_dico_df["GAI_prox"].append(GAI_prox[StBu.num_plante])
            Proba_dico_df["P_debourr"].append(StBu.p_debourr)
          
          if random.random() <= StBu.p_debourr:
            # Formatting dictionnaries
            ## Dictionnaries including datas about emerged organs
            ### Axis scale dictionnaries
            first_leaf_phase2[StBu.num_plante][StBu.tiller] = {"num_first_leaf_phase_2" : 0, "length_first_leaf_phase_2" : 0}
            LNfinal[StBu.num_plante][StBu.tiller] = 0
            
            axis_census[StBu.num_plante][StBu.tiller] = {"emerg_date" : Tempcum, "Stop_growth_flag" : False, "Regression_flag" : False}
            
            dico_PAR["Blade"][StBu.num_plante][StBu.tiller] = {}
            dico_PAR["Internode"][StBu.num_plante][StBu.tiller] = {}
            dico_PAR["Sheath"][StBu.num_plante][StBu.tiller] = {}
            dico_PAR["Peduncle"][StBu.num_plante][StBu.tiller] = {}
            dico_PAR["Ear"][StBu.num_plante][StBu.tiller] = {}
            dico_PAR_per_axis[StBu.num_plante][StBu.tiller] = {}
            
            ### End of dictionnaries formatting ###
            StA = Apex(StBu.num_plante, StBu.geno,StBu.tiller,StBu.n,StBu.time)
            StA.nb_emerg_leaves = StBu.nb_emerg_leaves # TODO : pourquoi ?
            #StA.tiller_incl = StBu.tiller_incl
            StA.date_sortie = Tempcum
            StA.time = StBu.time
            nproduce Apex(StA)
          else:
            dico_cut_fantom_axes[StBu.num_plante][StBu.tiller] = True
            
            #TODO habituellement, on ne met pas � jour la cha�ne, � virer?
            nproduce Bud(StBu)
        else:
          nproduce Bud(StBu)
        
      else:
        # Si c'est le moment d'emerger
        if Tempcum >= leaf_emerg_date(StBu.tiller[len(StBu.tiller)-1] + 2,StBu.tiller[0:len(StBu.tiller)-1] , StBu.geno, StBu.num_plante) and StBu.emerg == False:
          StBu.emerg = True
          StBu.Tmoy = StBu.sumtemp / StBu.nb_j #TODO : inutile
          #if StBu.tiller in liste_talles:
            #StBu.p_debourr = 1
          #else:
            #StBu.p_debourr = 0
          if type(dico_stades[StBu.num_plante][StBu.tiller]["Ln_final"]) != int:
            StBu.p_debourr = proba_debourr(StBu.tiller, GAI_prox[StBu.num_plante], StBu.geno, StBu.tiller[-1], 100)
          else:
            StBu.p_debourr = proba_debourr(StBu.tiller, GAI_prox[StBu.num_plante], StBu.geno, StBu.tiller[-1], dico_stades[StBu.num_plante][StBu.tiller[0:len(StBu.tiller)-1]]["Ln_final"]) #On consulte le nombre final de feuilles de la talle m�re
          # Enregistrement des informations
          if write_output_file["Proba"]:
            Proba_dico_df["Elapsed_time"].append(elapsed_time)
            Proba_dico_df["Temperature"].append(Temperature)
            Proba_dico_df["Temp_cum"].append(Tempcum)
            Proba_dico_df["Num_plante"].append(StBu.num_plante)
            Proba_dico_df["Genotype"].append(StBu.geno)
            Proba_dico_df["Num_talle"].append(str(StBu.tiller[0:len(StBu.tiller)-1]))
            Proba_dico_df["Num_rang"].append(StBu.tiller[-1])
            Proba_dico_df["Sumtemp"].append(StBu.sumtemp)
            Proba_dico_df["GAI_prox"].append(GAI_prox[StBu.num_plante])
            Proba_dico_df["P_debourr"].append(StBu.p_debourr)
            
          if random.random() <= StBu.p_debourr:
            # Formatting dictionnaries
            ## Dictionnaries including datas about emerged organs
            ### Axis scale dictionnaries
            first_leaf_phase2[StBu.num_plante][StBu.tiller] = {"num_first_leaf_phase_2" : 0, "length_first_leaf_phase_2" : 0}
            LNfinal[StBu.num_plante][StBu.tiller] = 0
            
            axis_census[StBu.num_plante][StBu.tiller] = {"emerg_date" : Tempcum, "Stop_growth_flag" : False, "Regression_flag" : False}
            
            dico_PAR["Blade"][StBu.num_plante][StBu.tiller] = {}
            dico_PAR["Internode"][StBu.num_plante][StBu.tiller] = {}
            dico_PAR["Sheath"][StBu.num_plante][StBu.tiller] = {}
            dico_PAR["Peduncle"][StBu.num_plante][StBu.tiller] = {}
            dico_PAR["Ear"][StBu.num_plante][StBu.tiller] = {}
            dico_PAR_per_axis[StBu.num_plante][StBu.tiller] = {}
            
            ### End of dictionnaries formatting ###
            StA = Apex(StBu.num_plante, StBu.geno,StBu.tiller,StBu.n,StBu.time)
            StA.time = StBu.time
            StA.nb_emerg_leaves = StBu.nb_emerg_leaves
            #StA.tiller_incl = StBu.tiller_incl
            StA.date_sortie = Tempcum
            nproduce Apex(StA)
          else:
            dico_cut_fantom_axes[StBu.num_plante][StBu.tiller] = True
            nproduce Bud(StBu)
        else:
          nproduce Bud(StBu)


Bud_R(StBuR):
  # Tant que l'axe n'a pas �t� d�sign� pour r�gresser, tout fonctionne normalement
  if StBuR.tiller in axis_census[StBuR.num_plante] and axis_census[StBuR.num_plante][StBuR.tiller]["Stop_growth_flag"] == True:
    pass
  else:
    StBuR.sumtemp += max(Tbase,Temperature)
    
    # C'est le moment o� le bourgeon a la possibilit� d'�merger
    if Tempcum >= leaf_emerg_date(StBuR.tiller[len(StBuR.tiller)-1] + 2,StBuR.tiller[0:len(StBuR.tiller)-1] , StBuR.geno, StBuR.num_plante) and StBuR.emerg == False:
      StBuR.emerg = True
      StBuR.Tmoy = StBuR.sumtemp / StBuR.nb_j # TODO inutile
      #if StBuR.tiller in liste_talles:
        #StBuR.p_debourr = 1
      #else:
        #StBuR.p_debourr = 0
      if type(dico_stades[StBuR.num_plante][StBuR.tiller]["Ln_final"]) != int:
        StBuR.p_debourr = proba_debourr(StBuR.tiller, GAI_prox[StBuR.num_plante], StBuR.geno, StBuR.tiller[-1], 100)
      else:
        StBuR.p_debourr = proba_debourr(StBuR.tiller, GAI_prox[StBuR.num_plante], StBuR.geno, StBuR.tiller[-1], dico_stades[StBuR.num_plante][StBuR.tiller[0:len(StBuR.tiller)-1]]["Ln_final"]) #On consulte le nombre final de feuilles de la talle m�re
      
      # Enregistrement des informations
      if write_output_file["Proba"]:
        Proba_dico_df["Elapsed_time"].append(elapsed_time)
        Proba_dico_df["Temperature"].append(Temperature)
        Proba_dico_df["Temp_cum"].append(Tempcum)
        Proba_dico_df["Num_plante"].append(StBuR.num_plante)
        Proba_dico_df["Genotype"].append(StBuR.geno)
        Proba_dico_df["Num_talle"].append(str(StBuR.tiller[0:len(StBuR.tiller)-1]))
        Proba_dico_df["Num_rang"].append(StBuR.tiller[-1])
        Proba_dico_df["Sumtemp"].append(StBuR.sumtemp)
        Proba_dico_df["GAI_prox"].append(GAI_prox[StBuR.num_plante])
        Proba_dico_df["P_debourr"].append(StBuR.p_debourr)
        
      # Si le bourgeon �merge
      if random.random() <= StBuR.p_debourr:
        # Formatting dictionnaries
        ## Dictionnaries including datas about emerged organs
        ### Axis scale dictionnaries
        first_leaf_phase2[StBuR.num_plante][StBuR.tiller] = {"num_first_leaf_phase_2" : 0, "length_first_leaf_phase_2" : 0}
        LNfinal[StBuR.num_plante][StBuR.tiller] = 0
        
        axis_census[StBuR.num_plante][StBuR.tiller] = {"emerg_date" : Tempcum, "Stop_growth_flag" : False, "Regression_flag" : False}
        
        dico_PAR["Blade"][StBuR.num_plante][StBuR.tiller] = {}
        dico_PAR["Internode"][StBuR.num_plante][StBuR.tiller] = {}
        dico_PAR["Sheath"][StBuR.num_plante][StBuR.tiller] = {}
        dico_PAR["Peduncle"][StBuR.num_plante][StBuR.tiller] = {}
        dico_PAR["Ear"][StBuR.num_plante][StBuR.tiller] = {}
        dico_PAR_per_axis[StBuR.num_plante][StBuR.tiller] = {}
        dico_cut_dead_blades[StBuR.num_plante][StBuR.tiller] = []
        
        ### End of dictionnaries formatting ###
        
        # The previously produced ear emerges
        dico_stades[StBuR.num_plante][StBuR.tiller]["Ear_emergence"] = True
        StP = Peduncle(StBuR.num_plante, StBuR.geno, StBuR.tiller, StBuR.n)
        StAR = Apex_R(StBuR.num_plante, StBuR.geno, StBuR.tiller, StBuR.n)
        StAR.Ln_final = StBuR.Ln_final
        dico_stades[StBuR.num_plante][StBuR.tiller]["Ln_final"] = StBuR.Ln_final
        StAR.date_epi = dico_stades[StBuR.num_plante][StBuR.tiller]["Epiaison"][1]
        StAR.date_de_flo = dico_stades[StBuR.num_plante][StBuR.tiller]["Flo"][1]
        StAR.date_mat = dico_stades[StBuR.num_plante][StBuR.tiller]["Maturite"][1]
        produce Apex_R(StAR)
      else:
        dico_cut_fantom_axes[StBuR.num_plante][StBuR.tiller] = True
      
    else:
      produce Bud_R(StBuR)

CutPointBud(StCPB):
  
  ### On Coupe toutes les structures produites par un Bud qui n'�mergera jamais!
  #D�s qu'on franchit le GAIcritique, on coupe toutes les structures qui n'ont pas �merg�e
  if GAI_prox[StCPB.num_plante] >= GAI_c[StCPB.geno] and StCPB.tiller not in axis_census[StCPB.num_plante]:
    dico_cut_fantom_axes[StCPB.num_plante][StCPB.tiller] = True
  if StCPB.tiller != (1,):
    if dico_cut_fantom_axes[StCPB.num_plante][StCPB.tiller] == True:
      produce % CutPointBud(StCPB)
  
  ### On coupe les structures pr�sentes sur les talles qui r�gressent par manque de rayonnement
  if Tempcum > leaf_emerg_date(t_beg_reg[StCPB.geno], (1,), genotype_map[StCPB.num_plante], StCPB.num_plante) + 1.6*phyll_adjust(StCPB.geno):
    #Gestion de la mort des talles
    if StCPB.tiller in axis_census[StCPB.num_plante].keys():
      if axis_census[StCPB.num_plante][StCPB.tiller]['Stop_growth_flag'] == True:
        StCPB.reg_count += Temperature
        #TODO : enlever une �tape
        if Delta_SGtC > StCPB.reg_count > Delta_SGtR:
          axis_census[StCPB.num_plante][StCPB.tiller]['Regression_flag'] = True
        elif StCPB.reg_count > Delta_SGtC:
          #print StCPB.num_plante, "i will cut this mozeurfockeur : ", StCPB.tiller
          del axis_census[StCPB.num_plante][StCPB.tiller]
          produce % CutPointBud(StCPB)

Leaf(StL):
  if Tempcum >= Dse_heterogeneous[StL.num_plante]:
    # Tant que l'axe n'a pas �t� d�sign� pour r�gresser, tout fonctionne normalement
    if StL.tiller in axis_census[StL.num_plante] and axis_census[StL.num_plante][StL.tiller]["Stop_growth_flag"] == True:
      pass
    else:
      StL.sumtemp += max(Tbase,Temperature)
      StL.age += time_step
      if Tempcum >= StL.date_emerg:
        leaf_emergence[StL.num_plante][StL.tiller][StL.n] = (Tempcum,StL.sumtemp)
        StBl = Blade(StL.num_plante, StL.geno, StL.tiller, StL.n)
        StBl.tiller = StL.tiller # TODO inutile?
        StS = Sheath(StL.num_plante, StL.geno, StL.tiller, StL.n)  # On consid�re qu'� ce moment la longueur gaine est initialis�e � 0
        StS.tiller = StL.tiller  # TODO inutile?
        
        #Calcul de la taille finale que va avoir le limbe
        if StBl.n == 1:
          StBl.final_length = L_B_1[StBl.geno]
          StBl.width = blade_width(StBl.final_length, a_B_w[StBl.geno], b_B_w[StBl.geno])
          StS.final_length = sheath_length(StBl.final_length, a_S_L[StS.geno], b_S_L[StS.geno])
        else:
          previous_length = final_blade_length[StBl.num_plante][StBl.tiller][StBl.n-1]
          
          #La transition florale n'est pas pass�e
          if dico_stades[StBl.num_plante][StBl.tiller]["Transiflo"][0] == False:
            StBl.final_length = previous_length + s_B_1[geno]
            StBl.width = blade_width(StBl.final_length, a_B_w[StBl.geno], b_B_w[StBl.geno])
            StS.final_length = sheath_length(StBl.final_length, a_S_L[StS.geno], b_S_L[StS.geno])
            
          #La transition florale est pass�e !
          else:
            if dico_stades[StBl.num_plante][StBl.tiller]["Blade_Transiflo"] == False:
              first_leaf_phase2[StBl.num_plante][StBl.tiller]["num_first_leaf_phase_2"] =  StBl.n -1
              first_leaf_phase2[StBl.num_plante][StBl.tiller]["length_first_leaf_phase_2"] = final_blade_length[StBl.num_plante][StBl.tiller][StBl.n-1]
              StBl.final_length = previous_length + incr_repro_penlt_leaf(first_leaf_phase2[StBl.num_plante][StBl.tiller]["length_first_leaf_phase_2"], L_B_max[StBl.geno], (dico_stades[StL.num_plante][StL.tiller]["Ln_final"] - N_B_r[StBl.geno]) - first_leaf_phase2[StBl.num_plante][StBl.tiller]["num_first_leaf_phase_2"])
              StBl.width = blade_width(StBl.final_length, a_B_w[StBl.geno], b_B_w[StBl.geno])
              StS.final_length = sheath_length(StBl.final_length, a_S_L[StS.geno], b_S_L[StS.geno])
              dico_stades[StBl.num_plante][StBl.tiller]["Blade_Transiflo"] = True
            else:
              if StBl.n in range(dico_stades[StBl.num_plante][StBl.tiller]["Ln_final"] - N_B_r[StBl.geno] + 1, dico_stades[StBl.num_plante][StBl.tiller]["Ln_final"]+1):
                StBl.final_length = flag_leaf_blade_length(StBl.geno,final_blade_length[StBl.num_plante][StBl.tiller][StBl.n-1] , s_B_f[StBl.geno])
                #StBl.width = blade_width(StBl.final_length)
                nmax = dico_stades[StBl.num_plante][StBl.tiller]["Ln_final"] - N_B_r[StBl.geno]
                StBl.width = blade_width(L_B_max[StBl.geno] + (StBl.n - nmax) * incr_repro_penlt_leaf(first_leaf_phase2[StBl.num_plante][StBl.tiller]["length_first_leaf_phase_2"], L_B_max[StBl.geno], (dico_stades[StL.num_plante][StL.tiller]["Ln_final"] - N_B_r[StBl.geno]) - first_leaf_phase2[StBl.num_plante][StBl.tiller]["num_first_leaf_phase_2"]), a_B_w[StBl.geno], b_B_w[StBl.geno])
                StS.final_length = sheath_length(L_B_max[StBl.geno] + (StS.n - nmax) * incr_repro_penlt_leaf(first_leaf_phase2[StBl.num_plante][StBl.tiller]["length_first_leaf_phase_2"], L_B_max[StBl.geno], (dico_stades[StL.num_plante][StL.tiller]["Ln_final"] - N_B_r[StBl.geno]) - first_leaf_phase2[StBl.num_plante][StBl.tiller]["num_first_leaf_phase_2"]), a_S_L[StS.geno], b_S_L[StS.geno])
              else:
                StBl.final_length = previous_length + incr_repro_penlt_leaf(first_leaf_phase2[StBl.num_plante][StBl.tiller]["length_first_leaf_phase_2"], L_B_max[StBl.geno], (dico_stades[StL.num_plante][StL.tiller]["Ln_final"] - N_B_r[StBl.geno]) - first_leaf_phase2[StBl.num_plante][StBl.tiller]["num_first_leaf_phase_2"])
                StBl.width = blade_width(StBl.final_length, a_B_w[StBl.geno], b_B_w[StBl.geno])
                StS.final_length = sheath_length(StBl.final_length, a_S_L[StS.geno], b_S_L[StS.geno])
        final_blade_length[StBl.num_plante][StBl.tiller][StBl.n] = StBl.final_length
        
        #Initialisation de la longueur
        ## L'axe en question n'a pas encore de gaine
        if StBl.n <= 2:
          ## Sur le brin-ma�tre la longueur du limbe est initialis�e � la longueur du coleoptile
          if StBl.tiller == (1,):
            StBl.length = l_c
            StS.length = 0.0
          ## Sur les talles, la longueur du limbe est initialis�e � la longueur de la plus longue gaine pr�sente sur l'axe parent
          else:
            StBl.length = max([current_sheath_length[StBl.num_plante][StBl.tiller[0:len(StBl.tiller)-1]][x] for x in range(1, StBl.n + 4)])
            StS.length = 0.0
        elif current_sheath_length[StL.num_plante][StL.tiller][StL.n-2] > StBl.final_length:
          StBl.length = StBl.final_length
          StS.length = current_sheath_length[StL.num_plante][StL.tiller][StL.n-2] - StBl.final_length
        #cas classique : la longueur du limbe est initialis�e � la longueur de la gaine n-2 (qui vient de finir sa croissance)
        else:
          StBl.length = current_sheath_length[StL.num_plante][StL.tiller][StL.n-2]  #On recherche la gaine la plus longue sur toute la talle
          StS.length = 0.0
        
        #Calcul de la vitesse de croissance du limbe et de la gaine
        if StBl.n == dico_stades[StBl.num_plante][StBl.tiller]["Ln_final"]:
          StBl.gr_blade = (StBl.final_length - StBl.length) / (phyll_adjust(StL.geno) * ED_FB)
        else:
          StBl.gr_blade = (StBl.final_length - StBl.length) / (phyll_adjust(StL.geno) * ED_B)      
        
        StS.gr_sheath = StS.final_length / (ED_S * phyll_adjust(StL.geno)) #TODO correction
        
        #Ajout du point de coupe pour repr�senter la s�nescence des limbes
        StCPBl = CutPointBlade(StL.num_plante, StL.geno, StL.tiller, StL.n)
        produce Sheath(StS)CutPointBlade(StCPBl)Blade(StBl)
      else:
        produce Leaf(StL)

CutPointBlade(StCPBl):
  if type(dico_stades[StCPBl.num_plante][StCPBl.tiller]["Ln_final"]) == str:
    if StCPBl.n in dico_cut_dead_blades[StCPBl.num_plante][StCPBl.tiller]:
      produce % CutPointBlade(StCPBl)
  elif type(dico_stades[StCPBl.num_plante][StCPBl.tiller]["Ln_final"]) == int:
    if StCPBl.n <= dico_stades[StCPBl.num_plante][StCPBl.tiller]["Ln_final"] - N_I_el[StCPBl.geno]:
      if StCPBl.n in dico_cut_dead_blades[StCPBl.num_plante][StCPBl.tiller]:
        produce % CutPointBlade(StCPBl)

Blade(StBl):
  
  if Tempcum >= Dse_heterogeneous[StBl.num_plante]:
    # Tant que l'axe n'a pas �t� d�sign� pour r�gresser, tout fonctionne normalement
    if StBl.tiller in axis_census[StBl.num_plante] and axis_census[StBl.num_plante][StBl.tiller]["Stop_growth_flag"] == True:
      pass
      if StBl.tiller in axis_census[StBl.num_plante].keys() and axis_census[StBl.num_plante][StBl.tiller]['Regression_flag'] == False:
        StBl.reverse_incr = StBl.visible_length/Delta_Reg
      elif StBl.tiller in axis_census[StBl.num_plante].keys() and axis_census[StBl.num_plante][StBl.tiller]['Regression_flag'] == True:
        StBl.reg_count += max(0,Temperature)
        if StBl.reg_count <= Delta_Reg:
          StBl.visible_length -= StBl.reverse_incr * max(0,Temperature)
    
    else:
      StBl.sumtemp += max(Tbase,Temperature) #lui mettre un nom (a max) et r�utiliser
      StBl.age += time_step
      
      if StBl.sumtemp/phyll_adjust(StBl.geno) <= ED_B:
        StBl.length += min(max(Tbase,StBl.gr_blade * Temperature),StBl.final_length - StBl.length) #gr_blade * max(T_base, Temperature)
      else:
        StBl.length = StBl.final_length   ##TODO superflu ?
      
    #Si on a pas fait la transiflo encore
    if dico_stades[StBl.num_plante][StBl.tiller]["Ln_final"] == "undefined":
      if Tempcum >= date_senescence_fake(StBl.n, t0_sen[StBl.geno]) and StBl.photosynthetic == True:
        StBl.photosynthetic = False
        dico_cut_dead_blades[StBl.num_plante][StBl.tiller].append(StBl.n)
    else:
      if StBl.tiller == (1,):
        if Tempcum >= leaves_senesc_date_main_stem(StBl.n, dico_stades[StBl.num_plante][StBl.tiller]["Ln_final"], phyll_adjust(StBl.geno), n0_sen[StBl.geno], n1_sen[StBl.geno], n3_sen[StBl.geno], t1_sen[StBl.geno], t3_sen[StBl.geno], Dse_heterogeneous[StBl.num_plante], DelayTipToHS[StBl.geno]) and StBl.photosynthetic == True:
          StBl.photosynthetic = False
          dico_cut_dead_blades[StBl.num_plante][StBl.tiller].append(StBl.n)
          if StBl.n == dico_stades[StBl.num_plante][StBl.tiller]["Ln_final"]:
            dico_stades[StBl.num_plante][StBl.tiller]["Senescence_flag_leaf"][0] = True
            dico_stades[StBl.num_plante][StBl.tiller]["Senescence_flag_leaf"][1] = Tempcum
      else:
        if Tempcum >= leaves_senesc_date_tiller(StBl.n, StBl.tiller, dico_stades[StBl.num_plante][StBl.tiller]["Ln_final"], phyll_adjust(StBl.geno), n0_sen[StBl.geno], n1_sen[StBl.geno], n2_sen[StBl.geno], n3_sen[StBl.geno], t1_sen[StBl.geno], t2_sen[StBl.geno], t3_sen[StBl.geno], Dse_heterogeneous[StBl.num_plante], DelayTipToHS[StBl.geno]) and StBl.photosynthetic == True:
          StBl.photosynthetic = False
          dico_cut_dead_blades[StBl.num_plante][StBl.tiller].append(StBl.n)
          if StBl.n == dico_stades[StBl.num_plante][StBl.tiller]["Ln_final"]:
            dico_stades[StBl.num_plante][StBl.tiller]["Senescence_flag_leaf"][0] = True
            dico_stades[StBl.num_plante][StBl.tiller]["Senescence_flag_leaf"][1] = Tempcum
    
    StBl.area = (StBl.width * StBl.length * 0.75)
    StBl.visible_length = (StBl.length + current_sheath_length[StBl.num_plante][StBl.tiller][StBl.n]) - (Sh_max[StBl.num_plante][StBl.tiller][StBl.n]) #TODO a optimiser par incr�mentation
    StBl.visible_area = visible_area(StBl.visible_length, StBl.width, StBl.final_length) #TODO a optimiser par incr�mentation
    
    if write_output_file["Blade"]:
      Blade_dico_df['Elapsed_time'].append(elapsed_time)
      Blade_dico_df['Temp_cum'].append(Tempcum)
      Blade_dico_df['Temperature'].append(Temperature)
      Blade_dico_df['Num_plante'].append(StBl.num_plante)
      Blade_dico_df['Genotype'].append(StBl.geno )
      Blade_dico_df['Num_talle'].append(str(StBl.tiller))
      Blade_dico_df['Num_cohorte'].append(cohort_number(StBl.tiller))
      Blade_dico_df['Num_rang'].append(StBl.n)
      Blade_dico_df['Blade_sumtemp'].append(leaf_emergence[StBl.num_plante][StBl.tiller][StBl.n][1])
      Blade_dico_df['Blade_width'].append(StBl.width)
      Blade_dico_df['Blade_length'].append(StBl.length)
      Blade_dico_df['Blade_visible_length'].append(StBl.visible_length)
      Blade_dico_df['Blade_final_length'].append(StBl.final_length)
      Blade_dico_df['Blade_visible_surface'].append(StBl.visible_area)
      Blade_dico_df['Blade_surface'].append((StBl.width*StBl.length*0.75))
      Blade_dico_df['Blade_PAR'].append(StBl.PAR)
      Blade_dico_df['Senesc_flag'].append(StBl.senesc_flag)
      Blade_dico_df['Photosynthetic'].append(StBl.photosynthetic)
    
    produce Blade(StBl)


Sheath(StS):
  StS.diameter = d_S[StS.geno]
  
  if Tempcum >= Dse_heterogeneous[StS.num_plante]:
    # Tant que l'axe n'a pas �t� d�sign� pour r�gresser, tout fonctionne normalement
    if StS.tiller in axis_census[StS.num_plante] and axis_census[StS.num_plante][StS.tiller]["Stop_growth_flag"] == True:
      pass
    else:
      StS.sumtemp += max(Tbase,Temperature)
      StS.age += time_step
      if StS.sumtemp/phyll_adjust(StS.geno) > ED_B and StS.sumtemp/phyll_adjust(StS.geno) < ED_B + ED_S: # Le limbe a fini sa croissance mais pas la gaine
        #StS.length += max(Tbase,StS.gr_sheath * Temperature)
        StS.length += min(max(Tbase,StS.gr_sheath * Temperature),StS.final_length - StS.length)
      elif StS.sumtemp/phyll_adjust(StS.geno) >  ED_B + ED_S:
        StS.length = StS.final_length
      current_sheath_length[StS.num_plante][StS.tiller][StS.n] = StS.length
      
    if dico_stades[StS.num_plante][StS.tiller]["Ln_final"] == "undefined":
      if Tempcum >= date_senescence_fake(StS.n + 1, t0_sen[StS.geno]) and StS.photosynthetic == True:
        StS.photosynthetic = False
        dead_sheath_length[StS.num_plante][StS.tiller][StS.n] = StS.length
          
    else:
      #Senescence of sheaths
      if StS.tiller == (1,):
        if Tempcum >= leaves_senesc_date_main_stem(min(StS.n +1, dico_stades[StS.num_plante][StS.tiller]["Ln_final"]), dico_stades[StS.num_plante][StS.tiller]["Ln_final"], phyll_adjust(StS.geno), n0_sen[StS.geno], n1_sen[StS.geno], n3_sen[StS.geno], t1_sen[StS.geno], t3_sen[StS.geno], Dse_heterogeneous[StS.num_plante], DelayTipToHS[StS.geno]) and StS.photosynthetic == True:
          StS.photosynthetic = False
          dead_sheath_length[StS.num_plante][StS.tiller][StS.n] = StS.length
      else:
        if Tempcum >= leaves_senesc_date_tiller(min(StS.n +1, dico_stades[StS.num_plante][StS.tiller]["Ln_final"]), StS.tiller, dico_stades[StS.num_plante][StS.tiller]["Ln_final"], Phl[StS.geno], n0_sen[StS.geno], n1_sen[StS.geno], n2_sen[StS.geno], n3_sen[StS.geno], t1_sen[StS.geno], t2_sen[StS.geno], t3_sen[StS.geno], Dse_heterogeneous[StS.num_plante], DelayTipToHS[StS.geno]) and StS.photosynthetic == True:
          StS.photosynthetic = False
          dead_sheath_length[StS.num_plante][StS.tiller][StS.n] = StS.length
    
    #Estimate the max length of sheath (between previous of the axis and on the parent axis)
    if StS.tiller == (1,):
      Sh_max[StS.num_plante][StS.tiller][StS.n] = max(map(current_sheath_length[StS.num_plante][StS.tiller].get, range(0, StS.n+1)))
    else:
      if 2 in current_sheath_length[StS.num_plante][StS.tiller].keys() and current_sheath_length[StS.num_plante][StS.tiller][2] > 0: #WARNING : To avoid key error when axis with less than 2 sheaths
        Sh_max[StS.num_plante][StS.tiller][StS.n] = max(map(current_sheath_length[StS.num_plante][StS.tiller].get, range(0, StS.n+1)))
      else:
        Sh_max[StS.num_plante][StS.tiller][StS.n] = 0
    
    
    StS.area = StS.diameter * pi * StS.length
    #if StS.tiller == (1,):
      #print "gaine : ", StS.n, StS.length
    
    if write_output_file["Sheath"]:
      Sheath_dico_df['Elapsed_time'].append(elapsed_time)
      Sheath_dico_df['Temp_cum'].append(Tempcum)
      Sheath_dico_df['Temperature'].append(Temperature)
      Sheath_dico_df['Num_plante'].append(StS.num_plante)
      Sheath_dico_df['Genotype'].append(StS.geno )
      Sheath_dico_df['Num_talle'].append(str(StS.tiller))
      Sheath_dico_df['Num_cohorte'].append(cohort_number(StS.tiller))
      Sheath_dico_df['Num_rang'].append(StS.n)
      Sheath_dico_df['Sheath_sumtemp'].append(StS.sumtemp)
      Sheath_dico_df['Sheath_diameter'].append(StS.diameter)
      Sheath_dico_df['Sheath_length'].append(StS.length)
      Sheath_dico_df['Sheath_final_length'].append(StS.final_length)
      Sheath_dico_df['Sheath_surface'].append(pi * (StS.diameter/2) * StS.length)
      Sheath_dico_df['Sheath_PAR'].append(StS.PAR)
      Sheath_dico_df['Photosynthetic'].append(StS.photosynthetic)
      
    produce Sheath(StS)

Internode(StI):
  StI.diameter = d_I[StI.geno]
  
  if Tempcum >= Dse_heterogeneous[StI.num_plante]:
    # Tant que l'axe n'a pas �t� d�sign� pour r�gresser, tout fonctionne normalement
    if StI.tiller in axis_census[StI.num_plante] and axis_census[StI.num_plante][StI.tiller]["Stop_growth_flag"] == True:
      StI.area = StI.diameter * pi * StI.length
      current_internode_length[StI.num_plante][StI.tiller][StI.n] = StI.length
      if dico_stades[StI.num_plante][StI.tiller]["Transiflo"][0] == True:
        StI.Ln_final = dico_stades[StI.num_plante][StI.tiller]["Ln_final"]
        #Senescence of internodes
        if StI.tiller == (1,):
          if Tempcum >= leaves_senesc_date_main_stem(min(StI.n +1, StI.Ln_final), StI.Ln_final, phyll_adjust(StI.geno), n0_sen[StI.geno], n1_sen[StI.geno], n3_sen[StI.geno], t1_sen[StI.geno], t3_sen[StI.geno], Dse_heterogeneous[StI.num_plante], DelayTipToHS[StI.geno]) and StI.photosynthetic == True:
            StI.photosynthetic = False
        else:
          if Tempcum >= leaves_senesc_date_tiller(min(StI.n +1, StI.Ln_final), StI.tiller,  StI.Ln_final, phyll_adjust(StI.geno), n0_sen[StI.geno], n1_sen[StI.geno], n2_sen[StI.geno], n3_sen[StI.geno], t1_sen[StI.geno], t2_sen[StI.geno], t3_sen[StI.geno], Dse_heterogeneous[StI.num_plante], DelayTipToHS[StI.geno]) and StI.photosynthetic == True:
            StI.photosynthetic = False
      if write_output_file["Internode"]:
        Internode_dico_df['Elapsed_time'].append(elapsed_time)
        Internode_dico_df['Temp_cum'].append(Tempcum)
        Internode_dico_df['Temperature'].append(Temperature)
        Internode_dico_df['Num_plante'].append(StI.num_plante)
        Internode_dico_df['Genotype'].append(StI.geno )
        Internode_dico_df['Num_talle'].append(str(StI.tiller))
        Internode_dico_df['Num_cohorte'].append(cohort_number(StI.tiller))
        Internode_dico_df['Num_rang'].append(StI.n)
        Internode_dico_df['Internode_length'].append(StI.length)
        Internode_dico_df['Internode_final_length'].append(StI.final_length)
        Internode_dico_df['Internode_surface'].append(StI.area)
        Internode_dico_df['Internode_PAR'].append(StI.PAR)
        Internode_dico_df['Photosynthetic'].append(StI.photosynthetic)
      
    else:
      StI.age += time_step
      StI.sumtemp += max(Tbase,Temperature)
      
      if dico_stades[StI.num_plante][StI.tiller]["Transiflo"][0] == True:
        StI.Ln_final = dico_stades[StI.num_plante][StI.tiller]["Ln_final"]
        StI.final_length = EN_fin_length(n=StI.n, Ln_final=StI.Ln_final, geno=StI.geno, shape=shp_I[StI.geno], PlHeight=Param_PlHeight[StI.geno])
        
        if Tempcum >= dico_stades[StI.num_plante][StI.tiller]["Montaison"][1]:
          if leaf_emerg_date(StI.n, StI.tiller, StI.geno, StI.num_plante) + (ED_B + ED_S) * phyll_adjust(StI.geno) <= Tempcum <= leaf_emerg_date(StI.n, StI.tiller, StI.geno, StI.num_plante) + (ED_B + ED_S + ED_I) * phyll_adjust(StI.geno):
            StI.gr = StI.final_length/(ED_I * phyll_adjust(StI.geno))
            StI.length += min(max(Tbase, StI.gr * Temperature), StI.final_length - StI.length)
            
            if StI.n == StI.Ln_final and dico_stades[StI.num_plante][StI.tiller]["End_internode_elongation"] == False:
              dico_stades[StI.num_plante][StI.tiller]["End_internode_elongation"] = True
            
          StI.area = StI.diameter * pi * StI.length
          current_internode_length[StI.num_plante][StI.tiller][StI.n] = StI.length
        
        #Senescence of internodes
        if StI.tiller == (1,):
          if Tempcum >= leaves_senesc_date_main_stem(min(StI.n +1, StI.Ln_final), StI.Ln_final, phyll_adjust(StI.geno), n0_sen[StI.geno], n1_sen[StI.geno], n3_sen[StI.geno], t1_sen[StI.geno], t3_sen[StI.geno], Dse_heterogeneous[StI.num_plante], DelayTipToHS[StI.geno]) and StI.photosynthetic == True:
            StI.photosynthetic = False
        else:
          if Tempcum >= leaves_senesc_date_tiller(min(StI.n +1, StI.Ln_final), StI.tiller,  StI.Ln_final, phyll_adjust(StI.geno), n0_sen[StI.geno], n1_sen[StI.geno], n2_sen[StI.geno], n3_sen[StI.geno], t1_sen[StI.geno], t2_sen[StI.geno], t3_sen[StI.geno], Dse_heterogeneous[StI.num_plante], DelayTipToHS[StI.geno]) and StI.photosynthetic == True:
            StI.photosynthetic = False
      
      if write_output_file["Internode"]:
        Internode_dico_df['Elapsed_time'].append(elapsed_time)
        Internode_dico_df['Temp_cum'].append(Tempcum)
        Internode_dico_df['Temperature'].append(Temperature)
        Internode_dico_df['Num_plante'].append(StI.num_plante)
        Internode_dico_df['Genotype'].append(StI.geno )
        Internode_dico_df['Num_talle'].append(str(StI.tiller))
        Internode_dico_df['Num_cohorte'].append(cohort_number(StI.tiller))
        Internode_dico_df['Num_rang'].append(StI.n)
        Internode_dico_df['Internode_length'].append(StI.length)
        Internode_dico_df['Internode_final_length'].append(StI.final_length)
        Internode_dico_df['Internode_surface'].append(StI.area)
        Internode_dico_df['Internode_PAR'].append(StI.PAR)
        Internode_dico_df['Photosynthetic'].append(StI.photosynthetic)
        
      nproduce Internode(StI)

Peduncle(StP):
  StP.diameter = d_P[StP.geno]
  # Tant que l'axe n'a pas �t� d�sign� pour r�gresser, tout fonctionne normalement
  if StP.tiller in axis_census[StP.num_plante] and axis_census[StP.num_plante][StP.tiller]["Stop_growth_flag"] == True:
    pass
  else:
    StP.sumtemp += max(Tbase,Temperature)
    StP.final_length = EN_fin_length(n=dico_stades[StP.num_plante][StP.tiller]["Ln_final"]+1, Ln_final=dico_stades[StP.num_plante][StP.tiller]["Ln_final"], geno=StP.geno, shape=shp_I[StP.geno], PlHeight=Param_PlHeight[StP.geno])
    StP.gr = StP.final_length/(ED_P * phyll_adjust(StP.geno))
    if dico_stades[StP.num_plante][StP.tiller]["End_internode_elongation"] == True : #TODO ce n'est pas sur que ce soit tres vrai, mais ce n'est probablement pas catastrophique
      if StP.length < StP.final_length:
        StP.length += min(max(Tbase,StP.gr * Temperature), StP.final_length - StP.length)
      else:
        StP.length = StP.final_length
  StP.area = StP.diameter * pi * StP.length
  
  if Tempcum >= dico_stades[StP.num_plante][StP.tiller]["Senescence_flag_leaf"][1] + Delta_flsp and StP.photosynthetic == True:
    StP.photosynthetic = False
  
  if write_output_file["Peduncle"]:
    Peduncle_dico_df['Elapsed_time'].append(elapsed_time)
    Peduncle_dico_df['Temp_cum'].append(Tempcum)
    Peduncle_dico_df['Temperature'].append(Temperature)
    Peduncle_dico_df['Num_plante'].append(StP.num_plante)
    Peduncle_dico_df['Genotype'].append(StP.geno)
    Peduncle_dico_df['Num_talle'].append(str(StP.tiller))
    Peduncle_dico_df['Num_cohorte'].append(cohort_number(StP.tiller))
    Peduncle_dico_df['Num_rang'].append(StP.n)
    Peduncle_dico_df['Sum_temp'].append(StP.sumtemp)
    Peduncle_dico_df['Peduncle_length'].append(StP.length)
    Peduncle_dico_df['Peduncle_final_length'].append(StP.final_length)
    Peduncle_dico_df['Peduncle_surface'].append(StP.area)
    Peduncle_dico_df['Peduncle_PAR'].append(StP.PAR)
    Peduncle_dico_df['Photosynthetic'].append(StP.photosynthetic)
    
  produce Peduncle(StP)

Ear(StE):
  # Tant que l'axe n'a pas �t� d�sign� pour r�gresser, tout fonctionne normalement
  if StE.tiller in axis_census[StE.num_plante] and axis_census[StE.num_plante][StE.tiller]["Stop_growth_flag"] == True:
    pass
  else:
    if dico_stades[StE.num_plante][StE.tiller]["Ear_emergence"] == True and StE.emerged == False:
      StE.emerged = True
    StE.sumtemp += max(Tbase,Temperature)
    StE.age += time_step
    StE.diameter = d_E[StE.geno]
    StE.final_length = L_E[StE.geno]
    if Tempcum >= 1300:#dico_stades[StE.num_plante][StE.tiller]["Epiaison"][1]:
      StE.length = StE.final_length
  
  StE.area = StE.length * pi * StE.diameter
  
  if Tempcum >= dico_stades[StE.num_plante][StE.tiller]["Senescence_flag_leaf"][1] + Delta_flsp and StE.photosynthetic == True:
    StE.photosynthetic = False
  
  if write_output_file["Ear"]:
    Ear_dico_df["Elapsed_time"].append(elapsed_time)
    Ear_dico_df["Temp_cum"].append(Tempcum)
    Ear_dico_df["Num_plante"].append(StE.num_plante)
    Ear_dico_df["Genotype"].append(StE.geno)
    Ear_dico_df["Num_talle"].append(str(StE.tiller))
    Ear_dico_df["Ear_sumtemp"].append(StE.sumtemp)
    Ear_dico_df["Ear_length"].append(StE.length)
    Ear_dico_df["Ear_surface"].append(StE.area)
    Ear_dico_df["Emerged"].append(StE.emerged)
    Ear_dico_df["Ear_PAR"].append(StE.PAR)
    Ear_dico_df["Photosynthetic"].append(StE.photosynthetic)
  
  produce Ear(StE)


#######INTERPRETATION##########

interpretation:

#Apex(StA):
#  produce ;(7)^(45)@O(0.01)


#Leaf(StL):
#  produce ;(4)lorient@g(Scaled(Vector3(1,1,StL.length),Leaf))

Sheath(StS):
  if StS.photosynthetic == True:
    produce ;(2)_(StS.diameter/2)F(StS.length)
  else:
    produce ;(6)_(StS.diameter/2)F(StS.length)
    


Blade(StBl):
  if StBl.num_plante in plant_census: # for color between centyre and border plant
    if StBl.n <=2 and StBl.tiller == (1,): #Les deux premi�res feuilles tester sur la taille des gaines
      if StBl.sumtemp < (ED_B + ED_S) * phyll_adjust(StBl.geno): # no inclinaison avant ligulation
        StBl.incl = 1
        width = d_S[StBl.geno]-0.05
      else:
        StBl.incl = hazard_dict_organ[StBl.num_plante][StBl.tiller][StBl.n]["blade_inclination"]
        width = StBl.width
      produce ;(1)+(StBl.incl)@g(Scaled(Vector3(width,0.25,StBl.visible_length),Blade_geo))
    else:
      if axis_census[StBl.num_plante].has_key(StBl.tiller):
        #print StBl.num_plante, StBl.tiller, axis_census[StBl.num_plante][StBl.tiller]["Stop_growth_flag"]
        if axis_census[StBl.num_plante][StBl.tiller]["Stop_growth_flag"] == True:
          couleur = 11
        else:
          couleur = 1
      else:
        couleur = 1
      #Si le limbe n'a pas fini de sortir de la grande gaine
      if StBl.sumtemp < (ED_B + ED_S) * phyll_adjust(StBl.geno):
        StBl.incl = 1
        if StBl.sumtemp < ED_B * phyll_adjust(StBl.geno):
          produce ;(couleur)+(StBl.incl)f(Sh_max[StBl.num_plante][StBl.tiller][StBl.n])@g(Scaled(Vector3(d_S[StBl.geno],0.25,StBl.visible_length),Blade_geo))
        else:
          produce ;(couleur)+(StBl.incl)@g(Scaled(Vector3(d_S[StBl.geno]-0.05,0.25,StBl.visible_length),Blade_geo))
          
      # Si la ligule du limbe est apparente
      else:
        StBl.incl = hazard_dict_organ[StBl.num_plante][StBl.tiller][StBl.n]["blade_inclination"]
        if StBl.photosynthetic == False:
          produce ;(5)+(StBl.incl)@g(Scaled(Vector3(StBl.width,0.25,StBl.visible_length),Blade_geo))
        else:
          produce ;(couleur)+(StBl.incl)@g(Scaled(Vector3(StBl.width,0.25,StBl.visible_length),Blade_geo))
  else:
    # Pour les plantes de bordures
    if StBl.n <=2 and StBl.tiller == (1,): #Les deux premi�res feuilles tester sur la taille des gaines
      if StBl.sumtemp < (ED_B + ED_S) * phyll_adjust(StBl.geno):
        StBl.incl = 1
        width = d_S[StBl.geno]-0.05
      else:
        StBl.incl = hazard_dict_organ[StBl.num_plante][StBl.tiller][StBl.n]["blade_inclination"]
        width = StBl.width
      produce ;(4)+(StBl.incl)@g(Scaled(Vector3(width,0.25,StBl.visible_length),Blade_geo))
    else:
      #Si le limbe n'a pas fini de sortir de la grande gaine
      if StBl.sumtemp < (ED_B + ED_S) * phyll_adjust(StBl.geno):
        StBl.incl = 1
        if StBl.sumtemp < ED_B * phyll_adjust(StBl.geno):
          produce ;(4)+(StBl.incl)f(Sh_max[StBl.num_plante][StBl.tiller][StBl.n])@g(Scaled(Vector3(d_S[StBl.geno],0.25,StBl.visible_length),Blade_geo))
        else:
          produce ;(4)+(StBl.incl)@g(Scaled(Vector3(d_S[StBl.geno]-0.05,0.25,StBl.visible_length),Blade_geo))
      # Si la ligule du limbe est apparente
      else:
        StBl.incl = hazard_dict_organ[StBl.num_plante][StBl.tiller][StBl.n]["blade_inclination"]
        if StBl.photosynthetic == False:
          produce ;(5)+(StBl.incl)@g(Scaled(Vector3(StBl.width,0.25,StBl.visible_length),Blade_geo))
        else:
          produce ;(4)+(StBl.incl)@g(Scaled(Vector3(StBl.width,0.25,StBl.visible_length),Blade_geo))


#Blade(StBl):
#  if StBl.n <=2:
#    if StBl.tiller == (1,):
#      if StBl.sumtemp < (ED_B + ED_S) * phyll_adjust(StBl.geno):
#        StBl.incl = 1
#        width = sheath_diameter-0.05
#      else:
#        StBl.incl = hazard_dict_organ[StBl.num_plante][StBl.tiller][StBl.n]["blade_inclination"]
#        width = StBl.width
#      produce ;(4)+(StBl.incl)@g(Scaled(Vector3(width,0.25,StBl.length),Blade_geo))
#    else:
#      if StBl.sumtemp < (ED_B + ED_S) * phyll_adjust(StBl.geno):
#        StBl.incl = 1
#        if StBl.sumtemp < ED_B * phyll_adjust(StBl.geno):
#          #if StBl.tiller == (1,2) and StBl.n == 1:
#            #print StBl.tiller, StBl.n, "incl : ",StBl.incl
#          produce ;(14)+(StBl.incl)f(Sh_max[StBl.num_plante][StBl.tiller][StBl.n])@g(Scaled(Vector3(sheath_diameter,0.25,StBl.visible_length),Blade_geo))
#        else:
#          produce ;(11)+(StBl.incl)@g(Scaled(Vector3(sheath_diameter,0.25,StBl.length),Blade_geo))
#      
#  else:
#    #Si le limbe n'a pas fini de sortir de la grande gaine
#    if StBl.sumtemp < (ED_B + ED_S) * phyll_adjust(StBl.geno):
#      StBl.incl = 1
#      if StBl.sumtemp < ED_B * phyll_adjust(StBl.geno):
#        produce ;(4)+(StBl.incl)f(Sh_max[StBl.num_plante][StBl.tiller][StBl.n])@g(Scaled(Vector3(sheath_diameter,0.25,StBl.visible_length),Blade_geo))
#      else:
#        produce ;(4)+(StBl.incl)@g(Scaled(Vector3(sheath_diameter-0.05,0.25,StBl.length),Blade_geo))
#    # Si la ligule du limbe est apparente
#    else:
#      StBl.incl = hazard_dict_organ[StBl.num_plante][StBl.tiller][StBl.n]["blade_inclination"]
#      if StBl.photosynthetic == False:
#        produce ;(5)+(StBl.incl)@g(Scaled(Vector3(StBl.width,0.25,StBl.length),Blade_geo))
#      else:
#        produce ;(4)+(StBl.incl)@g(Scaled(Vector3(StBl.width,0.25,StBl.length),Blade_geo))
#
Ear(StE):
  StE.zenith = Phi_zen_E
  #if dico_stades[StE.num_plante][StE.tiller]["End_internode_elongation"] == True and Tempcum < dico_stades[StE.num_plante][StE.tiller]["Flo"][1]:
  if StE.photosynthetic == True:
    if delta_H[StE.num_plante][StE.tiller] > 0:
      visible_length = min(delta_H[StE.num_plante][StE.tiller], L_E[StE.geno])
      if StE.geno == 1:
        ear_color = 2
      else:
        ear_color = 4
      nproduce ;(ear_color)&(StE.zenith)_(StE.diameter/2)F(visible_length)
  elif StE.photosynthetic == False:
    if StE.geno == 1:
      dead_ear_color = 6
    else:
      dead_ear_color = 7
    nproduce ;(dead_ear_color)&(StE.zenith)_(StE.diameter/2)F(L_E[StE.geno])

Peduncle(StP):
  if StP.photosynthetic == True:
    produce ;(7)_(StP.diameter/2)F(StP.length)
  else:
    produce ;(5)_(StP.diameter/2)F(StP.length)
    


Internode(StI):
  if StI.photosynthetic == True:
    produce ;(3)_(StI.diameter/2)F(StI.length)\(StI.azimuth)
  else:
    produce ;(5)_(StI.diameter/2)F(StI.length)\(StI.azimuth)
    

CutPointBud(StCPB):
  if Tempcum < leaf_emerg_date(1, StCPB.tiller, StCPB.geno, StCPB.num_plante) + (ED_B + ED_S) * phyll_adjust(StCPB.geno):
    StCPB.zenith = 0
  else:
    StCPB.zenith = hazard_dict_axis[StCPB.num_plante][StCPB.tiller]["tiller_zenith"]
  #StCPB.zenith = hazard_dict_axis[StCPB.num_plante][StCPB.tiller]["tiller_zenith"]
  StCPB.azimuth = hazard_dict_axis[StCPB.num_plante][StCPB.tiller]["tiller_azimuth"]
  #if StCPB.tiller == (1,2):
    #print "zen : ", StCPB.zenith, "azi : ",StCPB.azimuth
  #if StCPB.tiller == (1,) or StCPB.tiller == (1,2):
    #print "axe : ", StCPB.tiller, "zen : ", StCPB.zenith, "azi : ", StCPB.azimuth
  if StCPB.tiller == (1,):
    produce @R/(StCPB.azimuth)+(StCPB.zenith)F(0.01)
  else:
    produce /(StCPB.azimuth)+(StCPB.zenith)F(0.01)

endlsystem
###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
	import openalea.plantgl.all as pgl
	Color_1 = pgl.Material("Color_1" , ambient = (0,0,0) , diffuse = 0 , specular = (8,120,15) , emission = (21,135,38) , )
	Color_1.name = "Color_1"
	context.turtle.setMaterial(1,Color_1)
	Color_2 = pgl.Material("Color_2" , ambient = (0,0,0) , diffuse = 0 , specular = (44,44,44) , emission = (0,143,0) , shininess = 0.69 , )
	Color_2.name = "Color_2"
	context.turtle.setMaterial(2,Color_2)
	Color_3 = pgl.Material("Color_3" , ambient = (0,0,0) , diffuse = 0 , specular = (0,0,0) , emission = (11,111,0) , shininess = 0 , )
	Color_3.name = "Color_3"
	context.turtle.setMaterial(3,Color_3)
	Color_4 = pgl.Material("Color_4" , ambient = (131,0,0) , diffuse = 0.793893 , specular = (0,0,0) , emission = (39,0,0) , shininess = 0 , )
	Color_4.name = "Color_4"
	context.turtle.setMaterial(4,Color_4)
	Color_5 = pgl.Material("Color_5" , ambient = (195,189,16) , diffuse = 0.169231 , specular = (0,0,0) , emission = (14,14,3) , shininess = 0 , )
	Color_5.name = "Color_5"
	context.turtle.setMaterial(5,Color_5)
	Color_6 = pgl.Material("Color_6" , ambient = (36,37,0) , diffuse = 1.83784 , specular = (0,0,0) , emission = (226,152,24) , shininess = 0 , )
	Color_6.name = "Color_6"
	context.turtle.setMaterial(6,Color_6)
	Color_7 = pgl.Material("Color_7" , ambient = (0,0,0) , diffuse = 0 , specular = (0,0,0) , emission = (115,58,20) , )
	Color_7.name = "Color_7"
	context.turtle.setMaterial(7,Color_7)
	Color_8 = pgl.Material("Color_8" , ambient = (5,253,245) , diffuse = 1.00791 , emission = (28,237,255) , )
	Color_8.name = "Color_8"
	context.turtle.setMaterial(8,Color_8)
	Color_9 = pgl.Material("Color_9" , ambient = (170,85,255) , diffuse = 0 , specular = (0,0,0) , )
	Color_9.name = "Color_9"
	context.turtle.setMaterial(9,Color_9)
	Color_10 = pgl.Material("Color_10" , ambient = (0,0,0) , diffuse = 26.6667 , specular = (0,0,0) , )
	Color_10.name = "Color_10"
	context.turtle.setMaterial(10,Color_10)
	Color_11 = pgl.Material("Color_11" , ambient = (0,0,255) , diffuse = 0 , specular = (0,0,0) , )
	Color_11.name = "Color_11"
	context.turtle.setMaterial(11,Color_11)
	Color_12 = pgl.Material("Color_12" , ambient = (0,0,0) , diffuse = 0 , specular = (0,0,0) , emission = (255,42,14) , shininess = 0 , )
	Color_12.name = "Color_12"
	context.turtle.setMaterial(12,Color_12)
	Color_13 = pgl.Material("Color_13" , ambient = (0,0,0) , diffuse = 30 , specular = (0,0,0) , emission = (236,255,19) , )
	Color_13.name = "Color_13"
	context.turtle.setMaterial(13,Color_13)
	Color_14 = pgl.Material("Color_14" , ambient = (248,44,255) , diffuse = 0.627451 , )
	Color_14.name = "Color_14"
	context.turtle.setMaterial(14,Color_14)
