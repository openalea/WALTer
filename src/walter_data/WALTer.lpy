# -*- coding: utf-8 -*-

### Importation de libraries
from __future__ import division
import random
from openalea.plantgl.all import *
import pandas as pd
import numpy as np

import sys
import os
from math import sqrt, exp, pi, floor, ceil, asin, acos, cos, sin, tan, log
from walter.leaf_shape import walter_leaf, walter_leaf_mesh, leaf_area, form_factor

pj = os.path.join
data_dir = os.getcwd()
inputdir = pj(data_dir, 'input')
#from my_own_functions import *

# setup params/ID if and only if params not defined as Lsys args
try:
  params = params
except NameError:
  params = {}
  ID = 'walter_defaults'

try:
  ID = ID
except NameError:
  ID = 'debug'


### Importations de fichiers annexes ###

from walter import fitness

### Rayonnement ###
#from vplants.fractalysis.light.directLight import diffuseInterception      #Importation de Fractalysis : obsolete

from walter.light import CaribuScene, get_light, get_turtle_light
from walter.light import CaribuRecorder

from walter.crop_conception import design_crop_mesh_for_nplants, design_crop_Darwinkel, adapting_crop_area, \
  design_crop_classical, plant_disposition, domain, central_domain, central_and_border_plants, set_neighbour

# CPL

# Date

import datetime

# Liste des modules utilises par la suite dans le modele :

# Plan de semis dans lequel on specifie le nombre de plantes et espacement entre les plantes
module Seed

# Differents organes qui vont suivre des lois de production "propres"
module Apex
module Bud_primord
module Bud
module Bud_R
module Apex_R


module Leaf
module Internode

module Sheath
module Blade

module Peduncle
module Ear

# Module "d'insertion de branche" dans lequel on va faire evoluer les regles de regression de talles
module CutPointBud
module CutPointBlade

### REPRESENTATION DES ORGANES


#Parametres de mise a l'echelle pour que 1=1 dans chacune des directions
scalex = 0.5
scaley = 1
scalez = 0.5

#########################

#Importation des figures creees dans des scenes
#scene_house  =  Scene(pj(inputdir,'organ_shapes', 'Pentagon_up.bgeom'))
#scene_square =  Scene(pj(inputdir,'organ_shapes','Square_up_volume.bgeom'))

#Sheath_geo = Scaled(Vector3(scalex,scaley,scalez),scene_square[0].geometry)
#Blade_geo  = Scaled(Vector3(scalex,scaley,scalez),scene_house[0].geometry)

WALTer_version = "v3.0"
WALTer_build = 29042019

##########################################
####     BUILDING OUR SIMULATION      ####
##########################################
expe_related         = "Sensitivity_Analysis"
densite              = 150
CARIBU_state         = "enabled"
rep                  = 1
write_debug_PAR = False
CARIBU_screen_res = 2000
show_caribu_stats = False # print checks small triangle problems / infos for screen_size setting

# minimal length for representing visible objects (1mm). 1e-3 apparently prevent generation of small leaves (pgl warning)
epsilonL = 1e-1

caribu_recorder = CaribuRecorder()

var_register1 = ["expe_related","densite","CARIBU_state","rep", "write_debug_PAR", "CARIBU_screen_res"]

for key, value, in params.iteritems():
  if key in var_register1:
    exec(key+"=value")


hazard_plant_xy = True
hazard_plant_azi = True
hazard_axis = True
hazard_organ = True
hazard_emerg = True

var_register_hazard = ["hazard_plant_xy","hazard_plant_azi","hazard_axis","hazard_organ","hazard_emerg"]

for key, value, in params.iteritems():
  if key in var_register_hazard:
    exec(key+"=value")


hazard_driver = {"plant_azi" : hazard_plant_azi, "plant_xy" : hazard_plant_xy, "axis" : hazard_axis, "organ" : hazard_organ, "emerg" : hazard_emerg}


write_lscene = False
write_lstring = False

which_output_files = pd.read_csv(pj(data_dir, "which_output_files.csv"), sep="\t")
write_output_file = {"GAI":which_output_files.GAIp[0], "Peraxes":which_output_files.Peraxes[0], "Proba":which_output_files.Proba[0], "Apex_Sirius":which_output_files.Apex_sirius[0], "Apex":which_output_files.Apex[0], "Apex_R":which_output_files.Apex_R[0], "Blade":which_output_files.Blade[0], "Internode":which_output_files.Internode[0], "Sheath":which_output_files.Sheath[0], "Ear":which_output_files.Ear[0], "Peduncle":which_output_files.Peduncle[0], "PAR_per_axes":which_output_files.PAR_per_axes[0], "Fitness":which_output_files.Fitness[0], "Lstring":which_output_files.Lstring[0], "Lscene":which_output_files.Lscene[0]}
print "ce qu'on ecrit:", write_output_file["Lscene"]


#########################

#Phyllochron adjustment
def phyll_adjust(geno):
  if sowing_DOY >= SDSA:
    phyllo = Phl[geno]
  else:
    phyllo = Phl[geno] * (1 - Rp * min(sowing_DOY,SDWS))
  return phyllo


# When using WALTer with the population genetics model, the names of the genotypes are defined in the sim_scheme.csv parameter file
# In the sim_scheme parameter file, the parameter genotypes must be the names of the different genotypes only separated by a comma
# In the sim_scheme parameter file, the parameter genotype_numbers must be the number of plants for each genotype (in the same order as the genotypes parameter) only separated by a comma

genotypes = str()
genotype_numbers = str()

var_register_genotypes = ["genotypes","genotype_numbers"]

for key, value, in params.iteritems():
  if key in var_register_genotypes:
    exec(key+"=value")

genotypes = genotypes.split(',') # genotypes is a list with the names of the different genotypes
genotype_numbers = str(genotype_numbers) # making sure genotype_numbers is a string
genotype_numbers = genotype_numbers.split(',') # genotype_numbers is a list with the number of plants for each genotype


var_register_Ln_final_genetics = []

for geno in genotypes:
  var_register_Ln_final_genetics.append("Ln_final_"+geno)

Ln_final_genetics = {}

for key, value, in params.iteritems():
  if key in var_register_Ln_final_genetics:
    exec(key + "=value")

if expe_related == "Genetics":
  for geno in genotypes:
    Ln_final_genetics[geno] = eval("Ln_final_"+geno)

# Setting experimental informations
experimental_conditions = {
"Sreten":{"sowing_date" : datetime.date(1998,10,15), "year" : "1999","location" : "Grignon","meteo" : "Grignon", "dist_inter_rang" : 0.175, "genotype" : ["Soissons"], "Ln_final":{"Soissons":11}},
"Rim1-1":{"sowing_date" : datetime.date(2007,9,25), "year" : "2008","location" : "Grignon","meteo" : "Grignon", "dist_inter_rang" : 0.175, "genotype" : ["Soissons"], "Ln_final":{"Soissons":11}},
"Rim1-2":{"sowing_date" : datetime.date(2007,11,12), "year" : "2008","location" : "Grignon","meteo" : "Grignon", "dist_inter_rang" : 0.175, "genotype" : ["Soissons"], "Ln_final":{"Soissons":11}},
"Rim2-1":{"sowing_date" : datetime.date(2008,9,30), "year" : "2009","location" : "Grignon","meteo" : "Grignon", "dist_inter_rang" : 0.175, "genotype" : ["Soissons"], "Ln_final":{"Soissons":11}},
"Rim2-2":{"sowing_date" : datetime.date(2008,11,17), "year" : "2009","location" : "Grignon","meteo" : "Grignon", "dist_inter_rang" : 0.175, "genotype" : ["Soissons"], "Ln_final":{"Soissons":11}},
"Jillian":{"sowing_date" : datetime.date(2003,10,16), "year" : "2004","location" : "Grignon","meteo" : "Grignon", "dist_inter_rang" : 0.175, "genotype" : ["Soissons"], "Ln_final":{"Soissons":11}},
"Jessica":{"sowing_date" : datetime.date(2005,10,27), "year" : "2006","location" : "Grignon","meteo" : "Bertheloot_2005", "dist_inter_rang" : 0.175, "genotype" : ["Soissons"], "Ln_final":{"Soissons":11.3}},
"Mariem":{"sowing_date" : datetime.date(2010,10,26), "year" : "1901","location" : "Grignon","meteo" : "Grignon", "dist_inter_rang" : 0.175, "genotype" : ["Maxwell"] , "Ln_final":{"Maxwell":11.3}},
"Darwinkel":{"sowing_date" : datetime.date(1976,10,19), "year" : "1977","location" : "Lelystad","meteo" : "Lelystad", "dist_inter_rang" : 0.175, "genotype" : ["Lely"], "Ln_final":{"Lely":11}},
"Darwinkel_temp":{"sowing_date" : datetime.date(2013,10,19), "year" : "1901","location" : "Grignon","meteo" : "Grignon", "dist_inter_rang" : 0.175, "genotype" : ["Maxwell"], "Ln_final":{"Maxwell":11}},
"Wheatamix-2014":{"sowing_date" : datetime.date(2013,10,31), "year" : "2014","location" : "Grignon","meteo" : "Grignon", "dist_inter_rang" : 0.175, "genotype" : ["Soissons"], "Ln_final":{"Soissons":11}},
"Ouitamics-2014":{"sowing_date" : datetime.date(2013,10,30), "year" : "2014","location" : "Gif_sur_Yvette","meteo" : "Gif_sur_Yvette", "dist_inter_rang" : 0.15, "genotype" : ["Soissons","Apache", "Renan", "Caphorn", "A208", "A210", "F236", "A398"], "Ln_final":{"Soissons":11,"Apache":11, "Renan":11, "Caphorn":11, "A208":11, "A210":11, "F236":11, "A398":11}},
"None":{"sowing_date" : datetime.date(2013,10,15), "year" : "2014","location" : "Gif_sur_Yvette","meteo" : "Gif_sur_Yvette", "dist_inter_rang" : 0.1, "genotype" : ["Soissons","Maxwell"], "Ln_final":{"Soissons":11,"Maxwell":11}},
"Mariem_mean":{"sowing_date" : datetime.date(1900,10,26), "year" : "1901","location" : "Grignon","meteo" : "Grignon_mean10", "dist_inter_rang" : 0.175, "genotype" : ["Maxwell"] , "Ln_final":{"Maxwell":11}},
"Darwinkel_Grignon_mean":{"sowing_date" : datetime.date(1900,10,19), "year" : "1901","location" : "Grignon","meteo" : "Grignon_mean10", "genotype" : ["Maxwell"], "Ln_final":{"Maxwell":11}},
"Darwinkel_mean":{"sowing_date" : datetime.date(1900,10,19), "year" : "1901","location" : "Lelystad","meteo" : "Lelystad_mean10", "dist_inter_rang" : 0.175, "genotype" : ["Maxwell"], "Ln_final":{"Maxwell":11.3}
},
"Sparkes_2001":{"sowing_date" : datetime.date(2000,10,17), "year" : "2001","location" : "Nottingham","meteo" : "Nottingham","dist_inter_rang" :0.135, "genotype" : ["Maxwell"], "Ln_final":{"Maxwell":11}},
"Sparkes_2002":{"sowing_date" : datetime.date(2001,10,4), "year" : "2002","location" : "Nottingham","meteo" : "Nottingham","dist_inter_rang" :0.135, "genotype" : ["Maxwell"], "Ln_final":{"Maxwell":11}},
"Sparkes_2003":{"sowing_date" : datetime.date(2002,9,20), "year" : "2003","location" : "Nottingham","meteo" : "Nottingham","dist_inter_rang" :0.135, "genotype" : ["Maxwell"], "Ln_final":{"Maxwell":11}},
"Association" : {"sowing_date" : datetime.date(2013,10,30),"year" : "2014","location" : "Gif_sur_Yvette","meteo" : "Gif_sur_Yvette", "dist_inter_rang" : 0.175, "genotype" : ["Gigant_Maxwell","Darwinkel_Maxwell"] , "Ln_final":{"Gigant_Maxwell":11,"Darwinkel_Maxwell":11}},
"Sensitivity_Analysis" : {"sowing_date" : datetime.date(1900,10,15),"year" : "1901","location" : "Grignon","meteo" : "Climat_moy_AS", "dist_inter_rang" : 0.175, "genotype" : ["Maxwell"] , "Ln_final":{"Maxwell":11.3}},
"Genetics":{"sowing_date" : datetime.date(1900,10,15),"year" : "1901","location" : "Grignon","meteo" : "Climat_moy_AS", "dist_inter_rang" : 0.175, "genotype" : genotypes , "Ln_final": Ln_final_genetics}
}

liste_expe = experimental_conditions.keys()

## CARIBU
infinity_CARIBU = 0              # En booleen 0 : False 1: True
nb_azimuth = 5
nb_zenith = 4

dico_latitudes = {'Gif_sur_Yvette': 48.5, 'Le_Pin_aux_Haras': 48.7, 'Lelystad': 52.5, 'Le_Rheu': 48.1,'Alenya': 42.6, 'Grignon': 48.8, 'Colmar': 48.1, 'Fagniere': 49, 'Clermont': 45.7, "Nottingham" : 52.9}
dico_longitudes = {'Gif_sur_Yvette': 2.13, 'Le_Pin_aux_Haras': 0.13, 'Lelystad': 5.47, 'Le_Rheu': 1.77,'Alenya': 2.98, 'Grignon': 1.95, 'Colmar': 7.37, 'Fagniere': 4.32, 'Clermont': 3.08, "Nottingham" : -1.17}
dico_altitude = {'Gif_sur_Yvette': 61, 'Le_Pin_aux_Haras': 200, 'Lelystad': 0, 'Le_Rheu': 25,'Alenya': 8, 'Grignon': 106, 'Colmar': 200, 'Fagniere': 100, 'Clermont': 358, "Nottingham" : 46}
dico_time_zone = {'Gif_sur_Yvette': "Europe/Paris", 'Le_Pin_aux_Haras': "Europe/Paris", 'Lelystad': "Europe/Amsterdam", 'Le_Rheu': "Europe/Paris",'Alenya': "Europe/Paris", 'Grignon': "Europe/Paris", 'Colmar': "Europe/Paris", 'Fagniere': "Europe/Paris", 'Clermont': "Europe/Paris", "Nottingham" : "Europe/London"}

# Moyennes sur 10/18ans disponibles sur Grignon : { "Grignon_mean10" "Grignon_mean18"}
# Pour Lelystad on a plusieurs variantes : Lelystad, Lelystad_plusundemi, Lelystad_plusun

########################################

crop_ccptn = "Mesh_for_nplants"


var_register0 = ["crop_ccptn", "infinity_CARIBU"]

for key, value, in params.iteritems():
  if key in var_register0:
    exec(key+"=value")

#default values relative to crop_conception (registered later on before crop_scheme init)
area_targeted = 1
nb_rang = 1
nb_plt_temp = 1
area_min, area_max = 1, 13
opt_plt_nb = 10
nb_plt_utiles = 50
if crop_ccptn == "classical":
  dist_border_x = 0. #inside a rang
  dist_border_y = 0. #rang
elif crop_ccptn == "neo_Darwinkel":
  dist_border_x = 0.2 #inside a rang
  dist_border_y = 0.15 #rang
elif crop_ccptn == "Darwinkel_original":
  dist_border_x = 0.15 #inside a rang
  dist_border_y = 0.15 #rang
elif crop_ccptn == "Mesh_for_nplants":
  dist_border_x = 0.20 #inside a rang
  dist_border_y = 0.20 #rang

genotype_proportion = "random"

var_register_genotype_proportion = ["genotype_proportion"]

for key, value, in params.iteritems():
  if key in var_register_genotype_proportion:
    exec(key+"=value")


geno_nb              = len(experimental_conditions[expe_related]["genotype"])                              # Number of different genotypes on the plot

crop_genotype = []

for geno in experimental_conditions[expe_related]["genotype"]:
  crop_genotype.append(geno)

################################

SIRIUS_state         = "disabled"
infinity_GAIp        = "True"         # A METTRE EN TEXTE #Infinitisation du couvert pour le calcul du GAI de proximite
cohorte_max          = 9

# If SIRIUS in not activated, the final number of leaves on the main stem is chosen according to the experimental data. If there is no experimental data, the default value is 11.

# Initialization
global param_Ln_final

if SIRIUS_state == "disabled":
  if expe_related in liste_expe:
    param_Ln_final = experimental_conditions[expe_related]["Ln_final"]
  else:
    param_Ln_final = {}

var_register_Ln_final = ["Ln_final_Maxwell","Ln_final_Soissons","Ln_final_Lely","Ln_final_Gigant_Maxwell","Ln_final_Darwinkel_Maxwell","Ln_final_Apache","Ln_final_Renan","Ln_final_Caphorn","Ln_final_A208","Ln_final_A210","Ln_final_F236","Ln_final_A398"]

for key, value, in params.iteritems():
  if key in var_register_Ln_final:
    exec(key+"=value")

for geno in crop_genotype:
  try:
    param_Ln_final[geno] = eval("Ln_final_"+geno)
  except NameError:
    pass

####################
#### PARAMETERS ####
####################

# genotypic parameters are described by python dictionnaries in which the value is associated with the name of the genotype

# leaf geometry, with control of inclination at meshing
leaf_nb_segments = 7

scurv_Maxwell = 0.75
curvature_Maxwell = 30

var_register_leaf = ["leaf_nb_segments"]

for geno in crop_genotype:
  var_register_leaf.append("scurv_"+geno)
  var_register_leaf.append("curvature_"+geno)

for key, value, in params.iteritems():
  if key in var_register_leaf:
    exec(key+"=value")


scurv = {"Maxwell" : scurv_Maxwell} 
curvature = {"Maxwell" : curvature_Maxwell}

for geno in crop_genotype:
  scurv[geno] = eval("scurv_"+geno)
  curvature[geno] = eval("curvature_"+geno)


### SIRIUS PARAMETERS ###

# Final leaf number by SIRIUS
Tvermin             = 0
Tverint             = 8
Tvermax             = 17
Lmax                = 24
Lmin                = 8
DLsat               = 15

# Adjusting phyllochrone to leaf number
Ldecr               = 2
Lincr               = 8
phyllo_decr         = 0.75
phyllo_incr         = 1.25

# Adjusting phyllochron to extreme sowing dates

SDSA = 200                                      # mid-july (in DOY)
SDWS = 90                                       # End of the winter (
Rp = 0.003                                      # decroissement du phyllo 

VAI_Maxwell = 0.00906
VAI_Soissons = 0.00906
VAI_Renan =  0.00456


VBEE_Maxwell =  0.012
VBEE_Soissons = 0.012
VBEE_Renan = 0.012


SLDL_Maxwell = 1.34
SLDL_Soissons = 1.34
SLDL_Renan = 1.12 

var_register_phyll_adjust = []

for geno in crop_genotype:
  var_register_phyll_adjust.append("VAI_"+geno)
  var_register_phyll_adjust.append("VBEE_"+geno)
  var_register_phyll_adjust.append("SLDL_"+geno)

for key, value, in params.iteritems():
  if key in var_register_phyll_adjust:
    exec(key+"=value")


VAI = {"Maxwell" : VAI_Maxwell, "Gigant_Maxwell" : VAI_Maxwell, "Darwinkel_Maxwell" : VAI_Maxwell, "Soissons" : VAI_Soissons, "Renan" :VAI_Renan}    # Differentes valeurs issues de recalibrations (pour Soissons) He : 0.00906  #Ly : 0.00405  #Lecarpentier :
VBEE = {"Maxwell" :VBEE_Maxwell, "Gigant_Maxwell" :VBEE_Maxwell , "Darwinkel_Maxwell" : VBEE_Maxwell, "Soissons" : VBEE_Soissons, "Renan" : VBEE_Renan}         # Differentes valeurs issues de recalibrations (pour Soissons)  #He : 0.012    #Ly : 0.012    #Lecarpentier : 0.012
SLDL = {"Maxwell" : SLDL_Maxwell, "Gigant_Maxwell" : SLDL_Maxwell, "Darwinkel_Maxwell" : SLDL_Maxwell, "Soissons" : SLDL_Soissons, "Renan" : SLDL_Renan}           # Differentes valeurs issues de recalibrations (pour Soissons) #He : 1.34     #Ly : 1.467    #Lecarpentier : 

for geno in crop_genotype:
  VAI[geno] = eval("VAI_"+geno)
  VBEE[geno] = eval("VBEE_"+geno)
  SLDL[geno] = eval("SLDL_"+geno) 

# Final plant height (internodes+peduncle+ear of mainstem)
Param_PlHeight_Maxwell = 55.6155
Param_PlHeight_Soissons = 87.6579
Param_PlHeight_Gigant_Maxwell = 110
Param_PlHeight_Darwinkel_Maxwell = 55.6155

var_registerHeight = ["Param_PlHeight_Maxwell","Param_PlHeight_Soissons","Param_PlHeight_Gigant_Maxwell","Param_PlHeight_Darwinkel_Maxwell"]

for geno in crop_genotype:
  var_registerHeight.append("Param_PlHeight_"+geno)
  
for key, value, in params.iteritems():
  if key in var_registerHeight:
    exec(key+"=value")

Param_PlHeight = {"Maxwell" : Param_PlHeight_Maxwell, "Gigant_Maxwell" : Param_PlHeight_Gigant_Maxwell, "Darwinkel_Maxwell" : Param_PlHeight_Darwinkel_Maxwell, "Soissons" : Param_PlHeight_Soissons}

for geno in crop_genotype:
  Param_PlHeight[geno] = eval("Param_PlHeight_"+geno)

## DEVELOPMENT OF VEGETATIVE ORGANS
######################################


# Organ initiation, emergence and elongation
Phl_Maxwell = 99
Phl_Soissons = 87
Phl_Renan = 112


DelayHSToCol = 0.2                                     #temps phyllochronique


ED_I = 1.66 # Duration for internode extension (value extracted directly from ADEL-wheat) (phyllochronic time) | old name : gr_duration_internode
ED_B = 1.6  # Duration for blade extension (phyllochronic time)                                                | old name : gr_duration_blade
ED_FB = 1 # Duration for the extension of the flag blade(phyllochronic time)                                 | old name : gr_duration_flagblade
ED_S = 0.4 # Duration for sheath extension (phyllochronic time)                                                 | old name : gr_duration_sheath
ED_P = 2 # Duration for peduncle extension (phyllochronic time)                                                 | old name : gr_duration_peduncle


# Tiller emergence
Delta_b  = 1            #Delay between the initiation of a bud and the start of its activity (plastochronic unit) | old name : inactive_time_bud

P_T_Maxwell = 0.88
P_T_Soissons = 0.88


P_CT_Maxwell = 0
P_CT_Soissons = 0

var_register_till_prob = []

for geno in crop_genotype:
  var_register_till_prob.append("P_T_"+geno)
  var_register_till_prob.append("P_CT_"+geno)

for key, value, in params.iteritems():
  if key in var_register_till_prob:
    exec(key+"=value")

P_T = {"Maxwell" : P_T_Maxwell, "Gigant_Maxwell" : P_T_Maxwell, "Darwinkel_Maxwell" : P_T_Maxwell, "Soissons" : P_T_Soissons}  # Probability of emergence of a tiller (except for coleoptil tiller) | old name : tillering_prob
P_CT = {"Maxwell" : P_CT_Maxwell, "Gigant_Maxwell" : P_CT_Maxwell, "Darwinkel_Maxwell" : P_CT_Maxwell, "Soissons" : P_CT_Soissons}              #Probability of emergence of coleoptil tiller | old name : prob_appear_Tc

for geno in crop_genotype:
  P_T[geno] = eval("P_T_"+geno)
  P_CT[geno] = eval("P_CT_"+geno)

# Floral transition and final leaf number

Psi_FT = 0 #Thermal time shift between the floral transition of axes belonging to two consecutive cohorts | old name : transiflo_shift_param

Dse_mean_Maxwell = 81
Dse_sd_Maxwell = int(hazard_driver["emerg"]) * 30
Dse_mean_Soissons = 100
Dse_sd_Soissons = int(hazard_driver["emerg"]) * 30
Dse_mean_Thesee = 125
Dse_sd_Thesee = int(hazard_driver["emerg"]) * 30
Dse_mean_Renan = 125
Dse_sd_Renan = int(hazard_driver["emerg"]) * 30

var_registerDSE = ["Dse_mean_Maxwell","Dse_mean_Soissons","Dse_mean_Thesee","Dse_mean_Renan","Dse_sd_Maxwell","Dse_sd_Soissons","Dse_sd_Thesee","Dse_sd_Renan"]

for geno in crop_genotype:
  var_registerDSE.append("Dse_mean_"+geno)
  var_registerDSE.append("Dse_sd_"+geno)

for key, value, in params.iteritems():
  if key in var_registerDSE:
    exec(key+"=value")

Dse = {"Maxwell" : {"mean" : Dse_mean_Maxwell, "sd" : Dse_sd_Maxwell}, "Gigant_Maxwell" : {"mean" : Dse_mean_Maxwell, "sd" : Dse_sd_Maxwell}, "Darwinkel_Maxwell" : {"mean" : Dse_mean_Maxwell, "sd" : Dse_sd_Maxwell}, "Soissons" : {"mean" : Dse_mean_Soissons, "sd" : Dse_sd_Soissons}, "Thesee" : {"mean" : Dse_mean_Thesee, "sd" : Dse_sd_Thesee}, "Renan" : {"mean" :Dse_mean_Renan , "sd" : Dse_sd_Renan}}

for geno in crop_genotype:
  Dse[geno] = { "mean" : eval("Dse_mean_"+geno) , "sd" : eval("Dse_sd_"+geno)}


N_p_s = 4 #Number of primordia already preformed inside the seed | old name : nb_primord_seed

# Phenology
Delta_hf = 1.3        # Delay between heading and flowering (phyllochronic unit) | old name : delta_epi_flo
Delta_c_GN = 30       # Duration of the critical period determining grain number (days) | old name : duration_critical_period
Delta_hm = 800        # Delay between heading and maturity (in degree-days) | old name : delta_epi_mat
Delta_lflf = 1.39     # Delay between the ligulation of the flag leaf and flowering (phyllochronic units) | old name : delta_ligflagleaf_flo


# Organ final dimensions

## Internode final length

NENC = 98
shp_I_Maxwell = "squared" # Possibilities are: "linear","squared","Homogenous", "Linear", "ExpIncrease", "ExpDecrease"
shp_I_Gigant_Maxwell = "ExpIncrease"
shp_I_Darwinkel_Maxwell = "ExpIncrease"
shp_I_Soissons = "squared"

N_I_el_Maxwell = 5
N_I_el_Soissons = 5

### Linear formalism
inc_I_Maxwell = 3.48
inc_I_Soissons = 4.5

### Power formalism
a_I_L_Maxwell = -0.93
a_I_L_Gigant_Maxwell = -0.93
a_I_L_Soissons = 0.79
b_I_L_Maxwell = -0.04
b_I_L_Gigant_Maxwell = -0.04
b_I_L_Soissons = -0.29

## Sheath final length
a_S_L_Maxwell = 0.6919
a_S_L_Gigant_Maxwell = 0.6919
a_S_L_Soissons = 0.6857
b_S_L_Maxwell = -2.6953
b_S_L_Gigant_Maxwell = -2.6953
b_S_L_Soissons = -2.16

## Blade final length
l_c = 0.5                                               #length of the coleoptil at the emergence                    | old name : coleoptil_length
L_B_1_Maxwell = 7
L_B_1_Soissons = 7

s_B_1_Maxwell = 0.8
s_B_1_Soissons = 0.5

L_B_max_Maxwell = 17.4
L_B_max_Soissons = 22.4

N_B_r_Maxwell = 2
N_B_r_Soissons = 1

s_B_f_Maxwell = 0.8
s_B_f_Soissons = 0.92


## Blade width
b_B_w_Maxwell = -0.3
b_B_w_Soissons = -0.4
a_B_w_Maxwell = 0.099
a_B_w_Soissons = 0.097

## Fixed dimensions (ear, peduncle, etc.)

d_I_Maxwell = 0.38
d_I_Soissons = 0.2
d_P_Maxwell = 0.25
d_P_Soissons = 0.3
L_P_Maxwell = 22.58
L_P_Soissons = 19.8
d_S_Maxwell = 0.4
d_S_Soissons = 0.32
d_E_Maxwell = 0.4
d_E_Soissons = 0.65
L_E_Maxwell = 7.93
L_E_Soissons = 7.38

var_register_geometry = []

for geno in crop_genotype:
  var_register_geometry.append("shp_I_"+geno)
  var_register_geometry.append("N_I_el_"+geno)
  var_register_geometry.append("inc_I_"+geno)
  var_register_geometry.append("a_I_L_"+geno)
  var_register_geometry.append("b_I_L_"+geno)
  var_register_geometry.append("a_S_L_"+geno)
  var_register_geometry.append("b_S_L_"+geno)
  var_register_geometry.append("L_B_1_"+geno)
  var_register_geometry.append("s_B_1_"+geno)
  var_register_geometry.append("N_B_r_"+geno)
  var_register_geometry.append("s_B_f_"+geno)
  var_register_geometry.append("b_B_w_"+geno)
  var_register_geometry.append("d_I_"+geno)
  var_register_geometry.append("d_P_"+geno)
  var_register_geometry.append("L_P_"+geno)
  var_register_geometry.append("d_S_"+geno)
  var_register_geometry.append("d_E_"+geno)
  var_register_geometry.append("L_E_"+geno)

for key, value, in params.iteritems():
  if key in var_register_geometry:
    exec(key+"=value")

shp_I = {"Maxwell" : shp_I_Maxwell, "Gigant_Maxwell" : shp_I_Gigant_Maxwell, "Darwinkel_Maxwell" : shp_I_Darwinkel_Maxwell, "Soissons" : shp_I_Soissons} # Shape of the function to determine internode final length
N_I_el = {"Maxwell" : N_I_el_Maxwell, "Gigant_Maxwell" :N_I_el_Maxwell , "Darwinkel_Maxwell" : N_I_el_Maxwell, "Soissons" : N_I_el_Soissons } # Number of elongated internodes                               | old name : NENL
inc_I = {"Maxwell" :inc_I_Maxwell , "Gigant_Maxwell" :inc_I_Maxwell , "Darwinkel_Maxwell" :inc_I_Maxwell , "Soissons" : inc_I_Soissons}
a_I_L = {"Maxwell" : a_I_L_Maxwell , "Gigant_Maxwell" : a_I_L_Gigant_Maxwell, "Darwinkel_Maxwell" :a_I_L_Maxwell , "Soissons" :a_I_L_Soissons} #Coefficient for internode final length                | old name : a_internode_squ
b_I_L = {"Maxwell" : b_I_L_Maxwell, "Gigant_Maxwell" :b_I_L_Gigant_Maxwell , "Darwinkel_Maxwell" : b_I_L_Maxwell, "Soissons" : b_I_L_Soissons} #Coefficient for internode final length                | old name : b_internode_squ
a_S_L = {"Maxwell" : a_S_L_Maxwell, "Darwinkel_Maxwell" : a_S_L_Maxwell, "Gigant_Maxwell" : a_S_L_Gigant_Maxwell, "Soissons" : a_S_L_Soissons} # Coefficient for sheath final length                     | old name : a_sheath_length
b_S_L = {"Maxwell" : b_S_L_Maxwell,  "Darwinkel_Maxwell" : b_S_L_Maxwell, "Gigant_Maxwell" : b_S_L_Gigant_Maxwell,"Soissons" : b_S_L_Soissons} # Coefficient for sheath final length (cm)                 | old name : b_sheath_length
L_B_1 = {"Maxwell" : L_B_1_Maxwell, "Darwinkel_Maxwell" : L_B_1_Maxwell, "Gigant_Maxwell" : L_B_1_Maxwell, "Soissons" : L_B_1_Soissons} # Final length of the first blade of each axis (cm)             | old name : first_blade_length
s_B_1 = {"Maxwell" : s_B_1_Maxwell,  "Darwinkel_Maxwell" :s_B_1_Maxwell , "Gigant_Maxwell" : s_B_1_Maxwell,"Soissons" : s_B_1_Soissons} # Final length increment between two successive leaves (bef FT) | old name : incr_Bl
N_B_r = {"Maxwell" : N_B_r_Maxwell, "Darwinkel_Maxwell" : N_B_r_Maxwell, "Gigant_Maxwell" : N_B_r_Maxwell, "Soissons" :N_B_r_Soissons} # Number of higher leaves with are smaller than the previous    | old name : nbf_reduce
s_B_f = {"Maxwell" : s_B_f_Maxwell, "Darwinkel_Maxwell" :s_B_f_Maxwell , "Gigant_Maxwell" : s_B_f_Maxwell, "Soissons" : s_B_f_Soissons} # Reduction factor of blade final length w 2 succ leaves        | old name : ratio_flag_blade
b_B_w = {"Maxwell" : b_B_w_Maxwell, "Darwinkel_Maxwell" : b_B_w_Maxwell, "Gigant_Maxwell" : b_B_w_Maxwell, "Soissons" : b_B_w_Soissons} # Coefficient for blade width (cm)                          | old name : b_blade_width
d_I = {"Maxwell" : d_I_Maxwell, "Darwinkel_Maxwell" : d_I_Maxwell, "Gigant_Maxwell" : d_I_Maxwell, "Soissons" : d_I_Soissons} # Diameter of the internode  (cm)                                   | old name : internode_diameter
d_P = {"Maxwell" : d_P_Maxwell, "Darwinkel_Maxwell" : d_P_Maxwell, "Gigant_Maxwell" : d_P_Maxwell, "Soissons" : d_P_Soissons} # Diameter of the peduncle (cm)                                     | old name : peduncle_diameter
L_P = {"Maxwell" :L_P_Maxwell , "Darwinkel_Maxwell" : L_P_Maxwell, "Gigant_Maxwell" :L_P_Maxwell , "Soissons" :L_P_Soissons} # Final length of the peduncle (cm)                                | old name : peduncle_length
d_S = {"Maxwell" : d_S_Maxwell, "Darwinkel_Maxwell" : d_S_Maxwell, "Gigant_Maxwell" : d_S_Maxwell, "Soissons" : d_S_Soissons} # Diameter of the sheath (cm)                                   | old name : sheath_diameter
d_E = {"Maxwell" : d_E_Maxwell, "Darwinkel_Maxwell" :d_E_Maxwell , "Gigant_Maxwell" : d_E_Maxwell, "Soissons" : d_E_Soissons} # Diameter of the ear (cm)                                         | old name : ear_diameter
L_E = {"Maxwell" :L_E_Maxwell , "Darwinkel_Maxwell" : L_E_Maxwell, "Gigant_Maxwell" : L_E_Maxwell, "Soissons" : L_E_Soissons} # Final length of the ear (cm)                                     | old name : ear_final_length

for geno in crop_genotype:
  shp_I[geno] = eval("shp_I_"+geno)
  N_I_el[geno] = eval("N_I_el_"+geno)
  inc_I[geno] = eval("inc_I_"+geno)
  a_I_L[geno] = eval("a_I_L_"+geno)
  b_I_L[geno] = eval("b_I_L_"+geno)
  a_S_L[geno] = eval("a_S_L_"+geno)
  b_S_L[geno] = eval("b_S_L_"+geno)
  L_B_1[geno] = eval("L_B_1_"+geno)
  s_B_1[geno] = eval("s_B_1_"+geno)
  N_B_r[geno] = eval("N_B_r_"+geno)
  s_B_f[geno] = eval("s_B_f_"+geno)
  b_B_w[geno] = eval("b_B_w_"+geno)
  d_I[geno] = eval("d_I_"+geno)
  d_P[geno] = eval("d_P_"+geno)
  L_P[geno] = eval("L_P_"+geno)
  d_S[geno] = eval("d_S_"+geno)
  d_E[geno] = eval("d_E_"+geno)
  L_E[geno] = eval("L_E_"+geno)
  
# Organ death
# All these parameters are calibrated in order to fit on experimental datas of Mariem Abichou (cv Maxwell) and Jessica Bertheloot (cv Soissons)
n0_sen_Maxwell = 4.75
n0_sen_Soissons =  4.91
n0_sen_Caphorn = 4.76
n1_sen_Maxwell =3.31
n1_sen_Soissons = 3.3
n1_sen_Caphorn = 3.56
n2_sen_Maxwell = 4.5
n2_sen_Soissons =  4.35
n2_sen_Caphorn = 5.19
n3_sen_Maxwell = 0
n3_sen_Soissons = 0
n3_sen_Caphorn = 0

t0_sen_Maxwell = 468
t0_sen_Soissons = 468
t0_sen_Caphorn = 382
t1_sen_Maxwell = 691
t1_sen_Soissons = 691
t1_sen_Caphorn = 671
t2_sen_Maxwell = 1131
t2_sen_Soissons = 959
t2_sen_Caphorn = 1050
t3_sen_Maxwell = 2000
t3_sen_Soissons = 1850
t3_sen_Caphorn = 1900


var_register_death = []

for geno in crop_genotype:
  var_register_death.append("n0_sen_"+geno)
  var_register_death.append("n1_sen_"+geno)
  var_register_death.append("n2_sen_"+geno)
  var_register_death.append("n3_sen_"+geno)
  var_register_death.append("t0_sen_"+geno)
  var_register_death.append("t1_sen_"+geno)
  var_register_death.append("t2_sen_"+geno)
  var_register_death.append("t3_sen_"+geno)

for key, value, in params.iteritems():
  if key in var_register_death:
    exec(key+"=value")

n0_sen = {"Maxwell" : n0_sen_Maxwell,  "Darwinkel_Maxwell" :n0_sen_Maxwell , "Gigant_Maxwell" :n0_sen_Maxwell ,"Soissons" :n0_sen_Soissons, "Caphorn" : n0_sen_Caphorn} # Haun stage of the beginning of the first phase of blade senescence
n1_sen = {"Maxwell" : n1_sen_Maxwell,  "Darwinkel_Maxwell" : n1_sen_Maxwell, "Gigant_Maxwell" : n1_sen_Maxwell,"Soissons" : n1_sen_Soissons, "Caphorn" : n1_sen_Caphorn} # Number of green blades at the end of the first phase of blade senescence
n2_sen = {"Maxwell" : n2_sen_Maxwell,  "Darwinkel_Maxwell" : n2_sen_Maxwell, "Gigant_Maxwell" : n2_sen_Maxwell,"Soissons" :n2_sen_Soissons, "Caphorn" : n2_sen_Caphorn} # Number of green blades at the end of the second phase of blade senescence (only for tillers)
n3_sen = {"Maxwell" :n3_sen_Maxwell , "Darwinkel_Maxwell" : n3_sen_Maxwell, "Gigant_Maxwell" : n3_sen_Maxwell, "Soissons" : n3_sen_Soissons, "Caphorn" :n3_sen_Caphorn } # Number of green blades at the end of blade senescence
t0_sen = {"Maxwell" : t0_sen_Maxwell,  "Darwinkel_Maxwell" : t0_sen_Maxwell, "Gigant_Maxwell" : t0_sen_Maxwell,"Soissons" :t0_sen_Soissons , "Caphorn" :t0_sen_Caphorn } # Date of the beginning of the blade senescence
t1_sen = {"Maxwell" :t1_sen_Maxwell,  "Darwinkel_Maxwell" : t1_sen_Maxwell, "Gigant_Maxwell" : t1_sen_Maxwell,"Soissons" :t1_sen_Soissons, "Caphorn" :t1_sen_Caphorn } # Date of the end of the first phase of blade senescence
t2_sen = {"Maxwell" : t2_sen_Maxwell, "Darwinkel_Maxwell" : t2_sen_Maxwell, "Gigant_Maxwell" : t2_sen_Maxwell, "Soissons" :t2_sen_Soissons , "Caphorn" : t2_sen_Caphorn} # Date of the second phase of blade senescence (only for tillers)
t3_sen = {"Maxwell" : t3_sen_Maxwell,  "Darwinkel_Maxwell" : t3_sen_Maxwell, "Gigant_Maxwell" : t3_sen_Maxwell,"Soissons" : t3_sen_Soissons, "Caphorn" : t3_sen_Caphorn} # Date of the end of blade senescence

for geno in crop_genotype:
  n0_sen[geno] = eval("n0_sen_"+geno)
  n1_sen[geno] = eval("n1_sen_"+geno)
  n2_sen[geno] = eval("n2_sen_"+geno)
  n3_sen[geno] = eval("n3_sen_"+geno)
  t0_sen[geno] = eval("t0_sen_"+geno)
  t1_sen[geno] = eval("t1_sen_"+geno)
  t2_sen[geno] = eval("t2_sen_"+geno)
  t3_sen[geno] = eval("t3_sen_"+geno)

  

Delta_flsp = 100 #Thermal time delay between the senescence of the flag blade and the beginning of peduncle senescence (en degree-days) | old name : delta_senflagleaf_to_senped


# Plant geometry
Phi_zen_B_Maxwell = 10        # Angle between blade inclination and the stem | old name : bl_incl_shift
Phi_zen_B_Lely = 10        # Angle between blade inclination and the stem | old name : bl_incl_shift
Phi_zen_B_Soissons = 10        # Angle between blade inclination and the stem | old name : bl_incl_shift
Phi_zen_B_Renan = 10        # Angle between blade inclination and the stem | old name : bl_incl_shift
Phi_zen_B_Gigant_Maxwell = 10        # Angle between blade inclination and the stem | old name : bl_incl_shift
Phi_zen_B_Darwinkel_Maxwell = 10        # Angle between blade inclination and the stem | old name : bl_incl_shift
Phi_zen_B_Caphorn = 10        # Angle between blade inclination and the stem | old name : bl_incl_shift
Phi_zen_B_Apache = 10        # Angle between blade inclination and the stem | old name : bl_incl_shift
Phi_zen_B_A208 = 10        # Angle between blade inclination and the stem | old name : bl_incl_shift
Phi_zen_B_A210 = 10        # Angle between blade inclination and the stem | old name : bl_incl_shift
Phi_zen_B_F236 = 10        # Angle between blade inclination and the stem | old name : bl_incl_shift
Phi_zen_B_A398 = 10        # Angle between blade inclination and the stem | old name : bl_incl_shift

Phi_azi_B = 185       # Angle between the azimuth of two consecutive blades | old name : bl_azi_shift
Phi_zen_T = 0         # Angle between the zenith of two consecutive tillers  | old name : till_zen_shift
Phi_azi_T = 40        # Angle between the azimuth of two consecutive tillers | old name : till_azi_shift

Phi_zen_E = 0         # Angle between ear inclination and the stem | old name : ear_zen_shift
Phi_azi_S = 0         # Angle between seed azimuth and X axis | old name : seed_azi_shift
Phi_zen_S = 0         # Angle between seed inclination and the stem | old name : seed_zen_shift

# Hazard parameters

# hazard_driver dictionnary will trigger if necessary hazard in different cases:
# if hazard == False : hazard parameter value = 0, if hazard == True, hazard parameter value is set at the value of the parameter

y_position_hazard = int(hazard_driver["plant_xy"]) * 2

if crop_ccptn == "Mesh_for_nplants" or crop_ccptn == "Darwinkel_original":
  x_position_hazard = int(hazard_driver["plant_xy"]) * 2
else:
  x_position_hazard = int(hazard_driver["plant_xy"]) * 3

z_position_hazard = int(hazard_driver["plant_xy"]) * 0

blade_incl_hazard = int(hazard_driver["organ"]) * 5
blade_azi_hazard = int(hazard_driver["organ"]) * 20

till_zen_hazard = int(hazard_driver["axis"]) * 7
till_azi_hazard = int(hazard_driver["axis"]) * 90

plant_azi_hazard = int(hazard_driver["plant_azi"]) * 360


## SELF-ORGANIZED TILLERING RULES
##################################

# Cessation of tillering
GAI_c_Maxwell = 0.59
GAI_c_Soissons = 0.78
GAI_c_Lely = 0.59
GAI_c_Darwinkel_Maxwell = 0.35
GAI_c_Gigant_Maxwell = 0.35
GAI_c_Renan = 0.59
GAI_c_Apache = 0.59
GAI_c_Caphorn = 0.59
GAI_c_A208 = 0.59
GAI_c_A210 = 0.59
GAI_c_F236 = 0.59
GAI_c_A398 = 0.59

var_registerGAI = ["GAI_c_Soissons","GAI_c_Maxwell", "GAI_c_Darwinkel_Maxwell", "GAI_c_Gigant_Maxwell","GAI_c_Lely","GAI_c_Darwinkel_Maxwell","GAI_c_Gigant_Maxwell","GAI_c_Renan","GAI_c_Apache","GAI_c_Caphorn","GAI_c_A208","GAI_c_A210","GAI_c_F236","GAI_c_A398"]

for geno in crop_genotype:
  var_registerGAI.append("GAI_c_"+geno)

for key, value, in params.iteritems():
  if key in var_registerGAI:
    exec(key+"=value")

GAI_c = {"Maxwell" : GAI_c_Maxwell,  "Darwinkel_Maxwell" : GAI_c_Darwinkel_Maxwell, "Gigant_Maxwell" : GAI_c_Gigant_Maxwell,"Soissons" : GAI_c_Soissons, "Lely" : GAI_c_Lely,"Darwinkel_Maxwell" : GAI_c_Darwinkel_Maxwell,"Gigant_Maxwell" : GAI_c_Gigant_Maxwell,"Renan" : GAI_c_Renan,"Apache" : GAI_c_Apache,"Caphorn" : GAI_c_Caphorn,"A208" : GAI_c_A208,"A210" : GAI_c_A210,"F236" : GAI_c_F236,"A398" : GAI_c_A398} # Green Area Index threshold above which tillering of a plant stops

for geno in crop_genotype:
  GAI_c[geno] = eval("GAI_c_"+geno)

dGAIp = 1			# Maximal range of plant detection (meter)
L_b_S = 2      # Buried length of the first sheath (in cm) | old name : L_burried


var_registerdGAIp = ["dGAIp"]

for key, value, in params.iteritems():
  if key in var_registerdGAIp:
    exec(key+"=value")



# Tiller death
t_beg_reg_Maxwell = 4.2
t_beg_reg_Darwinkel_Maxwell = 3.2
t_beg_reg_Gigant_Maxwell = 3.2
t_beg_reg_Soissons = 4.2

var_registerT_beg = ["t_beg_reg_Soissons","t_beg_reg_Maxwell","t_beg_reg_Darwinkel_Maxwell","t_beg_reg_Gigant_Maxwell"]

for geno in crop_genotype:
  var_registerT_beg.append("t_beg_reg_"+geno)

for key, value, in params.iteritems():
  if key in var_registerT_beg:
    exec(key+"=value")

t_beg_reg = {"Maxwell" : t_beg_reg_Maxwell,  "Darwinkel_Maxwell" : t_beg_reg_Darwinkel_Maxwell, "Gigant_Maxwell" : t_beg_reg_Gigant_Maxwell,"Soissons" : t_beg_reg_Soissons} # Date of potentiel beginning of the regression (in Haun Stage unit)

for geno in crop_genotype:
  t_beg_reg[geno] = eval("t_beg_reg_"+geno)

PAR_t_Maxwell = 280000
PAR_t_Soissons = 150000
PAR_t_Lely = 280000
PAR_t_Darwinkel_Maxwell = 100000
PAR_t_Gigant_Maxwell = 100000
PAR_t_Renan = 280000
PAR_t_Apache = 280000
PAR_t_Caphorn = 280000
PAR_t_A208 = 280000
PAR_t_A210 = 280000
PAR_t_F236 = 280000
PAR_t_A398 = 280000

var_registerPARt = ["PAR_t_Soissons","PAR_t_Maxwell", "PAR_t_Darwinkel_Maxwell", "PAR_t_Gigant_Maxwell","PAR_t_Lely","PAR_t_Darwinkel_Maxwell","PAR_t_Gigant_Maxwell","PAR_t_Renan","PAR_t_Apache","PAR_t_Caphorn","PAR_t_A208","PAR_t_A210","PAR_t_F236","PAR_t_A398"]

for geno in crop_genotype:
  var_registerPARt.append("PAR_t_"+geno)


for key, value, in params.iteritems():
  if key in var_registerPARt:
    exec(key+"=value")

PAR_t = {"Maxwell" : PAR_t_Maxwell,  "Darwinkel_Maxwell" : PAR_t_Darwinkel_Maxwell, "Gigant_Maxwell" : PAR_t_Gigant_Maxwell,"Soissons" : PAR_t_Soissons, "Lely" : PAR_t_Lely,"Darwinkel_Maxwell" : PAR_t_Darwinkel_Maxwell,"Gigant_Maxwell" : PAR_t_Gigant_Maxwell,"Renan" : PAR_t_Renan,"Apache" : PAR_t_Apache,"Caphorn" : PAR_t_Caphorn,"A208" : PAR_t_A208,"A210" : PAR_t_A210,"F236" : PAR_t_F236,"A398" : PAR_t_A398}  # PAR threshold below which a tiller don't survive | old name : PARseuil

for geno in crop_genotype:
  PAR_t[geno] = eval("PAR_t_"+geno)


Delta_l = 100     #Duration of radiation integration to determine the survival of a tiller (degree-day) | old name : ray_integration


Delta_SGtC = 600                   # Thermal time between the moment a tiller stops growing and its entire removal | old name : delta_stopgr_to_cut
Delta_SGtR = 200                   # Thermal time between the moment a tiller stops growing and the beginning of the reverse growth of leaves | old name : delta_stopgr_to_reg
Delta_Reg = Delta_SGtC - Delta_SGtR # | old name : duration_reg

Delta_prot_Maxwell = 75
Delta_prot_Darwinkel_Maxwell = 25
Delta_prot_Gigant_Maxwell = 25
Delta_prot_Soissons = 50

var_registerDelta_prot = ["Delta_prot_Soissons","Delta_prot_Maxwell", "Delta_prot_Darwinkel_Maxwell", "Delta_prot_Gigant_Maxwell"]

for geno in crop_genotype:
  var_registerDelta_prot.append("Delta_prot_"+geno)

for key, value, in params.iteritems():
  if key in var_registerDelta_prot:
    exec(key+"=value")

Delta_prot = {"Maxwell" : Delta_prot_Maxwell,  "Darwinkel_Maxwell" : Delta_prot_Darwinkel_Maxwell, "Gigant_Maxwell" : Delta_prot_Gigant_Maxwell,"Soissons" : Delta_prot_Soissons}                    # Thermal time interval during which two tillers of the same plant cannot die | old name : duration_plant_protection

for geno in crop_genotype:
  Delta_prot[geno] = eval("Delta_prot_"+geno)


# Parametres communs
#######################

sky_type    = "soc" # Parameter for type of sky : 'soc' (overcast sky) or 'clear_sky'
turtle_sectors = 16 # Parameter for the get_turtle_light function (number of sectors in the sky). Choices are : 1, 6, 16 or 46
add_sun = 0 # trigger the addition of one sun position per hour in the light sources

var_registerTurtleSky = ["sky_type", "turtle_sectors", "add_sun"]
for key, value, in params.iteritems():
  if key in var_registerTurtleSky:
    exec(key+"=value")

PAS               = 24

n_days_fitness_before = 30
n_days_fitness_after = 0
a_fitness = 1
b_fitness = 0

var_register_fitness = ["n_days_fitness_before", "n_days_fitness_after", "a_fitness", "b_fitness"]

for key, value, in params.iteritems():
  if key in var_register_fitness:
    exec(key+"=value")


##

nbj               = 25 + 300                             # Duree de la simulation
time_step         = 1.                                   # Temps qui s'ecoule   (jour)
Tbase             = 0.                                 


liste_talles = [(1,2),(1,3)]#,(1,4),(1,5),(1,6),(1,7)]



####################
#### VARIABLES  ####
####################

### Globales ###
################

Initialization_count       = 0
nb_voisins_glob            = {}
elapsed_time               = 0                      # Elapsed time since the beginning of the simulation (in days)
num_j                      = 0                      # Current day
Tempcum                    = 0                      # Cumulated temperature since the beginning of the simulation (degree-days)
_Tempcum                   = 0
DOY                        = 0
date_current_day           = 0
#current_PAR                = 0
Temperature                = 0
earliest_plant             = 0
latest_plant               = 0
#datetime.date(2000, 1, 1)

### Locales ###
###############

##### Identification #####
n_init                     = 0                       # Number of the targeted phytomer
tiller_init                = (1,)                    # Number of the targeted tiller
num_plante                 = 1                       # Number of the targeted plant

##### Variables communes #####
age_init                   = 0                       # Age de l'organe (j)
time_init                  = 0                       # Temps ecoule depuis l'initiation du dernier phytomere  (j)
nb_j_init                  = 0
sumtemp_init               = 0                       # Somme des temp�ratures accumul�es par l'organe depuis son initiation

##### Dimensions d'organes #####
length_init                = 0.0                    # Taille de l'organe (cm)
width_init                 = 0.0                 # Largeur du limbe (en cm)
diameter_init              = 0.5                      # Diametre de l'organe (en cm)
final_length_init          = 0.0                    # Taille finale de l'organe
PAR_init                   = 0                       # Quantite de Par recu par l'organe


##### Cinetique de croissance #####
date_emerg                 = 10000                   # Date d'emergence de l'organe en temps "global"
gr_init                    = 0

##### Vernalisation #####
vern_rate_init             = 0
vern_prog_init             = 0
Ln_pot_init                = Lmax
Ln_app_init                = Lmax
Ln_final_init              = 100
Lmin_pot_init              = 0

##### Stades de d�veloppement #####
test_res= [True]
real_ts0 = [float("inf")]


### PANDAS DATAFRAME ###

global GAI_dico_df
if CARIBU_state == "enabled":
  GAI_dico_df = {"Init_flag":[], "Elapsed_time":[],"Temp_cum":[],"DOY":[],"Genotype":[],"Num_plante":[],"Surface_plante":[],"Surface_visible":[],"Surface_sol":[],"GAI_tot":[],"GAI_center":[],"GAI_prox":[],"Position":[], "Weakest_axis":[],"PAR_weakest_axis":[]}
if CARIBU_state == "disabled":
  GAI_dico_df = {"Init_flag":[], "Elapsed_time":[],"Temp_cum":[],"DOY":[],"Genotype":[],"Num_plante":[],"Surface_plante":[],"Surface_visible":[],"Surface_sol":[],"GAI_tot":[],"GAI_center":[],"GAI_prox":[],"Position":[]}

global Apex_Sirius_dico_df
Apex_Sirius_dico_df = {"Elapsed_time" :[],"Temperature" :[],"Temp_cum" :[], "Daylength" :[], "Num_plante" :[], "Genotype" :[], "PN"  :[], "LN"  :[], "Sumtemp"   :[], "Vern_rate" :[], "Vern_prog" :[], "Vern_flag" :[], "Debut_ppd_flag" :[], "Fin_ppd_flag" :[], "Ln_pot" :[], "Var_L_min" :[],"Ln_app" :[], "Ln_final" :[]}

global Apex_dico_df
Apex_dico_df = {"Elapsed_time" :[], "Temperature" :[], "Temp_cum" :[], "Time_count" :[], "Sum_temp" :[], "Current_PAR" :[], "Num_plante":[],  "Genotype" :[], "Num_talle" :[], "Num_cohorte":[], "Nb_phyto_emi" :[], "Nb_emerged_leaf" :[], "Transiflo_flag" :[], "STOP_init_flag" :[], "Transiflo_DOY" :[],"Ln_final" :[]}

global Apex_R_dico_df
Apex_R_dico_df = {"Elapsed_time" :[], "DOY" : [], "Temperature" :[], "Temp_cum" :[], "Sum_temp" :[], "Num_plante":[], "Genotype" :[], "Num_cohorte":[], "Ln_final":[], "Num_talle" :[], "Date_epiaison" :[], "Epi_DOY" :[], "Date_de_flo" :[], "Mont_flag" :[], "Mont_DOY":[], "Flo_flag" :[], "Flo_DOY" :[], "Death_flag" :[], "Date_de_maturite" : [], "Mat_DOY" : []}

global Blade_df
Blade_dico_df = {"Elapsed_time" :[], "Temp_cum" :[], "Temperature" :[], "Num_plante" :[], "Genotype" :[], "Num_talle" :[], "Num_cohorte" :[], "Num_rang" :[], "Blade_sumtemp" :[], "Blade_width" :[], "Blade_length" :[], "Blade_visible_length" :[], "Blade_final_length" :[], "Blade_visible_surface" :[], "Blade_surface" :[], "Blade_PAR" :[], "Senesc_flag" :[], "Photosynthetic" :[], "Form_factor" : []}

global Internode_dico_df
Internode_dico_df = {"Elapsed_time" :[],  "Temp_cum" :[],  "Temperature" :[],  "Num_plante" :[],  "Genotype" :[],  "Num_talle" :[], "Num_cohorte":[], "Num_rang" :[], "Internode_length" :[],  "Internode_final_length" :[], "Internode_surface" :[], "Internode_PAR" : [], "Photosynthetic" :[]}

global Peduncle_dico_df
Peduncle_dico_df = {"Elapsed_time" :[],  "Temp_cum" :[],  "Temperature" :[],  "Num_plante" :[],  "Genotype" :[],  "Num_talle" :[], "Num_cohorte":[], "Num_rang" :[],"Sum_temp" :[], "Peduncle_length" : [], "Peduncle_final_length" : [], "Peduncle_surface" : [], "Peduncle_PAR" : [], "Photosynthetic" :[]}

global Sheath_dico_df
Sheath_dico_df = {"Elapsed_time" :[],  "Temp_cum" :[],  "Temperature" :[],  "Num_plante" :[],  "Genotype" :[],  "Num_talle" :[] ,"Num_cohorte":[], "Num_rang" :[],"Sheath_sumtemp" :[] ,"Sheath_diameter" :[], "Sheath_length" :[],  "Sheath_final_length" :[], "Sheath_surface" :[], "Sheath_PAR" : [], "Photosynthetic" :[]}

global Ear_dico_df
Ear_dico_df = {"Elapsed_time":[], "Temp_cum" :[], "Num_plante" :[], "Genotype":[], "Num_talle" :[],  "Ear_sumtemp"  :[], "Ear_length" :[], "Ear_surface":[], "Ear_PAR":[], "Photosynthetic" :[], "Emerged" : []}

global Proba_dico_df
Proba_dico_df = {"Elapsed_time":[], "Temperature":[], "Temp_cum":[], "Num_plante":[], "Genotype":[], "Num_talle":[], "Num_rang":[], "Sumtemp":[], "GAI_prox":[], "P_debourr":[]}

global Peraxes_dico_df
Peraxes_dico_df = {"Init_flag":[], "Elapsed_time":[], "DOY":[], "Temperature":[], "Temp_cum":[], "Num_plante":[], "Num_talle":[], "Sheath_max":[], "Collar_height":[], "Dead_collar_height":[], "Delta_H":[], "Visible_leaves_surface":[], "Visible_surface":[], "Stop_growth_flag" : [], "Leaf_contrib_to_GAI" : [], "Stem_contrib_to_GAI" : [], "Ear_contrib_to_GAI" : [], "Peduncle_contrib_to_GAI" : []}

global Debug_PAR_dico_df
Debug_PAR_dico_df = {"Elapsed_time":[], "Temp_cum":[], "Num_plante":[], "Num_talle":[], "Organ_PAR":[], "Organ_type":[], "Num_organe":[], "Organ_surface":[], "Ei":[], "id": [], "tiller_surface": [],"Inc_PAR": []}

global PAR_per_organ
PAR_per_organ = {"Num_plante":[], "Num_talle":[], "Organ_PAR":[], "Organ_surface":[], "tiller_surface": []}


if write_output_file["PAR_per_axes"] or write_output_file["Fitness"] == True:
  global PAR_per_axes_dico
  PAR_per_axes_dico = {"Elapsed_time":[], "DOY":[], "Temperature":[], "Temp_cum":[], "Num_plante":[], "Num_talle":[], "Sum_PAR":[], "Inc_PAR":[], "Abs_int_PAR":[]}


#######################
###### TABLEAUX #######
#######################

initialization_Flag           = {}
final_blade_length            = {}              # Dico regroupant les tailles finales de tous les limbes par individu, par talle, par phytomere
current_sheath_length         = {}              # Dico regroupant les tailles actuelles de gaines par individu, par talle, par phytomere
dead_sheath_length            = {}
current_internode_length      = {}              # Dico regroupant les tailles actuelles de gaines par individu, par talle, par phytomere
dico_voisins                  = {}              # Dico regroupant la liste de totues les plantes voisines en fonction de la "portee" du voisinage
plant_census                  = []
border_plants                 = []
surface_sol                   = {}              # Dico regroupant la surface de sol inherente a chaque individu
GAI_prox                      = {}              # Dico regroupant le GAI d'un sous-peuplement constitue d'une plante cible ainsi que de ses voisins
LNfinal                       = {}              #TODO Attention ce dico est obsolete il faudra le virer pour epurer un peu ce beau code
tiller_death                  = {}              # Dico recensant toutes les talles qui doivent mourir (teste a Montaison)
tiller_death_now              = {}              # Dico listant toutes les talles qui sont sensees mourir a CE PAS DE TEMPS PRECIS
date_emission                 = {}
dico_stades                   = {}
photoperiode                  = []
leaf_emergence                = {}
dead_tillers                  = {}
PAR_intercepted               = {}
axis_census                   = {}
Dse_heterogeneous             = {}
t_beg_reg_ind_Tht             = {}
MSLn_app                      = {}
first_leaf_phase2             = {}
genotype_map                  = {}
plant_map                     = {}


#Scheduling of events

tiller_2_ts0                  = {(1,1):0,(1,2):0,(1,3):0,(1,4):0,(1,5):0,(1,6):0,(1,7):0}
cohort_2_ts0                  = {1: 633, 2: 693, 3: 761, 4: 709, 5: 847, 6: 855, 7: 864, 8: 693, 9: 693, 10: 633, 11: 573}

dico_PAR                      = {}              # Dico dans lequel on stocke les informations de PAR capt� par organe
dico_PAR["Blade"]             = {}                          # On formatte le dico pour qu'il capte des infos concernant les blades
dico_PAR["Sheath"]            = {}
dico_PAR["Internode"]         = {}
dico_PAR["Peduncle"]          = {}
dico_PAR["Ear"]               = {}

#### Pour le calcul du GAI ##########
tiller_surface                    = {}
surface_plante                    = {}              # Dico regroupant les surfaces actuelles de plantes par individu
surface_plante_visible            = {}

Sh_max                            = {}
Hcol_max                          = {}
Hcol_dead                         = {}
delta_H                           = {}
#####################################

future_dead_axes              = {}
dico_PAR_per_axis             = {}
dico_cut_fantom_axes          = {}
dico_cut_dead_blades          = {}
young_tiller                  = {}
youngest_axis                 = {}

# For tillers regression
liste_tal                     = {}
axis_order                    = {}
weaker_order                  = {}
weakers_pos                   = {}
weakers                       = {}
youngest_axes                 = {}
weakest_axis                  = {}
plant_shield_indicator        = {}

# Random :
positions                     = {}
hazard_dict_organ             = {}
hazard_dict_axis              = {}
hazard_dict_plant             = {}


color=[0,4,5,7,8,6,9,10,11]                     # Colors to differentiate the different genotypes
organ_type = ["Blade", "Internode", "Sheath","Peduncle", "Ear"]
#organ_type = ["Blade","Sheath","Internode","Peduncle"]

##################################################################################


####################################################################################
############################# DEFINITION DE FONCTION ###############################
####################################################################################

# Physical calculation of daylength
def duree_du_jour(lat, J):
  delta = asin(0.4*sin((2*pi*(J-80))/365))
  lat = (pi * lat)/180
  return 24*(1-(acos(tan(delta)*tan(lat)))/pi)

# Manipulation of meteo table in case of direct radiation
def read_meteo(dico_meteo,start_day,start_hour,PAS):
  val1 = 0
  val2 = 0
  for i in range(PAS):
    mykey = (start_day,start_hour+i)
    #print mykey, i, start_hour
    val1 += dico_meteo[mykey][0]
    val2 += dico_meteo[mykey][1]
  # val1 = RG ; val2 = Rd/Rg
  return val1,val2/PAS


#SCHEDULING OF EVENTS
########################

def tiller_ln_final(cohort, Ln_final_MS):
    """ Final number of leaves on a tiller
    Parameters
    ----------
    cohort (int) : Cohort number of the tiller
    Ln_final_MS (int) : Final number of leaves on the main stem of the bearing plant

    Returns
    -------
    Final number of leaves on the tiller (int)
    """
    lnf_till = Ln_final_MS - cohort - 1
    return lnf_till

# Determining the cohort number of the axis
def cohort_number(tiller):
  return (len(tiller) + sum(tiller)) - 3

def synchrone_correspondance(tiller):
  if tiller == (1,):
    return 1
  else:
    l = 0
    n = 1
    for l in range(1,len(tiller)):
      new_tiller = tiller[0:len(tiller)-1]
      new_n = tiller[-1] + 2 + (n-1)
      #print new_tiller, new_n
      tiller = new_tiller
      n = new_n
      l += 1
      if tiller == (1,):
        return n

def Haun_Stage(Tht, tiller, Ln_final, phyllo, Dse, DelayTipToHS):
  tHS0 = Dse + (synchrone_correspondance(tiller) - 1) * phyllo + DelayTipToHS
  tHSf = tHS0 + Ln_final * phyllo
  if Tht <= tHS0:
    return 0
  elif tHS0 < Tht < tHSf:
    a = 1/phyllo
    b = - (1/phyllo) * tHS0
    return a * Tht + b
  else:
    return Ln_final


def SSI_MS(Tht, Ln_final, phyllo, n0, n1, n3, ts1, ts3, Dse, DelayTipToHS):
  tHS0 = Dse + (synchrone_correspondance((1,)) - 1) * phyllo + DelayTipToHS
  real_ts0 = (Dse + DelayTipToHS) + n0 * phyllo
  real_ts1 = ts1 + (Dse + DelayTipToHS)
  real_ts3 = ts3 + (Dse + DelayTipToHS)
  npot1 = (real_ts1 - tHS0)/phyllo
  s1 = npot1 - n1
  #Premiere phase de senescence
  if Tht < tHS0:
    a = 0
    b = 0
  elif tHS0 <= Tht < real_ts1:
    s0 = 0 #Nombre de feuilles mortes � t0
    a = (s1 - s0)/(real_ts1 - real_ts0)
    b = s1 - a*real_ts1
  #Deuxieme phase de senescence
  elif real_ts1 <= Tht <= real_ts3:
    s3 = Ln_final                #Nombre de feuilles mortes � t2
    a = (s3 - s1)/(real_ts3 - real_ts1)
    b = s3 - a*real_ts3
  elif Tht > real_ts3:
    a = 0
    b = Ln_final
  return max(0,((a * Tht) + b))

def Green_Leaves(Haun_Stage, SSI):
  return Haun_Stage - SSI

Ln_final_dict = {(1,) : 11, (1,1):9, (1,2):8, (1,3):7, (1,4):7, (1,5):6, (1,4):5, (1,6):5, (1,7):4}

def junction_test(Tht, tiller, Ln_final, phyllo, n0, n1, n3, ts1, ts3, Dse, DelayTipToHS, test_res):
  HS_BM = Haun_Stage(Tht, (1,), Ln_final, phyllo, Dse, DelayTipToHS)
  HS_tiller = Haun_Stage(Tht, tiller, Ln_final, phyllo, Dse, DelayTipToHS)
  GL_BM = Green_Leaves(Haun_Stage(Tht, (1,), Ln_final, phyllo, Dse, DelayTipToHS), SSI_MS(Tht, Ln_final, phyllo, n0, n1, n3, ts1, ts3, Dse, DelayTipToHS))
  if HS_BM != 0 and HS_tiller >= GL_BM:
    return False
  else:
    return True

def define_ts0(Tht, tiller, Ln_final, phyllo, n1, n3, ts1, ts3, Dse, DelayTipToHS, test_res):
  if test_res[0]== True:
    test_res[0] = junction_test(Tht, tiller, Ln_final, phyllo, n0, n1, n3, ts1, ts3, Dse, DelayTipToHS, test_res[0])
    real_ts0[0] = Tht
  tiller_2_ts0[tiller] = real_ts0[0]

def SSI_tiller(Tht, tiller, Ln_final, phyllo, n1, n3, ts1, ts3, Dse, DelayTipToHS, test_res):
  tHS0 = Dse + (synchrone_correspondance(tiller) - 1) * phyllo + DelayTipToHS
  define_ts0(Tht, tiller, Ln_final, phyllo, n1, n3, ts1, ts3, Dse, DelayTipToHS, test_res)
  real_ts1 = ts1 + (Dse + DelayTipToHS)
  real_ts3 = ts3 + (Dse + DelayTipToHS)
  npot1 = (real_ts1 - tHS0)/phyllo
  s1 = npot1 - n1
  #Premiere phase de senescence
  if Tht < tHS0:
    a = 0
    b = 0
  elif tHS0 <= Tht < real_ts1:
    s0 = 0 #Number of dead leaves at t0
    a = (s1 - s0)/(real_ts1 - real_ts0[0])
    b = s1 - a*real_ts1
  #Deuxieme phase de senescence
  elif real_ts1 <= Tht <= real_ts3:
    s3 = Ln_final                #Number of dead leaves at t2
    a = (s3 - s1)/(real_ts3 - real_ts1)
    b = s3 - a*real_ts3
  elif Tht > real_ts3:
    a = 0
    b = Ln_final
  #~ print "Tht : ", Tht,"Ts0 : ", real_ts0[0]
  return max(0,((a * Tht) + b))

# Emergence date
def leaf_emerg_date(n, tiller, geno, num_plante):
  if tiller == (1,):
    return Dse_heterogeneous[num_plante] + (n-1) * phyll_adjust(geno)
  l = 0
  for l in range(1,len(tiller)):
    new_tiller = tiller[0:len(tiller)-1]
    new_n = tiller[-1] + 2 + (n-1)
    tiller = new_tiller
    n = new_n
    l += 1
    if tiller == (1,):
      return Dse_heterogeneous[num_plante] + (n-1) * phyll_adjust(geno)


def leaves_senesc_date_main_stem(n, Ln_final, phyllo, n0, n1, n3, ts1, ts3, Dse, DelayTipToHS):
  tHS0 = Dse + (synchrone_correspondance((1,)) - 1) * phyllo + DelayTipToHS
  real_ts0 = (Dse + DelayTipToHS) + n0 * phyllo
  real_ts1 = (Dse + DelayTipToHS) + ts1
  real_ts3 = (Dse + DelayTipToHS) + ts3
  npot1 = (real_ts1 - tHS0)/phyllo
  s1 = npot1 - n1
  #Premiere phase de senescence
  if 0 <= n < s1:
    s0 = 0 #Nombre de feuilles mortes � t0
    a = (real_ts1 - real_ts0)/(s1 - s0)
    b = real_ts1 - a*s1
    return (a * n) + b
  elif s1 <= n <= Ln_final:
    s3 = Ln_final                #Nombre de feuilles mortes � t2
    a = (real_ts3 - real_ts1)/(s3 - s1)
    b = real_ts3 - a*s3
    return (a * n) + b

#def leaves_senesc_date_tiller(n, tiller, Ln_final, phyllo, n0, n1, n3, ts1, ts3, Dse, DelayTipToHS):
#  tHS0 = Dse + (synchrone_correspondance(tiller) - 1) * phyllo + DelayTipToHS
#  real_ts0 = cohort_2_ts0[cohort_number(tiller)]
#  real_ts1 = (Dse + DelayTipToHS) + ts1
#  real_ts3 = (Dse + DelayTipToHS) + ts3
#  npot1 = (real_ts1 - tHS0)/phyllo
#  s1 = npot1 - n1
#  #Premiere phase de senescence
#  if 0 <= n < s1:
#    s0 = 0 #Nombre de feuilles mortes � t0
#    a = (real_ts1 - real_ts0)/(s1 - s0)
#    b = real_ts1 - a*s1
#    return (a * n) + b
#  elif s1 <= n <= Ln_final:
#    s3 = Ln_final                #Nombre de feuilles mortes � t2
#    a = (real_ts3 - real_ts1)/(s3 - s1)
#    b = real_ts3 - a*s3
#    return (a * n) + b

def leaves_senesc_date_tiller(n, tiller, Ln_final, phyllo, n0, n1, n2, n3, ts1,ts2, ts3, Dse, DelayTipToHS):
  tHS0 = Dse + (synchrone_correspondance(tiller) - 1) * phyllo + DelayTipToHS
  real_ts0 = cohort_2_ts0[cohort_number(tiller)]
  real_ts1 = (Dse + DelayTipToHS) + ts1
  real_ts2 = (Dse + DelayTipToHS) + ts2
  real_ts3 = (Dse + DelayTipToHS) + ts3
  npot1 = (real_ts1 - tHS0)/phyllo
  npot2 = (real_ts2 - tHS0)/phyllo
  s1 = npot1 - n1
  s2 = npot2 - n2
  #Premiere phase de senescence
  if 0 <= n < s1:
    s0 = 0 #Nombre de feuilles mortes � t0
    a = (real_ts1 - real_ts0)/(s1 - s0)
    b = real_ts1 - a*s1
    return (a * n) + b
  elif s1 <= n < s2:
    a = (real_ts2 - real_ts1)/(s2 - s1)
    b = real_ts2 - a*s2
    return (a * n) + b
  elif s2 <= n <= Ln_final:
    s3 = Ln_final                #Nombre de feuilles mortes � t2
    a = (real_ts3 - real_ts2)/(s3 - s2)
    b = real_ts2 - a*s2
    return (a * n) + b



# Number of emerged leaves
def nb_emerged_leaves(tempcum, tiller, geno, Ln_final):
  if tiller == (1,):
    return min(max(0,((tempcum - Dse_heterogeneous[num_plante])/phyll_adjust(geno)) + 1), Ln_final)
  else:
    tiller_emergence_date = leaf_emerg_date(1, tiller, geno, num_plante)
    return min(max(0,((tempcum - tiller_emergence_date)/phyll_adjust(geno)) + 1), Ln_final)


# Senescence date (in case of knowing the final leaf number of the axis)

#def date_senescence(n, Ln_final, phyllo, n0, n1, n3, t0, t1, t3):
#  n1pot = (t1 - t0)/phyllo
#
#  #Premiere phase de senescence
#  if n <= (n1pot + (n0 - n1)):
#    s0 = 0 #Nombre de feuilles mortes � t0
#    s1 = n1pot + (n0 - n1) #Nombre de feuilles mortes � t1
#
#    a = (t1 - t0) /(s1 - s0)
#    b = ((t0*s1) - (t1*s0))/(s1 - s0)
#
#  #Deuxieme phase de senescence
#  elif (n1pot + (n0 - n1)) < n <= Ln_final:
#    s1 = n1pot + (n0 - n1) #Nombre de feuilles mortes � t1
#    s2 = Ln_final                #Nombre de feuilles mortes � t2
#
#    a = (t3 - t1)/(s2 - s1)
#    b = ((t1*s2) - (t3*s1))/(s2 - s1)
#
#  return a * (n) + b


# Temporary date of senescence (in case of NOT knowing the final leaf number on the axis)
def date_senescence_fake(n, t0):
  #calcul interm�diaires pour la premi�re phase de s�nescence
  #print "/|\ Date de s�nescence douteuse !"
  return t0 + n/0.015

# Setting a delay of floral transition of tiller according to the cohort number
def transiflo_shift(tiller, geno):
  cohort_num = cohort_number(tiller)
  if cohort_num == 1:
    return 10
  elif cohort_num > 1:
    return (cohort_num-1) * (Psi_FT * Pls[geno])
  else:
    return 0


# TILLERING
##############


# Estimating the probability of emergence of a bud (taking into account the GAI)
def proba_debourr(tiller, GAIprox, geno, n, Ln_final):
  if tiller == (1,1):
    return P_CT[geno]
  else:
    NENC = (Ln_final - N_I_el[geno])+1 # NENC is the rank of the first elongated internode
    #NENC = (Ln_final - 4)
    if GAIprox < GAI_c[geno]:
      if n < NENC:
        return P_T[geno]
      else:
        return 0
    else:
      return 0



# ORGAN FINAL DIMENSIONS
###########################

# Determining a specific blade final length
def FindBlade_length(num_plante, tiller):
  n = 1
  l = 0
  for l in range(1,len(tiller)):
    new_tiller = tiller[0:len(tiller)-1]
    new_n = tiller[-1] + 2 + (n-1)
    tiller = new_tiller
    n = new_n
    l += 1
    if tiller == (1,):
      return final_blade_length[num_plante][tiller][n-1]


### BLADE LENGTH ###

#### USE IT ####


# Calculating the increment during the juvenile phase specifying the length of penultimate bladeTaking into account the effect of temperature)
def incr_repro_penlt_leaf(lg_first_leaf_ph2, lg_penultimate_leaf, nb_leaves_axis):
  remaining_length_to_grow = lg_penultimate_leaf - lg_first_leaf_ph2
  incr = remaining_length_to_grow/nb_leaves_axis
  return incr

def flag_leaf_blade_length(geno, lg_previous_leaf, ratio):
  return lg_previous_leaf * ratio


### SHEATH LENGTH ###

# Calculating sheath final length (from data of blade final length)

def sheath_length(bld_lgt, a_sh_length, b_sh_length):
  return (a_sh_length * bld_lgt) + b_sh_length

### BLADE WIDTH ###

# Calculating blade maximal width (from data of blade final length)
def blade_width(bld_lgt, a_bl_width, b_bl_width):
  return (a_bl_width * bld_lgt) + b_bl_width

### INTERNODE FINAL LENGTH ###

# Finding the possible range of a and b values, for a given height and NENL
# these a and b values are used when shape = 'ExpIncrease' or shape = 'ExpDecrease'

def getRangeHeightPar(ranh,ranNENL,rangeno,leaf_nf):        
    l_ear = L_E[rangeno]
    l_short = 0            
    #DETERMINING A'S RANGE, setting a < 0
    alpha_a = (ranNENL+1)**2*(ranNENL+2)*( (ranNENL+2) - (2/3)*(2*ranNENL+3) ) # n�gatif si NENL=5
    beta_a = -4 * (ranNENL+1) * ( l_ear - ranh + l_short*(leaf_nf - ranNENL) ) # est positif quand h > l_ear
    if alpha_a >= 0:
        print 'NENL =  ' + str(ranNENL) + '    unextected NENL?'
        if alpha_a == 0:
            print 'a range problem : division by 0'
            posrange_a = [np.nan, np.nan]
        elif beta_a*alpha_a > 0:
            print 'a range problem : square root of negative number'
            posrange_a = [np.nan, np.nan]
        elif beta_a*alpha_a < 0:
            val_a = -sqrt(-beta_a / alpha_a )            
            posrange_a = [-100, val_a] # would actually be -infinity
    elif alpha_a < 0:
        if beta_a*alpha_a > 0:
            print 'a range problem : square root of negative number'
            posrange_a = [np.nan, np.nan]
        elif beta_a*alpha_a < 0:
            val_a = -sqrt(-beta_a / alpha_a ) # val_a is the value for which delta = 0, a < 0            
            posrange_a = [val_a,0]    
    # DETERMINIG B'S RANGE, setting b > 0    
    alpha_b = (ranNENL+1)**2*(ranNENL+2)*( (ranNENL+2) - (2/3)*(2*ranNENL+3) ) 
    beta_b = (-2/3)*(ranNENL+1)*(ranNENL+2)*(2*ranNENL+3)*( l_ear - ranh + l_short*(leaf_nf - ranNENL) ) 
    if alpha_b >= 0: 
        print 'NENL =  ' + str(ranNENL) + '    unextected NENL?'
        if alpha_b == 0:
            print 'b range problem : division by 0'
            posrange_b = [np.nan, np.nan]
        elif beta_b*alpha_b > 0:
            print 'b range problem : square root of negative number'
            posrange_b = [np.nan, np.nan]
        elif beta_b*alpha_b < 0:
            val_b = -sqrt(-beta_b / alpha_b )            
            posrange_b = [val_b, 100] # would actually be +infinity         
    elif alpha_b < 0: # is what we have for NENL = 5    
        if beta_b*alpha_b > 0:
            print 'b range problem : square root of negative number'
            posrange_b = [np.nan, np.nan]
        elif beta_b*alpha_b < 0:
            val_b = sqrt(-beta_b / alpha_b ) # val_b is the value for which delta = 0, b > 0       
            posrange_b = [0, val_b]        
    return [posrange_a, posrange_b]

# provides a, b or NENL, knowing all of the other parameters and the height (the parameter we want is ppar_of_interest, and we set it as nan)
# used when when shape = 'ExpIncrease' or shape = 'ExpDecrease'

def getHeightPar(ph, pgeno, pa, pb, pNENL, leaf_nf, ppar_of_interest):
    l_ear = L_E[pgeno] 
    l_short = 0    
    if ppar_of_interest == 'a': # knowing h, b and NENL
        p_0 = (pNENL+1)*(pNENL+2)*(2*pNENL+3)*(1/6)
        p_1 = (pNENL+1)*(pNENL+2)*pb
        p_2 = l_ear + (leaf_nf - pNENL)*l_short + (pNENL+1)*pb**2 - ph
        p = [p_0, p_1, p_2]
        roots = np.roots(p)
        return ['a', roots]        
    if ppar_of_interest == 'b': # knowing h, a and NENL
        p_0 = (pNENL+1)
        p_1 = (pNENL+1)*(pNENL+2)*pa
        p_2 = l_ear + (leaf_nf - pNENL)*l_short + (pNENL+1)*(pNENL+2)*(pa**2)*(2*pNENL + 3)*(1/6 ) - ph
        p = [p_0, p_1, p_2]
        roots = np.roots(p)
        return ['b', roots]    
    if ppar_of_interest == 'NENL': # knowing h, a and b 
        p_0 = (pa**2)/3
        p_1 = pa*pb + (pa**2)*(3/2)
        p_2 = pb**2 - l_short + 3*pa*pb + (pa**2)*(13/6)
        p_3 = l_ear + leaf_nf*l_short + pb**2 + 2*pa*pb + pa**2 - ph
        p = [p_0, p_1, p_2, p_3]
        roots = np.roots(p)[np.isreal(np.roots(p))]
        return ['NENL', abs(roots)]


# Calculating internode final length fixing the number of elongated internodes

def EN_fin_length(n, Ln_final, geno, shape, PlHeight):
  n0 = Ln_final - N_I_el[geno]
  rel_rank = n - n0
  l_ear = L_E[geno]
  l_ped = L_P[geno]
  l_short = 0
  if n <= n0:
    return 0.00
  else:
    if shape == "linear":
      if n > Ln_final:
        return L_P[geno]
      else:
        return inc_I[geno] * n - (inc_I[geno] * n0)
    elif shape == "squared":
      a_squ = a_I_L[geno]
      b_squ = b_I_L[geno]
      return (a_squ * rel_rank + b_squ)**2
    elif shape == "Homogenous":
      intH = ( PlHeight - l_ear - l_short*(Ln_final - N_I_el[geno]) ) / (N_I_el[geno] + 1)
      return intH
    elif shape == "Linear":
      if geno == 'Maxwell':
        l_ped = l_ped*(1-(90-PlHeight)*1.3/100)
      if geno == 'Soissons':
        l_ped = l_ped*(1-(110-PlHeight)/100)
      aL = ( l_ped - ( PlHeight - l_ear - l_short*(Ln_final - N_I_el[geno]) )/(N_I_el[geno] + 1) ) * (2/N_I_el[geno])
      bL = l_ped - aL*(N_I_el[geno]+1)
      intL = aL*rel_rank + bL
      return intL
    elif shape == "ExpIncrease":
      aEi = getRangeHeightPar(ranh=PlHeight, ranNENL=N_I_el[geno] ,rangeno=geno, leaf_nf=Ln_final)[0][0]*(3/6)        
      bEi = min(getHeightPar(ph=PlHeight, pgeno=geno, pa=aEi, pb=np.nan, pNENL=N_I_el[geno], leaf_nf=Ln_final, ppar_of_interest='b')[1])  
      intEi = ( aEi*rel_rank + bEi)**2
      return intEi
    elif shape == "ExpDecrease":
      aEd = getRangeHeightPar(ranh=PlHeight, ranNENL=N_I_el[geno] ,rangeno=geno, leaf_nf=Ln_final)[0][0]*(3/6)        
      bEd = max(getHeightPar(ph=PlHeight, pgeno=geno, pa=aEd, pb=np.nan, pNENL=N_I_el[geno], leaf_nf=Ln_final, ppar_of_interest='b')[1])        
      intEd = (aEd*rel_rank + bEd)**2        
      return intEd


#### PHYLLOTAXY #####

def blade_phyllotaxy(n, tiller, num_plante, NENL, Phi_azi_B, blade_azi_hazard):
  hazard_dict_organ[num_plante][tiller][n]["blade_azimuth"] = Phi_azi_B + random.uniform(-blade_azi_hazard, blade_azi_hazard)


# FUNCTIONS EXTRACTED FROM SIRIUS
####################################

# Calcul de l'impact de la vernalisation au temps t
def vrate(Tt,geno):
  if Tt<Tvermin or Tt>Tvermax:
    Vrate = 0
  elif Tt<= Tverint:
    Vrate = (VAI[geno] * Tt + VBEE[geno])
  else:
    Vrate = (VAI[geno] * Tverint + VBEE[geno]) * ((Tvermax - Tt)/(Tvermax - Tverint))
  return Vrate

# INITIALISATION OF THE MODEL
################################

def plasto_seed(delay_sowing_emergence, nb_p_seed):
  return delay_sowing_emergence/nb_p_seed




# YIELD
##########

# Number of grains produced
def calc_grain_nb(T, PAR):
  nb_epi_msqu = 592
  photothermal_quotient = PAR/T
  grain_nb =  (2600 + 8510 * photothermal_quotient)/nb_epi_msqu
  return grain_nb

def age_phyto_seed(num_phyto, N_p_s, geno):
  return (N_p_s - num_phyto) * Pls[geno]



##########################################################################
#####                EDITING CLASS FOR ORGAN TYPES                   #####
##########################################################################


class Seed:
  def __init__(self, num_plante, geno):
    self.num_plante = num_plante
    self.geno = geno


class Organ_Base:
  def __init__(self, num_plante, geno, tiller, n):
    self.num_plante = num_plante
    self.geno = geno
    self.tiller = tiller
    self.n = n
    self.age = 0
    self.sumtemp = 0
    self.length = 0

class Bud_primord(Organ_Base):
  def __init__(self, num_plante, geno, tiller, n):
    Organ_Base.__init__(self, num_plante, geno, tiller, n)
    #self.tiller_incl = 0
    self.sumtemp = 0
    self.competent_flag = False

class Bud(Organ_Base):
  def __init__(self, num_plante, geno, tiller, n, time):
    Organ_Base.__init__(self, num_plante, geno, tiller, n)
    self.nb_primord = 0
    self.nb_emerg_leaves = 0
    #self.tiller_incl = 0
    self.emerg = False
    self.Ln_final = Ln_final_init
    self.length = length_init
    self.nb_j = nb_j_init
    self.date_transiflo = -1
    self.date_de_flo = 10000
    self.date_epi = 10000
    self.Tmoy = 0
    self.p_debourr = 0
    self.time = 0
    self.Ln_final = Ln_final_init
    self.STOP = False
    self.transiflo = False

class Bud_R(Organ_Base):
  def __init__(self, num_plante, geno, tiller, n):
    Organ_Base.__init__(self, num_plante, geno, tiller, n)
    self.sumtemp = 0
    self.emerg = False
    self.Tmoy = 0
    self.nb_j = 0
    self.Ln_final = 0

class Apex(Organ_Base):
  def __init__(self, num_plante, geno, tiller, n, time):
    Organ_Base.__init__(self, num_plante, geno, tiller, n)
    self.time = time_init
    self.nb_primord = 0
    self.nb_emerg_leaves = 0
    #self.tiller_incl = 0
    self.vrn = False
    self.til_transiflo_count = 0
    self.exit_vrn = False
    self.vern_rate = vern_rate_init
    self.vern_prog = vern_prog_init
    self.Ln_pot = Ln_pot_init
    self.Ln_app = Ln_app_init
    self.Ln_final = Ln_final_init
    self.var_Lmin = Lmin
    self.transiflo = False
    self.photop_flag = False
    self.debut_ppd = False
    self.pn = 0
    self.ln = 0
    self.STOP_init = False
#
#  def iter_attributes(self):
#    return iter(self.__dict__.values())
class Apex_R(Organ_Base):
  def __init__(self, num_plante, geno, tiller, n):
    Organ_Base.__init__(self, num_plante, geno, tiller, n)
    self.mont = False
    self.exit_mont = False
    self.feuille_mont = 100
    self.flo = False
    self.epi = False
    self.date_de_flo = 10000
    self.date_epi = 10000
    self.mat = False
    self.date_mat = 10000
    self.death_flag = False
    self.Ln_final = 0


class CutPointBud():
  def __init__(self, num_plante, geno, tiller):
    self.num_plante = num_plante
    self.geno = geno
    self.tiller = tiller
    self.cut = False
    self.reg_count = 0
    self.count = 0
    self.azimuth = 0
    self.zenith = 0

class CutPointBlade():
  def __init__(self, num_plante, geno, tiller, n):
    self.num_plante = num_plante
    self.geno = geno
    self.tiller = tiller
    self.n = n
    self.cut = False

class Internode(Organ_Base):
  def __init__(self, num_plante, geno, tiller, n):
    Organ_Base.__init__(self, num_plante, geno, tiller, n)
    self.age = 0
    self.croiss = True
    self.length = length_init
    self.visible_length = 0
    self.Ln_final = Ln_final_init
    self.final_length = final_length_init
    self.gr = gr_init
    self.PAR = PAR_init
    self.diameter = diameter_init
    self.area = 0
    self.state = "not_prohibited"
    self.shift = 0
    self.photosynthetic = True

class Leaf(Organ_Base):
  def __init__(self, num_plante, geno, tiller, n):
    Organ_Base.__init__(self, num_plante, geno, tiller, n)
    self.date_emerg = 1000
    self.transiflo_flag = False

class Blade(Organ_Base):
  def __init__(self, num_plante, geno, tiller, n):
    Organ_Base.__init__(self, num_plante, geno, tiller, n)
    self.PAR = PAR_init
    self.width = width_init
    self.area = 0
    self.senesc_flag = False
    self.photosynthetic = True
    self.visible_length = 0
    self.visible_area = 0
    self.reg_count = 0

class Sheath(Organ_Base):
  def __init__(self, num_plante, geno, tiller, n):
    Organ_Base.__init__(self, num_plante, geno, tiller, n)
    self.diameter = diameter_init
    self.area = 0
    self.visible_length = 0
    self.PAR = PAR_init
    self.photosynthetic = True

class Ear(Organ_Base):
  def __init__(self, num_plante, geno, tiller, n):
    Organ_Base.__init__(self, num_plante, geno, tiller, n)
    self.age = 0
    self.PAR = 0
    self.length = 0
    self.visible_length = 0
    self.emerged = False
    self.sumtemp = 0
    self.photosynthetic = True

class Peduncle(Organ_Base):
  def __init__(self, num_plante, geno, tiller, n):
    Organ_Base.__init__(self, num_plante, geno, tiller, n)
    self.age = 0
    self.sumtemp = 0
    self.length = 0
    self.visible_length = 0
    self.diameter = 0
    self.area = 0
    self.PAR = 0
    self.photosynthetic = True



#################################################################################################################
mod_to_remove = ["[","]", "%", "CutPointBlade", "@M","CutPointBud"]


#### SAVING THE PARAMETERS


location           = experimental_conditions[expe_related]["location"]
meteo           = experimental_conditions[expe_related]["meteo"]
year               = experimental_conditions[expe_related]["year"]                            #s'il s'agit d'un fichier meteo moyenne, year = 1901
sowing_date        = experimental_conditions[expe_related]["sowing_date"]

dist_inter_rang = experimental_conditions[expe_related]["dist_inter_rang"]

var_register2 = ["location", "meteo"]

for key, value, in params.iteritems():
  if key in var_register2:
    exec(key+"=value")

latitude           = dico_latitudes[location]

##########################
# LIRE UN FICHIER METEO  #
##########################

meteo_dF = pd.read_csv(pj(inputdir, "meteo", meteo + ".csv"), header=9, sep=";")

var_register = ["crop_ccptn","sowing_date","year","latitude","nbj","densite","nb_rang","nb_plantes","area_targeted","geno_nb","SIRIUS_state","infinity_GAIp","nb_azimuth","nb_zenith","dist_inter_rang","N_p_s","l_c","L_b_S","Psi_FT","param_Ln_final","Tbase","Tvermin","Tverint","Tvermax","Lmax","Lmin","Ldecr","Lincr","phyllo_decr","phyllo_incr","DLsat","Delta_b","dGAIp","Delta_l","Delta_c_GN","Delta_hf","Delta_hm","Delta_lflf","Delta_flsp","Delta_SGtR","Delta_SGtC","ED_I","ED_B","ED_FB","ED_S","Phi_zen_B_Maxwell","Phi_zen_B_Lely","Phi_zen_B_Soissons","Phi_zen_B_Renan","Phi_zen_B_Gigant_Maxwell","Phi_zen_B_Darwinkel_Maxwell","Phi_zen_B_Caphorn","Phi_zen_B_Apache","Phi_zen_B_A208","Phi_zen_B_A210","Phi_zen_B_F236","Phi_zen_B_A398","Phi_azi_B","Phi_zen_T","Phi_azi_T","Phi_zen_E","Phi_azi_S","Phi_zen_S","y_position_hazard","x_position_hazard","z_position_hazard","blade_incl_hazard","blade_azi_hazard","till_zen_hazard","till_azi_hazard","Phl_Soissons","Phl_Maxwell","VAI_Soissons","VAI_Maxwell","VBEE_Soissons","VBEE_Maxwell","SLDL_Soissons","SLDL_Maxwell","N_I_el_Soissons","N_I_el_Maxwell","s_B_1_Soissons","s_B_1_Maxwell","N_B_r_Soissons","N_B_r_Maxwell","L_B_1_Soissons","L_B_1_Maxwell","L_B_max_Soissons","L_B_max_Maxwell","s_B_f_Soissons","s_B_f_Maxwell","a_B_w_Soissons","a_B_w_Maxwell","b_B_w_Soissons","b_B_w_Maxwell","a_S_L_Soissons","a_S_L_Gigant_Maxwell","a_S_L_Maxwell","b_S_L_Soissons","b_S_L_Gigant_Maxwell","b_S_L_Maxwell","inc_I_Soissons","inc_I_Maxwell","b_I_L_Soissons","b_I_L_Maxwell","b_I_L_Gigant_Maxwell","a_I_L_Soissons","a_I_L_MAxwell","a_I_L_Gigant_Maxwell","d_I_Soissons","d_I_Maxwell","L_P_Soissons","L_P_Maxwell","d_P_Soissons","d_P_Maxwell","d_E_Soissons","d_E_Maxwell","L_E_Soissons","L_E_Maxwell","d_S_Soissons","d_S_Maxwell","n0_sen_Soissons","n0_sen_Maxwell","n1_sen_Soissons","n1_sen_Maxwell","n2_sen_Soissons","n2_sen_Maxwell","n3_sen_Soissons","n3_sen_Maxwell","t0_sen_Soissons","t0_sen_Maxwell","t1_sen_Soissons","t1_sen_Maxwell","t2_sen_Soissons","t2_sen_Maxwell","t3_sen_Soissons","t3_sen_Maxwell","P_CT_Soissons","P_CT_Maxwell","P_T_Soissons","P_T_Maxwell","nb_plt_utiles","dist_border_x","dist_border_y","nb_plt_temp"]


for geno in crop_genotype:
  var_register.append("L_B_max_"+geno)
  var_register.append("a_B_w_"+geno)
  var_register.append("Phi_zen_B_"+geno)
  var_register.append("Phl_"+geno)

print 'params'
print params

for key, value, in params.iteritems():
  if key in var_register:
    print key, value
    exec(key+"=value")

nb_rang = int(nb_rang)

random.seed(rep)

L_B_max = {"Maxwell" : L_B_max_Maxwell, "Darwinkel_Maxwell" : L_B_max_Maxwell, "Gigant_Maxwell" : L_B_max_Maxwell, "Soissons" : L_B_max_Soissons} # Final length of the longest blade each the axis (cm)        | old name : length_penultimate_blade

a_B_w = {"Maxwell" : a_B_w_Maxwell, "Darwinkel_Maxwell" : a_B_w_Maxwell, "Gigant_Maxwell" : a_B_w_Maxwell, "Soissons" : a_B_w_Soissons} # Coefficient for blade width                              | old name : a_blade_width

Phi_zen_B = {"Maxwell" : Phi_zen_B_Maxwell ,"Lely" : Phi_zen_B_Lely,"Soissons" : Phi_zen_B_Soissons,"Renan" : Phi_zen_B_Renan,"Gigant_Maxwell" : Phi_zen_B_Gigant_Maxwell,"Darwinkel_Maxwell" : Phi_zen_B_Darwinkel_Maxwell,"Caphorn" : Phi_zen_B_Caphorn,"Apache" : Phi_zen_B_Apache,"A208" : Phi_zen_B_A208,"A210" : Phi_zen_B_A210,"F236" : Phi_zen_B_F236,"A398" : Phi_zen_B_A398}


tab_top = datetime.date(int(year)-1,9,1)													      # On definit la date du debut du fichier
double_finger = datetime.date(int(year)-1,1,1)                               #Premier janvier
sowing_DOY=(sowing_date-double_finger).days     # DOY du semis

#################################################################################################################
### LE TEMPS QUI PASSE ###
#delta_date = sowing_date - tab_top		                        # Calcule le nombre de jours entre la date de semis et le debut du fichier
#delta_date.days								                            # Retourne le nombre de jour en integer (c'est l'indice dans le tableau )
date_current_day = sowing_date + datetime.timedelta(elapsed_time) 	        # Date a laquelle nous nous trouvons pour un elapsed_time donne
DOY = int(date_current_day.strftime('%j'))


Phl = {"Maxwell" : Phl_Maxwell, "Darwinkel_Maxwell" : Phl_Maxwell,"Gigant_Maxwell":Phl_Maxwell, "Soissons" : Phl_Soissons, "Renan" : Phl_Renan}  # Differentes valeurs issues de recalibrations He : 104      #Ly : 113.5    #Lecarpentier :

for geno in crop_genotype:
  L_B_max[geno] = eval("L_B_max_"+geno)
  a_B_w[geno] = eval("a_B_w_"+geno)
  Phi_zen_B[geno] = eval("Phi_zen_B_"+geno)
  Phl[geno] = eval("Phl_"+geno)
  
  
Pls_Maxwell = phyll_adjust("Maxwell")/2
Pls_Soissons = phyll_adjust("Soissons")/2
Pls_Renan = phyll_adjust("Renan")/2

DelayTipToHS_Maxwell = 0.4125 * phyll_adjust("Maxwell")
DelayTipToHS_Soissons = 0.4125 * phyll_adjust("Soissons")


for geno in crop_genotype:
  exec("Pls_"+geno+ "= phyll_adjust(geno)/2")
  exec("DelayTipToHS_"+geno+ "= 0.4125 * phyll_adjust(geno)")


var_register3 = ["DelayTipToHS_Soissons","DelayTipToHS_Maxwell","Pls_Soissons","Pls_Maxwell"]

for geno in range (0,len(crop_genotype)):
  var_register3.append("Pls_"+crop_genotype[geno])
  var_register3.append("DelayTipToHS_"+crop_genotype[geno])

for key, value, in params.iteritems():
  if key in var_register3:
    exec(key+"=value")

Pls = {"Maxwell" : Pls_Maxwell, "Darwinkel_Maxwell" : Pls_Maxwell,"Gigant_Maxwell":Pls_Maxwell, "Soissons" : Pls_Soissons, "Renan" : Pls_Renan}

for geno in crop_genotype:
  Pls[geno] = eval("Pls_"+geno)
 
DelayTipToHS = {"Maxwell" : DelayTipToHS_Maxwell, "Darwinkel_Maxwell" : DelayTipToHS_Maxwell, "Gigant_Maxwell" : DelayTipToHS_Maxwell, "Soissons" : DelayTipToHS_Soissons}

for geno in crop_genotype:
  DelayTipToHS[geno] = eval("DelayTipToHS_"+geno)
 
crop_scheme = design_crop_classical()
if crop_ccptn == "classical":
  crop_scheme = design_crop_classical(nb_plt_temp, nb_rang, densite, dist_inter_rang)
  print crop_scheme

elif crop_ccptn == "neo_Darwinkel":
  crop_scheme = adapting_crop_area(densite,area_min, area_max, dist_inter_rang, opt_plt_nb)
  print crop_scheme

elif crop_ccptn == "Darwinkel_original": 
  area = area_targeted
  crop_scheme = design_crop_Darwinkel(area, densite)
  print "dist_border_x : ",dist_border_x, "dist_border_y : ",dist_border_y

elif crop_ccptn == "Mesh_for_nplants":
  crop_scheme = design_crop_mesh_for_nplants(densite, nb_plt_utiles , dist_border_x , dist_border_y)
  print "dist_border_x : ",dist_border_x, "dist_border_y : ",dist_border_y


plant_census, border_plants = central_and_border_plants(crop_scheme, dist_border_x, dist_border_y)
maillage, plant_map = plant_disposition(crop_scheme)
nb_voisins_glob, dico_voisins = set_neighbour(maillage, crop_scheme, dGAIp, infinity_GAIp)
nb_rangs = crop_scheme["nb_rang"] #RESTE !
nb_plantes = crop_scheme["nplant_peupl"]
dist_inter_rang = crop_scheme["dist_inter_rang"]
dist_intra_rang = crop_scheme["dist_intra_rang"]
dx = crop_scheme["dx"]
dy = crop_scheme["dy"]


if genotype_proportion == "equal":
  genotype_list = crop_genotype*int(ceil(crop_scheme["nplant_peupl"]/geno_nb))
  random.shuffle(genotype_list)

elif genotype_proportion == "genetics":
  genotype_list = [crop_genotype[0]]*int(genotype_numbers[0])
  for geno in range(1, geno_nb):
    genotype_list += [crop_genotype[geno]]*int(genotype_numbers[geno])
  random.shuffle(genotype_list)

# Create a unique ID to the simulation according to a specific combination of parameters value
global folder_name
global out_dir


folder_name = ID
out_dir = pj(data_dir, "output")



print "ID : ",ID

try:
  if not os.path.exists(out_dir):
    os.mkdir(out_dir)

  if not os.path.exists(pj(out_dir, folder_name)):
    os.mkdir(pj(out_dir, folder_name))
  if write_output_file["Lscene"]:
    if not os.path.exists(pj(out_dir, folder_name, "Lscenes")):
      os.mkdir(pj(out_dir, folder_name, "Lscenes"))
  
  if write_output_file["Lstring"]:
    if not os.path.exists(pj(out_dir, folder_name, "Lstrings")):
      os.mkdir(pj(out_dir, folder_name, "Lstrings"))
  
except Exception, e:
  print(e)
  pass


def Start(lstring):
  useGroup(1)
  current_PAR = 0
  
  #TODO ici c'est sale, il faut mettre �a dans Seed
  # Initialisation of the dictionnary regrouping Ts0 dates for each tiller
  #for tiller in tiller_2_ts0.keys():
  #  print "tiller : ",tiller, "tiller_2_ts0 : ", tiller_2_ts0
  #  for Tht in range(1, 3000):
  #    define_ts0(Tht, tiller, Ln_final_dict[tiller], phyllo_Maxwell, n1_Maxwell, n3_Maxwell, t1_sen_Maxwell, t3_sen_Maxwell, Dse_mean_Maxwell, DelayTipToHS*phyllo_Maxwell, test_res)
  #  test_res= [True]
  
  #for axis in tiller_2_ts0.keys():
  #  cohort_2_ts0[cohort_number(axis)] = tiller_2_ts0[axis]


#res_sky = 0

def StartEach(lstring):
  #if getIterationNb() % 2 == 0:
  frameDisplay(True)
  
  global Temperature
  global elapsed_time
  global Tempcum
  global date_current_day
  global DOY
  elapsed_time += time_step                    #dj = increment de temps en jours
  date_current_day = sowing_date + datetime.timedelta(elapsed_time) 	        # Date a laquelle nous nous trouvons pour un elapsed_time donne
  #mean_temperatures[current_day - tab_top).days]                   # Temperature moyenne du jour apres elapsed time jours passes
  if DOY == 365:
    DOY = 1
  else:
    DOY += 1

  try:
    _current_temperature = meteo_dF[(meteo_dF["year"] == date_current_day.year) & (meteo_dF["month"] == date_current_day.month) & (meteo_dF["day"] == date_current_day.day)]['TM']
    current_temperature = _current_temperature[_current_temperature.last_valid_index()]
  except:
    current_temperature = Temperature

  global current_PAR # Daily integrated Incoming radiation in  micromolPAR.m-2
  try:
    _current_PAR = meteo_dF[(meteo_dF["year"] == date_current_day.year) & (meteo_dF["month"] == date_current_day.month) & (meteo_dF["day"] == date_current_day.day)]['PAR']
    current_PAR = _current_PAR[_current_PAR.last_valid_index()]
  except:
    pass

  Temperature = current_temperature              # Temperature moyenne du jour apres elapsed time jours passes
  Tempcum += max(Tbase,Temperature)
  
  print "date : ", date_current_day, "|", location,"|", "Experiment : ", expe_related,"|", "densite : ", densite,"|", "num_jour : ",elapsed_time,"|", "tempcum : ",int(Tempcum),"|", "DOY : ",DOY,"|", "len : ",len(lstring), "|","T : ", current_temperature,"|", "PAR : ", current_PAR
  #daily_seed = rep + elapsed_time
  #random.seed(daily_seed)


def EndEach(lstring, lscene):

  # CALCUL DU GAI (a partir de la chaine)
  for num_plt in range(1, crop_scheme["nplant_peupl"] + 1):
    Hcol_max[num_plt] = dict.fromkeys(Hcol_max[num_plt].keys(), 0)
    delta_H[num_plt] = dict.fromkeys(delta_H[num_plt].keys(), 0)
    Hcol_dead[num_plt] = dict.fromkeys(Hcol_dead[num_plt].keys(), 0)
  
  global tiller_surface
  global surface_plante_visible
  global surface_plante
  
  tiller_surface = dict.fromkeys(tiller_surface.keys(), 0)
  surface_plante = dict.fromkeys(surface_plante.keys(), 0)
  surface_plante_visible = dict.fromkeys(surface_plante_visible.keys(), 0)
  
  # Computation of GAI
  for org_id in range(len(lstring)):
    org = lstring[org_id]
    if org.name in organ_type:
      if org.name == "Blade" and org[0].photosynthetic == True:
        
        # Former method for the computation of GAI
        surface_plante[org[0].num_plante] += org[0].area
        
        # New method for the computation of GAI (only the visible parts of the leaves)
        if org[0].visible_length > epsilonL:
          tiller_surface[(org[0].num_plante,org[0].tiller)] += org[0].visible_area
        
      if org.name == "Internode":
        if org[0].photosynthetic == True:
          # Hauteur max du collet (par axe)
          Hcol_max[org[0].num_plante][org[0].tiller] += org[0].length
        
        else:
          # Hauteur du col mort
          Hcol_dead[org[0].num_plante][org[0].tiller] += org[0].length
        
      if org.name == "Peduncle" and org[0].photosynthetic == True:
        #  Delta H (Lepi + Lped) - Lgmax)
        delta_H[org[0].num_plante][org[0].tiller] += org[0].length
        
      if org.name == "Ear" and org[0].photosynthetic == True:
        #  Delta H (Lepi + Lped) - Lgmax)
        delta_H[org[0].num_plante][org[0].tiller] += org[0].length
  
  for num_plt in range(1,crop_scheme["nplant_peupl"] + 1):
    for axis in axis_census[num_plt].keys():
    
      #Calculs
      Sh_max_temp = max([Sh_max[num_plt][axis][x] for x in range(0,max(Sh_max[num_plt][axis].keys()) + 1)])
      Sh_dead_max = max([dead_sheath_length[num_plt][axis][x] for x in range(0,max(dead_sheath_length[num_plt][axis].keys()) + 1)])
      Hcol_max[num_plt][axis] = Hcol_max[num_plt][axis] + Sh_max_temp
      Hcol_dead[num_plt][axis] =  Hcol_dead[num_plt][axis] + Sh_dead_max
      delta_H[num_plt][axis] = max(0, delta_H[num_plt][axis] - Sh_max_temp)
      
      #Computation of GAI (adding the contributions of the other parts of the plant)
      Peraxes_dico_df["Visible_leaves_surface"].append(tiller_surface[(num_plt,axis)])
      #TODO : transformer ces formules en fonctions a mettre en amont
      leaf_contrib = tiller_surface[(num_plt,axis)]
      stem_contrib = max(0,(Hcol_max[num_plt][axis] - max(L_b_S,Hcol_dead[num_plt][axis])) * d_S[genotype_map[num_plt]] * pi/2)
      peduncle_contrib = max(0,(delta_H[num_plt][axis] - L_E[genotype_map[num_plt]]) * pi/2 * d_P[genotype_map[num_plt]])
      
      if delta_H[num_plt][axis] <= 0:
        tiller_surface[(num_plt,axis)] = leaf_contrib + stem_contrib
        ear_contrib = 0
      elif delta_H[num_plt][axis] >= L_E[genotype_map[num_plt]]:
        ear_contrib = L_E[genotype_map[num_plt]] * d_E[genotype_map[num_plt]] * pi/2
        tiller_surface[(num_plt,axis)] = leaf_contrib + stem_contrib + ear_contrib + peduncle_contrib
      elif 0 < delta_H[num_plt][axis] < L_E[genotype_map[num_plt]]:
        ear_contrib = (L_E[genotype_map[num_plt]] - delta_H[num_plt][axis]) * d_E[genotype_map[num_plt]] * pi/2
        tiller_surface[(num_plt,axis)] = leaf_contrib + stem_contrib + ear_contrib
      
      
      #Filling the output dictionaries
      if write_output_file["Peraxes"]:
        Peraxes_dico_df["Init_flag"].append(initialization_Flag[num_plt])
        Peraxes_dico_df["Elapsed_time"].append(elapsed_time)
        Peraxes_dico_df["DOY"].append(DOY)
        Peraxes_dico_df["Temperature"].append(Temperature)
        Peraxes_dico_df["Temp_cum"].append(Tempcum)
        Peraxes_dico_df["Num_plante"].append(num_plt)
        Peraxes_dico_df["Num_talle"].append(axis)
        Peraxes_dico_df["Sheath_max"].append(Sh_max_temp)      
        Peraxes_dico_df["Collar_height"].append(Hcol_max[num_plt][axis])
        Peraxes_dico_df["Dead_collar_height"].append(Hcol_dead[num_plt][axis])
        Peraxes_dico_df["Delta_H"].append(delta_H[num_plt][axis])
        Peraxes_dico_df["Visible_surface"].append(tiller_surface[(num_plt,axis)])
        Peraxes_dico_df["Stop_growth_flag"].append(axis_census[num_plt][axis]['Stop_growth_flag'])
        Peraxes_dico_df["Leaf_contrib_to_GAI"].append(leaf_contrib)
        Peraxes_dico_df["Stem_contrib_to_GAI"].append(stem_contrib)
        Peraxes_dico_df["Ear_contrib_to_GAI"].append(ear_contrib)
        Peraxes_dico_df["Peduncle_contrib_to_GAI"].append(peduncle_contrib)
  
#aggregate axes surface per plant
  for key in tiller_surface.keys():
    surface_plante_visible[key[0]] += tiller_surface[key]
  
  # Calcul du GAI de proximite
  for num_plt in range(1,crop_scheme["nplant_peupl"] + 1):
    surface_peupl = 0
    for num_voisin in dico_voisins[num_plt]:
      surface_peupl += surface_plante_visible[num_voisin]
    GAI_prox[num_plt] = surface_peupl/(nb_voisins_glob[0] * (crop_scheme["dist_inter_rang"]*100)*(crop_scheme["dist_intra_rang"] * 100))  # On multiplie par 100 pour une conversion de m_squ � cm_squ
  
  GAI_old = sum(surface_plante.values())/(crop_scheme["nplant_peupl"] * ((crop_scheme["dist_inter_rang"]*100)*(crop_scheme["dist_intra_rang"] * 100)))
  GAI_tot = sum(surface_plante_visible.values())/(crop_scheme["nplant_peupl"] * ((crop_scheme["dist_inter_rang"]*100)*(crop_scheme["dist_intra_rang"] * 100)))
  Surf_center = 0
  for interest_plt in plant_census:
    Surf_center += surface_plante_visible[interest_plt]
  GAI_center = Surf_center/(len(plant_census) * ((crop_scheme["dist_inter_rang"]*100)*(crop_scheme["dist_intra_rang"] * 100)))
  
  
  ##################################
  ##Module de rayonnement : CARIBU #
  ##################################
  
  if write_output_file["Lscene"]:
    if elapsed_time > 40:
      s_save = Scene(lscene)
      s_save.save(pj(out_dir,folder_name, "Lscenes", "lscene-day-"+"%s" % elapsed_time+".bgeom"))
  
  if write_output_file["Lstring"]:
    out_lstring = open(pj(out_dir,folder_name, "Lstrings", "lstring-day-"+"%s" % round(elapsed_time) +".txt"), "w")
    out_lstring.write("%s" % lstring)
  
  #s = Scene(lscene)
  #s.add(lscene)
  #s.save("./lscene-debug.bgeom")
  #print(type(lscene))w<<
  
  ## Pour l'instant on fait QUE du diffus

  if CARIBU_state != "disabled":    #Le module de rayonnement peut �tre activ� ou d�sactiv� {"enabled";"disabled"}
    if type(lscene) != None:
      if len(lscene) > 0:
        if beginning_CARIBU < Tempcum < ending_CARIBU:
          print "The date : ", str(datetime.datetime.now())
          # light = get_light(current_PAR, nb_azimuth, nb_zenith)
          # 46 direction sky
          longi = dico_longitudes[location]
          lat = dico_latitudes[location]
          alt = dico_altitude[location]
          tz = dico_time_zone[location]
          light = get_turtle_light(current_PAR, sky_type=sky_type, turtle_sectors=turtle_sectors, add_sun=bool(add_sun),
                                   curent_date=date_current_day, longitude=longi, latitude=lat, altitude=alt, timezone=tz)
          pattern = domain(crop_scheme)
          c_scene = CaribuScene(scene=lscene, scene_unit="cm", light=light, pattern=pattern)
          res_sky= None
          try:
            raw, res_sky = c_scene.run(simplify=True, infinite = bool(infinity_CARIBU), direct = True, screen_size = CARIBU_screen_res)
          # The outputs are in micromolPAR.m-2 for Ei and Ea, and m2 for area
          # TODO: check these outputs are those expected or should be converted
            if show_caribu_stats:
              caribu_recorder.record(c_scene, raw, show=True)
          except Exception as exception :
            #~ if exception.__class__.__name__ == "CaribuRunError"
            if type(exception).__name__ == "CaribuRunError":
              error_caribu_file = open(pj(out_dir,folder_name, "error_caribu.txt"), "w")
            else:
              error_default_file = open(pj(out_dir,folder_name, "error_default.txt"), "w")
            
            sys.stderr.write(str(exception))
            sys.exit(1)

#          except Exception:
#            print '#'*80
#            print '*'*80
#            print 'ERROR in the run of caribu'
#            print lscene
#            print '*'*80
#            s_save = Scene(lscene)
#            s_save.save("./debug/lscene-day-"+"%s" % elapsed_time+".geom")
#            res_sky = None
          
          if Temperature > 0 and res_sky:
            PAR_per_organ = {"Num_plante": [], "Num_talle": [], "Organ_PAR": [], "Organ_surface": [], "tiller_surface": []}
            for num_plt in axis_census.keys():
              for axis in axis_census[num_plt].keys():
                dico_PAR_per_axis[num_plt][axis][round(Tempcum, 1)] = 0
            for id in res_sky['Ei'].keys():
              #if id not in new_lstring: continue
              new_ = lstring[id]
              if ((new_.name in ("Blade", "Sheath", "Internode", "Peduncle")) or
                 (new_.name == "Ear" and new_[0].emerged)):
                if new_[0].tiller in axis_census[new_[0].num_plante].keys():

                  if (res_sky["Ei"][id] < 0 or new_[0].photosynthetic == False):
                    new_[0].PAR = 0
                  else:
                    new_[0].PAR = res_sky["Ei"][id] * res_sky["area"][id]

                  if (new_.name != "Sheath" and new_[0].photosynthetic == False):
                    new_[0].organ_surface = 0 # Non photosynthetic organs do not count in the tiller surface for the computation of the PARt (except for sheath, because they often hide other photosynthetic organs)
                  else:
                    new_[0].organ_surface = res_sky["area"][id]
                  
                  dico_PAR[new_.name][new_[0].num_plante][new_[0].tiller][new_[0].n] = new_[0].PAR

                  PAR_per_organ["Num_talle"].append(lstring[id][0].tiller)
                  PAR_per_organ["Num_plante"].append(lstring[id][0].num_plante)
                  PAR_per_organ["Organ_surface"].append(lstring[id][0].organ_surface)
                  PAR_per_organ["Organ_PAR"].append(lstring[id][0].PAR)
                  PAR_per_organ["tiller_surface"].append(tiller_surface[(lstring[id][0].num_plante, lstring[id][0].tiller)] * 1e-4)

                  if write_debug_PAR == True:
                    Debug_PAR_dico_df["Ei"].append(res_sky["Ei"][id])
                    Debug_PAR_dico_df["Elapsed_time"].append(elapsed_time)
                    Debug_PAR_dico_df["Temp_cum"].append(Temperature)
                    Debug_PAR_dico_df["Organ_type"].append(lstring[id].name)
                    Debug_PAR_dico_df["Num_talle"].append(lstring[id][0].tiller)
                    Debug_PAR_dico_df["Num_plante"].append(lstring[id][0].num_plante)
                    Debug_PAR_dico_df["Num_organe"].append(lstring[id][0].n)
                    Debug_PAR_dico_df["Organ_surface"].append(lstring[id][0].organ_surface)
                    Debug_PAR_dico_df["Organ_PAR"].append(lstring[id][0].PAR)
                    Debug_PAR_dico_df["id"].append(id)
                    Debug_PAR_dico_df["tiller_surface"].append(tiller_surface[(lstring[id][0].num_plante, lstring[id][0].tiller)]*1e-4)
                    Debug_PAR_dico_df["Inc_PAR"].append(current_PAR)
                    
                  if (write_output_file["Blade"] and lstring[id].name == "Blade"):
                    Blade_dico_df['Elapsed_time'].append(elapsed_time)
                    Blade_dico_df['Temp_cum'].append(Tempcum)
                    Blade_dico_df['Temperature'].append(Temperature)
                    Blade_dico_df['Num_plante'].append(lstring[id][0].num_plante)
                    Blade_dico_df['Genotype'].append(lstring[id][0].geno)
                    Blade_dico_df['Num_talle'].append(str(lstring[id][0].tiller))
                    Blade_dico_df['Num_cohorte'].append(cohort_number(lstring[id][0].tiller))
                    Blade_dico_df['Num_rang'].append(lstring[id][0].n)
                    Blade_dico_df['Blade_sumtemp'].append(lstring[id][0].sumtemp)
                    Blade_dico_df['Blade_width'].append(lstring[id][0].width)
                    Blade_dico_df['Blade_length'].append(lstring[id][0].length)
                    Blade_dico_df['Blade_visible_length'].append(lstring[id][0].visible_length)
                    Blade_dico_df['Blade_final_length'].append(lstring[id][0].final_length)
                    Blade_dico_df['Blade_visible_surface'].append(lstring[id][0].visible_area)
                    Blade_dico_df['Blade_surface'].append(lstring[id][0].area)
                    Blade_dico_df['Blade_PAR'].append(lstring[id][0].PAR)
                    Blade_dico_df['Senesc_flag'].append(lstring[id][0].senesc_flag)
                    Blade_dico_df['Photosynthetic'].append(lstring[id][0].photosynthetic)
                    Blade_dico_df['Form_factor'].append(lstring[id][0].form_factor)

            par_per_axe = pd.DataFrame(PAR_per_organ).groupby(['Num_plante', 'Num_talle']).agg({'Organ_PAR': 'sum','Organ_surface': 'sum', 'tiller_surface':'mean'})
            for (nump, numt), row in par_per_axe.iterrows():
              if row.Organ_surface > 0:
                dico_PAR_per_axis[nump][numt][round(Tempcum, 1)] = row.Organ_PAR / Temperature / row.Organ_surface
              else:
                dico_PAR_per_axis[nump][numt][round(Tempcum, 1)] = 0
            dico_absolute_PAR_per_axis = par_per_axe.to_dict()

            if write_output_file["PAR_per_axes"] == True or write_output_file["Fitness"] == True:
              for num_plt in axis_census.keys():
                for axis in axis_census[num_plt].keys():
                  PAR_per_axes_dico["Elapsed_time"].append(elapsed_time)
                  PAR_per_axes_dico["DOY"].append(DOY)
                  PAR_per_axes_dico["Temperature"].append(Temperature)
                  PAR_per_axes_dico["Temp_cum"].append(Tempcum)
                  PAR_per_axes_dico["Num_plante"].append(num_plt)
                  PAR_per_axes_dico["Num_talle"].append(axis)
                  PAR_per_axes_dico["Inc_PAR"].append(current_PAR)
                  tt = round(Tempcum, 1)
                  PAR_per_axes_dico["Sum_PAR"].append(dico_PAR_per_axis[num_plt][axis].get(tt,0.))
                  PAR_per_axes_dico["Abs_int_PAR"].append(dico_absolute_PAR_per_axis['Organ_PAR'].get((num_plt,axis),0.))

    ### BOUCLE DE REGRESSION DES TALLES ###
    for num_plt in range(1,crop_scheme["nplant_peupl"] + 1):
      #Gestion du d�lai de protection d'une plante entre la mort successive de deux de ses talles
      if plant_shield_indicator[num_plt]["Shield"] == True:
        plant_shield_indicator[num_plt]["count"] += max(0,Temperature)
        if plant_shield_indicator[num_plt]["count"] >= Delta_prot[genotype_map[num_plt]]:
          plant_shield_indicator[num_plt]["Shield"] = False
          plant_shield_indicator[num_plt]["count"] = plant_shield_indicator[num_plt]["count"]%Delta_prot[genotype_map[num_plt]]
      
      weakest_axis = "No"
      PAR = 1
      nb_timestep_fenetre = 1
      PAR_2_write = 1
      
      #Date effective du debut de regression des talles qui d�pend du nombre de feuilles final
      if t_beg_reg_ind_Tht.keys(): #This is a simple and ugly test set to avoid performing the real test (on an empty dict) the first round of simulation before the dict t_beg_reg_ind_Tht fills itself
        #print elapsed_time, "tht beg reg : ",min(t_beg_reg_ind_Tht.values())
        if t_beg_reg_ind_Tht[num_plt] < Tempcum < dico_stades[num_plt][(1,)]["Flo"][1]: 
          #Determining the maximal cohort of the day
          PAR_per_youngest_tiller = (0, float('inf'))
          if len(axis_census[num_plt].values()) > 0: #If at least one axis is composing the plant
            
            # We calculate the highest emergence date of the tiller in order to point the youngest tiller
            date_emergence_max = 0
            for tal in axis_census[num_plt].keys():
              if axis_census[num_plt][tal]["emerg_date"] > date_emergence_max:
                date_emergence_max = axis_census[num_plt][tal]["emerg_date"]
            #date_emergence_max = max(axis_census[num_plt].values())["emerg_date"]
            
            for axis, value in axis_census[num_plt].iteritems():
              if axis != (1,): #No regression is considered on the main stem
                
                # On d�limite les bords de la fen�tre glissante
                min_temp = min(dico_PAR_per_axis[num_plt][axis].keys())
                max_temp = max(dico_PAR_per_axis[num_plt][axis].keys())
                # Considering only the youngest axis
                if(max_temp - min_temp) >= Delta_l and value["emerg_date"] == date_emergence_max and axis_census[num_plt][axis]["Stop_growth_flag"] == False:
                  if dico_PAR_per_axis[num_plt][axis][round(Tempcum, 1)] < PAR_per_youngest_tiller[1]:
                    weakest_axis = axis
                    #for temp in range(min(dico_PAR_per_axis[num_plt][axis].keys(), key=lambda x:abs(x-(max_temp-Delta_l))), max_temp+1):
                    Temp_keys = [t for t in dico_PAR_per_axis[num_plt][axis].keys() if t > max(dico_PAR_per_axis[num_plt][axis].keys()) - Delta_l]
                    PAR = 0            
                    for temp in Temp_keys:
                      PAR += dico_PAR_per_axis[num_plt][axis][temp]
                    nb_timestep_fenetre = len(Temp_keys)
                    #print "num plt : ", num_plt, "weakest_axis",weakest_axis, "PAR moyen: ",PAR/nb_timestep_fenetre, "test mort : ", PAR/nb_timestep_fenetre < PAR_t[genotype_map[num_plt]]
                    if PAR/nb_timestep_fenetre < PAR_t[genotype_map[num_plt]]:
                      PAR_per_youngest_tiller = (axis, dico_PAR_per_axis[num_plt][axis][round(Tempcum, 1)])
                      
            
            if PAR_per_youngest_tiller != (0, float('inf')) and plant_shield_indicator[num_plt]["Shield"] == False:
              plant_shield_indicator[num_plt]["Shield"] = True
              axis_census[num_plt][PAR_per_youngest_tiller[0]]["Stop_growth_flag"] = True 
              axis_census[num_plt][PAR_per_youngest_tiller[0]]["emerg_date"] = 0        
        
      #global GAI_df
      GAI_dico_df['Weakest_axis'].append(weakest_axis)
      GAI_dico_df['PAR_weakest_axis'].append(PAR/nb_timestep_fenetre)
  
  ###### Fin rayonnement
  
  for num in range(1, crop_scheme["nplant_peupl"] + 1):
    GAI_dico_df["Init_flag"].append(initialization_Flag[num])
    GAI_dico_df['Elapsed_time'].append(elapsed_time)
    GAI_dico_df['Temp_cum'].append(Tempcum)
    GAI_dico_df['DOY'].append(DOY)
    GAI_dico_df['Genotype'].append(0)
    GAI_dico_df['Num_plante'].append(num)
    GAI_dico_df['Surface_plante'].append(surface_plante[num])
    GAI_dico_df['Surface_visible'].append(surface_plante_visible[num])
    GAI_dico_df['Surface_sol'].append((crop_scheme["nplant_peupl"] * ((crop_scheme["dist_inter_rang"]*100)*(crop_scheme["dist_intra_rang"] * 100))))
    GAI_dico_df['GAI_tot'].append(GAI_tot)
    GAI_dico_df['GAI_center'].append(GAI_center)
    GAI_dico_df['GAI_prox'].append(GAI_prox[num])

    if num in plant_census:
      GAI_dico_df['Position'].append("center")
    else:
      GAI_dico_df['Position'].append("border")
  
  
  

def End(lstring):
  
  ####################################
  #   ECRITURE DANS DES FICHIERS     #
  ####################################
  print "Aloha"

  if write_output_file["Apex_Sirius"] == True:
    _Apex_Sirius_df = pd.DataFrame(Apex_Sirius_dico_df)
    dF_labels = ["Elapsed_time","Temperature", "Temp_cum", "Daylength", "Num_plante", "Genotype", "PN", "LN", "Sumtemp", "Vern_rate", "Vern_prog", "Vern_flag", "Debut_ppd_flag", "Fin_ppd_flag", "Ln_pot", "Var_L_min","Ln_app", "Ln_final"]
    Apex_Sirius_df = _Apex_Sirius_df.reindex(dF_labels, axis="columns", copy=False)
    Apex_Sirius_df.to_csv(pj(out_dir,folder_name, "Apex_Sirius.csv"), sep="\t", header=True, index=False)

  if write_output_file["Apex"] == True:
    _Apex_df = pd.DataFrame(Apex_dico_df)
    dF_labels = ["Elapsed_time", "Temperature", "Temp_cum", "Time_count", "Sum_temp", "Current_PAR", "Num_plante",  "Genotype", "Num_talle", "Num_cohorte", "Nb_phyto_emi", "Nb_emerged_leaf", "Transiflo_flag", "STOP_init_flag", "Transiflo_DOY","Ln_final"]
    Apex_df = _Apex_df.reindex(dF_labels, axis="columns", copy=False)
    Apex_df.to_csv(pj(out_dir,folder_name, "Apex.csv"), sep="\t", header=True, index=False)

  if write_output_file["Apex_R"] == True:
    _Apex_R_df = pd.DataFrame(Apex_R_dico_df)
    dF_labels = ["Elapsed_time", "DOY", "Temperature", "Temp_cum", "Sum_temp", "Num_plante", "Genotype", "Num_talle", "Num_cohorte", "Ln_final", "Date_epiaison", "Epi_DOY", "Date_de_flo", "Mont_flag", "Mont_DOY", "Flo_flag", "Flo_DOY", "Death_flag", "Date_de_maturite", "Mat_DOY"]
    Apex_R_df = _Apex_R_df.reindex(dF_labels, axis="columns", copy=False)
    Apex_R_df.to_csv(pj(out_dir,folder_name, "Apex_R.csv"), sep="\t", header=True, index=False)

  if write_output_file["Blade"] == True:
    _Blade_df = pd.DataFrame(Blade_dico_df)
    dF_labels = ["Elapsed_time", "Temp_cum" , "Temperature", "Num_plante", "Genotype", "Num_talle", "Num_cohorte", "Num_rang", "Blade_sumtemp", "Blade_width", "Blade_length", "Blade_visible_length","Blade_final_length", "Blade_visible_surface", "Blade_surface", "Blade_PAR", "Senesc_flag" , "Photosynthetic", "Form_factor"]
    Blade_df = _Blade_df.reindex(dF_labels, axis="columns", copy=False)
    Blade_df.to_csv(pj(out_dir,folder_name, "Blade.csv"), sep="\t", header=True, index=False)

  if write_output_file["Internode"] == True:
    _Internode_df = pd.DataFrame(Internode_dico_df)
    dF_labels = ["Elapsed_time" ,  "Temp_cum" ,  "Temperature" ,  "Num_plante" ,  "Genotype" ,  "Num_talle", "Num_cohorte", "Num_rang" , "Internode_length" ,  "Internode_final_length" ,  "Internode_surface", "Internode_PAR", "Photosynthetic"]
    Internode_df = _Internode_df.reindex(dF_labels, axis="columns", copy=False)
    Internode_df.to_csv(pj(out_dir,folder_name, "Internode.csv"), sep="\t", header=True, index=False)

  if write_output_file["Peduncle"] == True:
    _Peduncle_df = pd.DataFrame(Peduncle_dico_df)
    dF_labels = ["Elapsed_time", "Temp_cum", "Temperature",  "Num_plante",  "Genotype", "Num_talle", "Num_cohorte", "Num_rang", "Sum_temp", "Peduncle_length", "Peduncle_final_length", "Peduncle_surface", "Peduncle_PAR", "Photosynthetic"]
    Peduncle_df = _Peduncle_df.reindex(dF_labels, axis="columns", copy=False)
    Peduncle_df.to_csv(pj(out_dir,folder_name, "Peduncle.csv"), sep = "\t", header=True, index=False)

  if write_output_file["Sheath"] == True:
    _Sheath_df = pd.DataFrame(Sheath_dico_df)
    dF_labels = ["Elapsed_time" ,  "Temp_cum" ,  "Temperature" ,  "Num_plante" ,  "Genotype" ,  "Num_talle" , "Num_cohorte", "Num_rang" ,"Sheath_sumtemp"  ,"Sheath_diameter" , "Sheath_length" ,  "Sheath_final_length" , "Sheath_surface" , "Sheath_PAR" , "Photosynthetic"]
    Sheath_df = _Sheath_df.reindex(dF_labels, axis="columns", copy=False)
    Sheath_df.to_csv(pj(out_dir,folder_name, "Sheath.csv"), sep="\t", header=True, index=False)

  if write_output_file["Ear"] == True:
    _Ear_df = pd.DataFrame(Ear_dico_df)
    dF_labels = ["Elapsed_time", "Temp_cum" , "Num_plante" ,"Genotype", "Num_talle" , "Ear_sumtemp"  , "Ear_length" ,"Ear_surface", "Ear_PAR", "Photosynthetic", "Emerged"]
    Ear_df = _Ear_df.reindex(dF_labels, axis="columns", copy=False)
    Ear_df.to_csv(pj(out_dir,folder_name, "Ear.csv"), sep="\t", header=True, index=False)

  if write_output_file["Proba"] == True:
    _Proba_df = pd.DataFrame(Proba_dico_df)
    dF_labels = ["Elapsed_time", "Temperature", "Temp_cum", "Num_plante", "Genotype", "Num_talle", "Num_rang", "Sumtemp", "GAI_prox", "P_debourr"]
    Proba_df = _Proba_df.reindex(dF_labels, axis="columns", copy=False)
    Proba_df.to_csv(pj(out_dir,folder_name, "Probabilities.csv"), sep="\t", header=True, index=False)

  if write_output_file["Peraxes"] == True:
    _Peraxes_df = pd.DataFrame(Peraxes_dico_df)
    dF_labels = ["Init_flag","Elapsed_time", "DOY","Temperature", "Temp_cum", "Num_plante", "Num_talle", "Sheath_max", "Collar_height", "Dead_collar_height", "Delta_H", "Visible_leaves_surface", "Visible_surface", "Leaf_contrib_to_GAI","Stem_contrib_to_GAI","Ear_contrib_to_GAI","Peduncle_contrib_to_GAI", "Stop_growth_flag"]
    Peraxes_df = _Peraxes_df.reindex(dF_labels, axis="columns", copy=False)
    Peraxes_df.to_csv(pj(out_dir,folder_name, "Peraxes.csv"), sep="\t", header=True, index=False)

  if write_debug_PAR == True:
    Debug_PAR_df = pd.DataFrame(Debug_PAR_dico_df)
    Debug_PAR_df.to_csv(pj(out_dir,folder_name, "Debug_PAR.csv"), sep="\t", header=True, index=False)

  if write_output_file["PAR_per_axes"] == True:
    PAR_per_axes_df = pd.DataFrame(PAR_per_axes_dico)
    PAR_per_axes_df.to_csv(pj(out_dir,folder_name, "PAR_per_axes.csv"), sep = "\t", header = True, index = False)

  # FICHIER PARAMETRES
  
  fichier_params = open(pj(out_dir,folder_name, "Parameters.csv"), "w")
  fichier_params.write("Parameter" + "\t" + "Genotype" + "\t" + "Value" + "\n" +
                       "WALTer_version" + "\t" + "All" + "\t" + "%s" % WALTer_version + "\n" +
                       "WALTer_build" + "\t" + "All" + "\t" + "%s" % WALTer_build + "\n" +
                       "Related_experiment" + "\t" + "All" + "\t" + "%s" % expe_related + "\n" +
                       "Crop_conception" + "\t" + "All" + "\t" + "%s" % crop_ccptn + "\n" +
                       "Sowing_date" + "\t" + "All" + "\t" + "%s" % sowing_date + "\n" +
                       "Year" + "\t" + "All" + "\t" + "%s" % year + "\n" +
                       "Location" + "\t" + "All" + "\t" + "%s" % location + "\n" +
                       "Meteo" + "\t" + "All" + "\t" + "%s" % meteo + "\n" +
                       "Latitude" + "\t" + "All" + "\t" + "%s" % latitude + "\n" +
                       "Nbj" + "\t" + "All" + "\t" + "%s" % nbj + "\n" +
                       "rep" + "\t" + "All" + "\t" + "%s" % rep + "\n" +
                       "densite" + "\t" + "All" + "\t" + "%s" % densite + "\n" +
                       "Nb_rang" + "\t" + "All" + "\t" + "%s" % nb_rangs + "\n" +
                       "Nb_plantes" + "\t" + "All" + "\t" + "%s" % nb_plantes + "\n" +
                       "Area_targeted" + "\t" + "All" + "\t" + "%s" % area_targeted + "\n" +
                       "Nb_plantes_utiles" + "\t" + "All" + "\t" + "%s" % crop_scheme["nb_useful_plt"] + "\n" +
                       "dist_border_x" + "\t" + "All" + "\t" + "%s" % dist_border_x + "\n" +
                       "dist_border_y" + "\t" + "All" + "\t" + "%s" % dist_border_y + "\n" +
                       "Genotypes_nb" + "\t" + "All" + "\t" + "%s" % geno_nb + "\n" +
                       "CARIBU_state" + "\t" + "All" + "\t" + "%s" % CARIBU_state + "\n" +
                       "SIRIUS_state" + "\t" + "All" + "\t" + "%s" % SIRIUS_state + "\n" +
                       "sky_type" + "\t" + "All" + "\t" + "%s" % sky_type + "\n" +
                       "add_sun" + "\t" + "All" + "\t" + "%s" % add_sun + "\n" +
                       "turtle_sectors" + "\t" + "All" + "\t" + "%s" % turtle_sectors + "\n" +
                       "infinity_GAIp"  + "\t" + "All" + "\t" + "%s" % infinity_GAIp + "\n" +
                       "infinity_CARIBU" + "\t" + "All" + "\t" + "%s" % infinity_CARIBU + "\n" +
                       "Light_step" + "\t" + "All" + "\t" + "%s" % PAS + "\n" +
                       "nb_azimuth" + "\t" + "All" + "\t" + "%s" % nb_azimuth + "\n" +
                       "nb_zenith" + "\t" + "All" + "\t" + "%s" % nb_zenith + "\n" +
                       "dist_inter_rang" + "\t" + "All" + "\t" + "%s" % dist_inter_rang + "\n" +
                       "dist_intra_rang" + "\t" + "All" + "\t" + "%s" % dist_intra_rang + "\n" +
                       "dx" + "\t" + "All" + "\t" + "%s" % dx  + "\n" +
                       "dy" + "\t" + "All" + "\t" + "%s" % dy  + "\n" +
                       "Hazard_plant_xy" + "\t" + "All" + "\t" + "%s" % hazard_driver["plant_xy"]  + "\n" +
                       "Hazard_plant_azi" + "\t" + "All" + "\t" + "%s" % hazard_driver["plant_azi"]  + "\n" +
                       "Hazard_axis" + "\t" + "All" + "\t" + "%s" % hazard_driver["axis"]  + "\n" +
                       "Hazard_organ" + "\t" + "All" + "\t" + "%s" % hazard_driver["organ"]  + "\n" +
                       "Hazard_emerg" + "\t" + "All" + "\t" + "%s" % hazard_driver["emerg"]  + "\n" +
                       "N_p_s" + "\t" + "All" + "\t" + "%s" % N_p_s + "\n" +
                       "l_c" + "\t" + "%s" % "All" + "\t" + "%s" % l_c + "\n" +
                       "L_b_S" + "\t" + "All" + "\t" + "%s" % L_b_S + "\n" +
                       "Psi_FT" + "\t" + "All" + "\t" + "%s" % Psi_FT + "\n" +
                       "Tbase" + "\t" + "All" + "\t" + "%s" % Tbase + "\n" +
                       "T_vern_min" + "\t" + "All" + "\t" + "%s" % Tvermin + "\n" +
                       "T_vern_opt" + "\t" + "All" + "\t" + "%s" % Tverint + "\n" +
                       "T_vern_max" + "\t" + "All" + "\t" + "%s" % Tvermax + "\n" +
                       "Lmax" + "\t" + "All" + "\t" + "%s" % Lmax + "\n" +
                       "Lmin" + "\t" + "All" + "\t" + "%s" % Lmin + "\n" +
                       "Ldecr" + "\t" + "All" + "\t" + "%s" % Ldecr + "\n" +
                       "Lincr" + "\t" + "All" + "\t" + "%s" % Lincr + "\n" +
                       "phyllo_decr" + "\t" + "All" + "\t" + "%s" % phyllo_decr + "\n" +
                       "phyllo_incr" + "\t" + "All" + "\t" + "%s" % phyllo_incr + "\n" +
                       "DLsat" + "\t" + "All" + "\t" + "%s" % DLsat + "\n" +
                       "Delta_b"  + "\t" + "All" + "\t" + "%s" %  Delta_b + "\n" +
                       "dGAIp"  + "\t" + "All" + "\t" + "%s" % dGAIp + "\n" +
                       "Delta_l"  + "\t" + "All" + "\t" + "%s" % Delta_l + "\n" +
                       "Delta_c_GN" + "\t" + "All" + "\t" + "%s" % Delta_c_GN + "\n" +
                       "Delta_hf" + "\t" + "All" + "\t" + "%s" % Delta_hf   + "\n" +
                       "Delta_hm" + "\t" + "All" + "\t" + "%s" % Delta_hm  + "\n" +
                       "Delta_lflf" + "\t" + "All" + "\t" + "%s" % Delta_lflf + "\n"+
                       "Delta_flsp" + "\t" + "All" + "\t" + "%s" % Delta_flsp + "\n"+
                       "Delta_SGtR" + "\t" + "All" + "\t" + "%s" % Delta_SGtR + "\n"+
                       "Delta_SGtC" + "\t" + "All" + "\t" + "%s" % Delta_SGtC + "\n"+
                       "ED_I" + "\t" + "All" + "\t" + "%s" % ED_I + "\n" +
                       "ED_B" + "\t" + "All" + "\t" + "%s" % ED_B + "\n" +
                       "ED_FB"  + "\t" + "All" + "\t" + "%s" % ED_FB + "\n" +
                       "ED_S" + "\t" + "All" + "\t" + "%s" % ED_S + "\n" +
                       "Phi_azi_B"  + "\t" + "All" + "\t" + "%s" % Phi_azi_B + "\n" +
                       "Phi_zen_T"   + "\t" + "All" + "\t" + "%s" % Phi_zen_T + "\n" +
                       "Phi_azi_T"  + "\t" + "All" + "\t" + "%s" % Phi_azi_T + "\n" +
                       "Phi_zen_E"  + "\t" + "All" + "\t" + "%s" % Phi_zen_E + "\n" +
                       "Phi_azi_S"  + "\t" + "All" + "\t" + "%s" % Phi_azi_S + "\n" +
                       "Phi_zen_S"  + "\t" + "All" + "\t" + "%s" % Phi_zen_S + "\n" +
                       "y_position_hazard"  + "\t" + "All" + "\t" + "%s" % y_position_hazard + "\n" +
                       "x_position_hazard"  + "\t" + "All" + "\t" + "%s" % x_position_hazard + "\n" +
                       "z_position_hazard"  + "\t" + "All" + "\t" + "%s" % z_position_hazard + "\n" +
                       "blade_incl_hazard"  + "\t" + "All" + "\t" + "%s" % blade_incl_hazard + "\n" +
                       "blade_azi_hazard"  + "\t" + "All" + "\t" + "%s" % blade_azi_hazard + "\n" +
                       "till_zen_hazard"  + "\t" + "All" + "\t" + "%s" % till_zen_hazard + "\n" +
                       "till_azi_hazard"  + "\t" + "All" + "\t" + "%s" % till_azi_hazard + "\n" +
                       "leaf_nb_segments"  + "\t" + "All" + "\t" + "%s" % leaf_nb_segments + "\n" +
                       "genotype_proportion"  + "\t" + "All" + "\t" + "%s" % genotype_proportion + "\n")
  for geno in crop_genotype:
    fichier_params.write("Phl" + "\t" + "%s" % geno + "\t" + "%s" % Phl[geno] + "\n" +
                         "corrected_Phl" + "\t" + "%s" % geno + "\t" + "%s" % phyll_adjust(geno) + "\n" +
                         "Pls" + "\t" + "%s" % geno + "\t" + "%s" % Pls[geno] + "\n" +
                         "VAI" + "\t" + "%s" % geno + "\t" + "%s" % VAI[geno] + "\n" +
                         "VBEE" + "\t" + geno + "\t" + "%s" % VBEE[geno] + "\n" +
                         "SLDL" + "\t"+ "%s" % geno + "\t"  + "%s" % SLDL[geno] + "\n" +
                         "Dse_mean" + "\t" + "%s" % geno + "\t" + "%s" % Dse[geno]["mean"] + "\n" +
                         "Dse_sd" + "\t" + "%s" %  geno  + "\t" + "%s" % Dse[geno]["sd"] + "\n" +
                         "N_I_el" + "\t" + "%s" %  geno + "\t" + "%s" % N_I_el[geno] + "\n" +
                         "s_B_1" + "\t" + geno + "\t" + "%s" % s_B_1[geno] + "\n" +
                         "N_B_r" + "\t" + "%s" %  geno  + "\t" + "%s" % N_B_r[geno] + "\n" +
                         "L_B_1" + "\t" + "%s" %  geno  + "\t" + "%s" % L_B_1[geno] + "\n" +
                         "L_B_max" + "\t" + "%s" %  geno  + "\t" + "%s" % L_B_max[geno] + "\n" +
                         "s_B_f" + "\t" + "%s" % geno + "\t" + "%s" % s_B_f[geno] + "\n" +
                         "a_B_w" + "\t" + "%s" % geno + "\t" + "%s" % a_B_w[geno] + "\n" +
                         "b_B_w" + "\t" + "%s" % geno + "\t" + "%s" % b_B_w[geno] + "\n" +
                         "a_S_L" + "\t" + "%s" % geno + "\t" + "%s" % a_S_L[geno] + "\n" +
                         "b_S_L" + "\t" + "%s" % geno + "\t" + "%s" % b_S_L[geno] + "\n" +
                         "inc_I"  + "\t" + "%s" % geno + "\t" + "%s" % inc_I[geno] + "\n" +
                         "shape_internode"   + "\t" + "%s" % geno + "\t" + "%s" % shp_I[geno] + "\n" +
                         "b_I_L"   + "\t" + "%s" % geno + "\t" + "%s" % b_I_L[geno] + "\n" +
                         "a_I_L"   + "\t" + "%s" % geno + "\t" + "%s" % a_I_L[geno] + "\n" +
                         "d_I" + "\t" + "%s" % geno + "\t" + "%s" % d_I[geno] + "\n" +
                         "L_P" + "\t" + geno + "\t" + "%s" % L_P[geno] + "\n" +
                         "d_P" + "\t" + "%s" % geno + "\t" + "%s" % d_P[geno] + "\n" +
                         "d_E" + "\t" + "%s" % geno + "\t" + "%s" % d_E[geno] + "\n" +
                         "L_E" + "\t" +  "%s" % geno + "\t" + "%s" % L_E[geno] + "\n" +
                         "d_S" + "\t" + "%s" % geno + "\t" + "%s" % d_S[geno] + "\n" +
                         "n0_sen" + "\t" + "%s" % geno + "\t" + "%s" % n0_sen[geno] + "\n" +
                         "n1_sen" + "\t" + "%s" % geno + "\t" + "%s" % n1_sen[geno] + "\n" +
                         "n2_sen" + "\t" + "%s" % geno + "\t" + "%s" % n2_sen[geno] + "\n" +
                         "n3_sen" + "\t" + "%s" % geno + "\t" + "%s" % n3_sen[geno] + "\n" +
                         "t0_sen" + "\t" + "%s" % geno + "\t" + "%s" % t0_sen[geno] + "\n" +
                         "t1_sen" + "\t" + "%s" % geno + "\t" + "%s" % t1_sen[geno] + "\n" +
                         "t2_sen" + "\t" + "%s" % geno + "\t" + "%s" % t2_sen[geno] + "\n" +
                         "t3_sen" + "\t" + "%s" % geno + "\t" + "%s" % t3_sen[geno] + "\n" +
                         "DelayTipToHS" + "\t" + "%s" % geno + "\t" + "%s" % DelayTipToHS[geno] + "\n" +
                         "P_CT" + "\t" + "%s" %  geno  + "\t" + "%s" % P_CT[geno] + "\n" +
                         "GAI_critique" + "\t"+ "%s" % geno + "\t"  + "%s" % GAI_c[geno] + "\n" +
                         "t_beg_reg"  + "\t" + geno + "\t" + "%s" % t_beg_reg[geno] + "\n" +
                         "Delta_prot" + "\t" + geno + "\t" + "%s" %  Delta_prot[geno] + "\n" +
                         "PAR_t" + "\t" + geno + "\t" + "%s" % PAR_t[geno] + "\n" +
                         "P_T" + "\t" + "%s" %  geno  + "\t" + "%s" % P_T[geno] + "\n" +
                         "Param_PlHeight" + "\t" + "%s" %  geno  + "\t" + "%s" % Param_PlHeight[geno] + "\n" + 
                         "Phi_zen_B" + "\t" + "%s" %  geno  + "\t" + "%s" % Phi_zen_B[geno] + "\n"+
                         "Scurv" + "\t" + "%s" %  geno  + "\t" + "%s" % scurv[geno] + "\n"+
                         "Curvature" + "\t" + "%s" %  geno  + "\t" + "%s" % curvature[geno] + "\n"+
                         "Param_Ln_final" + "\t" + "%s" %  geno  + "\t" + "%s" % param_Ln_final[geno] + "\n")
  fichier_params.close()
  print "Au revoir"
  fichier_individual= open(pj(out_dir,folder_name, "Individual_heterogeneity.csv"), "w")
  fichier_individual.write("Parameter" + "\t" + "Num_plante" + "\t" + "Dse" + "\n" )
  for numplt in range(1,crop_scheme["nplant_peupl"] + 1):
    fichier_individual.write("Dse_ind" + "\t" + "%s" % numplt + "\t" + "%s" % Dse_heterogeneous[numplt] + "\n" )
  fichier_individual.close()

  if write_output_file["GAI"] == True:
    _GAI_df = pd.DataFrame(GAI_dico_df)
    dF_labels = ["Init_flag","Elapsed_time","Temp_cum","DOY","Genotype","Num_plante","Surface_plante","Surface_visible","Surface_sol","GAI_tot","GAI_center","GAI_prox","Position","Weakest_axis","PAR_weakest_axis"]
    GAI_df = _GAI_df.reindex(dF_labels,  axis="columns", copy=False)
    GAI_df.to_csv(pj(out_dir,folder_name, "GAI.csv"), sep="\t", header=True, index=False)

  if write_output_file["Fitness"] == True:
    if CARIBU_state != "disabled" and len(PAR_per_axes_dico['Num_plante']) >=1:
      Flo_date_dict = fitness.flo_date(Transiflo_dico = dico_stades, nb_days = n_days_fitness_before, nb_days_after = n_days_fitness_after)
      Fitness_dict = fitness.fitness(PAR_dict = PAR_per_axes_dico, geno_dict = genotype_map, flo_date_dict = Flo_date_dict, a_k = a_fitness, b_k = b_fitness)
      Fitness_dict.to_csv(path_or_buf = pj(out_dir, folder_name, 'Fitness.csv'), sep='\t', index=True) # Saving WALTer's Fitness_dict as a csv file
    else:
      print "The Fitness could not be computed because CARIBU_state = disabled or the model has not run for enough days"

Axiom:Seed

derivation length: int(nbj)
# nbj jours

###########PRODUCTION##########

production:

group 1:
Seed:
  global beginning_CARIBU
  global ending_CARIBU
  
  fichier_parcelle = open(pj(out_dir,folder_name, "Parcelle.csv"), "w")
  
  fichier_parcelle.write("X" + "\t" + "Y" + "\t" + "Num_plante" + "\t" + "Genotype" + "\n")
  
  # Calculates the coordinates of each plant
  xmin, ymin, xmax, ymax = domain(crop_scheme)
  xmin_center, ymin_center, xmax_center, ymax_center = central_domain(crop_scheme, dist_border_x, dist_border_y)
  
  #  xmin_center = xmin + ((crop_scheme["dist_intra_rang"] * 100 * nb_plante_par_rang_border) + x_position_hazard)
  #  xmax_center = xmax - ((crop_scheme["dist_intra_rang"] * 100 * nb_plante_par_rang_border) + x_position_hazard)
  #  ymin_center = ymin + ((crop_scheme["dist_inter_rang"]*100 * nb_rang_border) + y_position_hazard)
  #  ymax_center = ymax - ((crop_scheme["dist_inter_rang"]*100 * nb_rang_border) + y_position_hazard)
  #  
  # xmin_center = xmin + (dist_border_x + x_position_hazard)
  # xmax_center = xmax - (dist_border_x + x_position_hazard)
  # ymin_center = ymin + (dist_border_y + y_position_hazard)
  # ymax_center = ymax - (dist_border_y + y_position_hazard)
  
  
  print "xmin : ", xmin, "xmax : ", xmax, "xmin_center", xmin_center, "xmax_center", xmax_center
  print "ymin : ", ymin, "ymax : ", ymax, "ymin_center", ymin_center, "ymax_center", ymax_center
  
  for num_plante in range(1,int(crop_scheme["nplant_peupl"]) + 1):
    x = plant_map[num_plante]["x"]
    y = plant_map[num_plante]["y"]
    if genotype_proportion == "random":
      geno = random.choice(crop_genotype)    ## selection geno random
      genotype_map[num_plante] = geno
    elif genotype_proportion == "equal" or genotype_proportion == "genetics":
      geno = genotype_list[num_plante-1]
      genotype_map[num_plante] = geno
    
    Dse_heterogeneous[num_plante] = max(0,random.normalvariate(Dse[genotype_map[num_plante]]["mean"],Dse[genotype_map[num_plante]]["sd"] ))
    positions[num_plante] = {"x" : x + random.uniform(-x_position_hazard, x_position_hazard) ,"y" : y + random.uniform(-y_position_hazard, y_position_hazard),"z" : 0}
    
    #Dictionnary initialisation
    
    ## Individual scale
    initialization_Flag[num_plante] = True
    GAI_prox[num_plante] = 0
    tiller_death[num_plante] = {}
    tiller_death_now[num_plante] = (2,)
    dead_tillers[num_plante] = []      
    youngest_axes[num_plante] = []
    weakest_axis[num_plante] = {}
    dico_cut_fantom_axes[num_plante] = {}      
    future_dead_axes[num_plante] = []
    plant_shield_indicator[num_plante] = {"Shield": False, "count": 0.0}
    
    surface_plante[num_plante] = 0.01
    surface_plante_visible[num_plante] = 0.01
    
    surface_sol[num_plante] = crop_scheme["dist_inter_rang"] * crop_scheme["dist_intra_rang"]
    
    ## Axis scale
    ### about emerged organs
    first_leaf_phase2[num_plante] = {}
    first_leaf_phase2[num_plante][tiller_init] = {"num_first_leaf_phase_2" : 0, "length_first_leaf_phase_2" : 0}
    LNfinal[num_plante] = {}
    LNfinal[num_plante][tiller_init] = 0
    axis_census[num_plante] = {}
    axis_census[num_plante][tiller_init] = {"emerg_date" : Dse_heterogeneous[num_plante], "Stop_growth_flag" : False, "Regression_flag" : False}
    
    dico_stades[num_plante] = {}
    dico_stades[num_plante][tiller_init] = {"Age" : 0 ,"Blade_Transiflo" : False, "Transiflo" : [False,10000,0], "Montaison" : [False,10000,0],"Ear_emergence" : False, "Epiaison" : [False,10000,0], "Flo" : [False,10000,0], "Maturite" : [False,10000,0], "Ln_final":"undefined", "End_internode_elongation" : False, "Senescence_flag_leaf" : [False, 10000, 0]}
    
    dico_PAR["Blade"][num_plante] = {}
    dico_PAR["Sheath"][num_plante] = {}
    dico_PAR["Internode"][num_plante] = {}
    dico_PAR["Peduncle"][num_plante] = {}
    dico_PAR["Ear"][num_plante] = {}
    dico_PAR["Blade"][num_plante][tiller_init] = {}
    dico_PAR["Sheath"][num_plante][tiller_init] = {}
    dico_PAR["Internode"][num_plante][tiller_init] = {}
    dico_PAR["Peduncle"][num_plante][tiller_init] = {}
    dico_PAR["Ear"][num_plante][tiller_init] = {}
    dico_PAR_per_axis[num_plante] = {}
    dico_PAR_per_axis[num_plante][tiller_init] = {}
    
    dico_cut_dead_blades[num_plante] = {}
    dico_cut_dead_blades[num_plante][tiller_init] = []
    
    hazard_dict_axis[num_plante] = {}
    hazard_dict_axis[num_plante][tiller_init] = {"tiller_azimuth" : Phi_azi_S + random.randint(0,plant_azi_hazard) , "tiller_zenith" : Phi_zen_S}
    
    ### about initiated organs
    date_emission[num_plante] = {}
    date_emission[num_plante][tiller_init] = Dse_heterogeneous[num_plante]
    Hcol_max[num_plante] = {}
    Hcol_max[num_plante][tiller_init] = 0
    Hcol_dead[num_plante] = {}
    Hcol_dead[num_plante][tiller_init] = 0
    delta_H[num_plante] = {}
    delta_H[num_plante][tiller_init] = 0      
    tiller_surface[(num_plante,tiller_init)] = 0.0
    
    # Phytomer scale
    
    current_sheath_length[num_plante] = {}
    current_sheath_length[num_plante][tiller_init] = {0: l_c}
    dead_sheath_length[num_plante] = {}
    dead_sheath_length[num_plante][tiller_init] = {0:0}
    
    
    current_internode_length[num_plante] = {}
    current_internode_length[num_plante][tiller_init] = {} 
    
    final_blade_length[num_plante] = {}
    final_blade_length[num_plante][tiller_init] = {} 
    
    leaf_emergence[num_plante] = {}
    leaf_emergence[num_plante][tiller_init] = {1: (0,0)}
    
    Sh_max[num_plante] = {}
    Sh_max[num_plante][tiller_init] = {0 : 0.0}
    
    hazard_dict_organ[num_plante] = {}
    hazard_dict_organ[num_plante][tiller_init] = {}
    
    fichier_parcelle.write("%s" % positions[num_plante]["x"] + "\t" + "%s" % positions[num_plante]["y"] + "\t" + "%s" % num_plante + "\t" + "%s" % geno + "\n")
    nproduce  @M(positions[num_plante]["x"],positions[num_plante]["y"],positions[num_plante]["z"])
    
    StA = Apex(num_plante, geno, tiller_init, 0,0)
    StCPB = CutPointBud(num_plante,geno,tiller_init)
    nproduce CutPointBud(StCPB)Apex(StA)
  
  print "border plants : ", border_plants
  
  #TODO ajouter un nom plus explicite pour les plantes du centre/bordure.
  print "plant census 2 : ",plant_census
  crop_scheme["nb_useful_plt"] = len(plant_census)
  nb_plantes_utiles = crop_scheme["nb_useful_plt"] 
  print crop_scheme["nb_useful_plt"]," plantes utiles sur ",crop_scheme["nplant_peupl"]
  print "All plants in border : ",border_plants == plant_census
  
  #d�terminer la plante la plus pr�coce
  global earliest_plant
  global latest_plant
  global param_Ln_final
  minimal_emergence = min(Dse_heterogeneous.values())
  maximal_emergence = max(Dse_heterogeneous.values())
  
  for key, value in Dse_heterogeneous.iteritems():
    if value == minimal_emergence:
      earliest_plant = key
    if value == maximal_emergence:
      latest_plant = key
  # List phyllochrones of all the genotypes presents within the crop
  all_phyllo = {}
  for g in crop_genotype:
    all_phyllo[phyll_adjust(g)] = g
  longest_phyllo = max(all_phyllo.keys())
  shortest_phyllo = min(all_phyllo.keys())
  earliest_geno = all_phyllo[shortest_phyllo]
  latest_geno = all_phyllo[longest_phyllo]
  earliest_t_beg_reg = floor(min(param_Ln_final.values()))-max(t_beg_reg.values())
  if 'beginning_CARIBU' in params:
    beginning_CARIBU = params['beginning_CARIBU']
  else:
    beginning_CARIBU = (leaf_emerg_date(earliest_t_beg_reg, (1,), earliest_geno, earliest_plant) + 1.6 * shortest_phyllo) - 100
  ending_CARIBU = (leaf_emerg_date(ceil(max(param_Ln_final.values())),(1,), latest_geno, latest_plant) +  2.98 * longest_phyllo) +100
  print "Beginning CARIBU : ",beginning_CARIBU, "Ending CARIBU : ", ending_CARIBU
  useGroup(2)


group 2:


Apex(StA):
  if SIRIUS_state == "disabled":
    StA.Ln_final = int(param_Ln_final[StA.geno])+int(random.random() + param_Ln_final[StA.geno]%1)
    dico_stades[StA.num_plante][(1,)]["Ln_final"] = StA.Ln_final
    t_beg_reg_ind = dico_stades[StA.num_plante][(1,)]["Ln_final"]-t_beg_reg[StA.geno]
    t_beg_reg_ind_Tht[StA.num_plante] = leaf_emerg_date(t_beg_reg_ind, (1,), StA.geno, StA.num_plante) + 1.6*phyll_adjust(StA.geno)
    useGroup(3)
  
  elif SIRIUS_state == "enabled":
    
    global _Tempcum
    global DOY
    
    for day in range(1,300):
      date_current_day = sowing_date + datetime.timedelta(day) 	        # Date of the current day for a given elapsed_time
      _current_temperature = meteo_dF[(meteo_dF["year"] == date_current_day.year) & (meteo_dF["month"] == date_current_day.month) & (meteo_dF["day"] == date_current_day.day)]['TM']
      current_temperature = _current_temperature[_current_temperature.last_valid_index()]
      _Tempcum += max(Tbase,current_temperature)
      DOY = int(date_current_day.strftime('%j'))
      if DOY == 365:
        DOY = 1
      else:
        DOY += 1
      Apex_Sirius_dico_df['Elapsed_time'].append(day)
      Apex_Sirius_dico_df['Temperature'].append(current_temperature)
      Apex_Sirius_dico_df['Temp_cum'].append(_Tempcum)
      Apex_Sirius_dico_df['Daylength'].append(duree_du_jour(latitude,DOY))
      Apex_Sirius_dico_df['Num_plante'].append(StA.num_plante)
      Apex_Sirius_dico_df['Genotype'].append(StA.geno)
      Apex_Sirius_dico_df['PN'].append(StA.pn)
      Apex_Sirius_dico_df['LN'].append(StA.ln)
      Apex_Sirius_dico_df['Sumtemp'].append(StA.sumtemp)
      Apex_Sirius_dico_df['Vern_rate'].append(StA.vern_rate)
      Apex_Sirius_dico_df['Vern_prog'].append(StA.vern_prog)
      Apex_Sirius_dico_df['Vern_flag'].append(StA.vrn)
      Apex_Sirius_dico_df['Debut_ppd_flag'].append(StA.debut_ppd)
      Apex_Sirius_dico_df['Fin_ppd_flag'].append(StA.photop_flag)
      Apex_Sirius_dico_df['Ln_pot'].append(StA.Ln_pot)
      Apex_Sirius_dico_df['Var_L_min'].append(StA.var_Lmin)
      Apex_Sirius_dico_df['Ln_app'].append(StA.Ln_app)
      Apex_Sirius_dico_df['Ln_final'].append(StA.Ln_final)
      if _Tempcum >= Dse_heterogeneous[StA.num_plante]:
        StA.sumtemp += max(Tbase,current_temperature)
        
        if StA.ln < Ldecr:
          StA.ln = phyllo_decr * StA.sumtemp /phyll_adjust(StA.geno)
        elif Ldecr <= StA.ln < Lincr:
          StA.ln = StA.sumtemp /phyll_adjust(StA.geno)
        elif StA.ln >= Lincr:
          StA.ln = phyllo_incr * StA.sumtemp /phyll_adjust(StA.geno)
        
        StA.pn = 2 * StA.ln + 4
        # Vernalization
        if StA.vrn == False:
          StA.vern_rate = vrate(current_temperature,StA.geno)
          StA.vern_prog += StA.vern_rate
          StA.vern_rate = 0
          if StA.vern_prog >= 1 or StA.pn > Lmax: #the vernalization is progressing
            StA.vrn = True
            StA.var_Lmin = max(StA.var_Lmin, StA.pn)
          else:
            StA.Ln_pot = Lmax - (Lmax - StA.var_Lmin) * StA.vern_prog
            if StA.pn >= StA.Ln_pot:
              StA.vrn = True
              StA.var_Lmin = max((StA.Ln_pot + StA.pn)/2.0, StA.var_Lmin)
        # Photoperiod
        if StA.vrn == True and StA.ln > 1.5:
          if StA.photop_flag == False:
            StA.debut_ppd = True
            if duree_du_jour(latitude,DOY) > DLsat:
              StA.Ln_final = StA.var_Lmin
              StA.photop_flag = True
            else:
              StA.Ln_app = StA.var_Lmin + SLDL[StA.geno] * (DLsat - duree_du_jour(latitude,DOY))
              #Sortie finale de la s�rie de tests
              if 0.5 * StA.Ln_app <= StA.ln: # Used to determine the number of visible leaves EDIT (It's rather the number of emitted primordia)
                StA.photop_flag = True
                StA.Ln_app = StA.Ln_app
                MSLn_app[StA.num_plante] = StA.Ln_app
                
                StA.Ln_final = int(StA.Ln_app)+int(random.random()+StA.Ln_app%1)
                dico_stades[StA.num_plante][(1,)]["Ln_final"] = StA.Ln_final
                
                t_beg_reg_ind = dico_stades[StA.num_plante][(1,)]["Ln_final"]-t_beg_reg[StA.geno]
                t_beg_reg_ind_Tht[StA.num_plante] = leaf_emerg_date(t_beg_reg_ind, (1,), StA.geno, StA.num_plante) + 1.6*phyll_adjust(StA.geno)
    _Tempcum = 0
    date_current_day = sowing_date + datetime.timedelta(2) 	        # Date of the current day for a given elapsed_time
    DOY = int(date_current_day.strftime('%j'))
    useGroup(3)

group 3:

#INITIALISATION DU MODELE 
###########################

Apex(StA):
  global elapsed_time
  global Tempcum
  global DOY
  global date_current_day
  
  
  if StA.n < N_p_s and initialization_Flag[StA.num_plante] == True:
    StA.sumtemp += max(Tbase,Temperature)
    StA.time += max(Tbase,Temperature)
    
    if StA.time >= Pls[StA.geno]:
      StL = Leaf(StA.num_plante, StA.geno, StA.tiller, StA.n + 1)
      StBu_p = Bud_primord(StA.num_plante, StA.geno, StA.tiller, StA.n + 1)
      StBu_p.sumtemp = StA.time%Pls[StA.geno]
      #StBu_p.tiller_incl = StA.tiller_incl
      StI = Internode(StA.num_plante, StA.geno, StA.tiller, StA.n + 1)
      StA.time = StA.time % Pls[StA.geno]
      StL.date_emerg = leaf_emerg_date(StL.n, StL.tiller, StL.geno, StL.num_plante)
      
      # Formatting phytomer scaled dictionnaries
      current_internode_length[StL.num_plante][StL.tiller][StL.n] = 0 
      Sh_max[StA.num_plante][StL.tiller][StL.n] = 0.0
      final_blade_length[StL.num_plante][StL.tiller][StL.n] = 0        # Formater le dico des longueurs finales
      final_blade_length[StL.num_plante][StL.tiller][StL.n] = 0
      current_sheath_length[StL.num_plante][StL.tiller][StL.n] = 0
      dead_sheath_length[StL.num_plante][StL.tiller][StL.n] = 0
      
      hazard_dict_organ[StL.num_plante][StL.tiller][StL.n] = {}
      hazard_dict_organ[StL.num_plante][StL.tiller][StL.n]["blade_inclination"] = Phi_zen_B[StL.geno] + random.uniform(-blade_incl_hazard, blade_incl_hazard)
      
      ### End of dictionnaries formatting ###
      
      blade_phyllotaxy(StL.n, StL.tiller, StL.num_plante, N_I_el[StL.geno], Phi_azi_B, blade_azi_hazard)
      
      StL.azimuth = hazard_dict_organ[StL.num_plante][StL.tiller][StL.n]["blade_azimuth"]
      #print "angle", StI.tiller, "n", StI.n, StI.azimuth
      nproduce [Bud_primord(StBu_p)]Internode(StI)Leaf(StL)Apex(StA)
      StA.n += 1
    else:
      produce Apex(StA)
      
  elif StA.n >= N_p_s :
    #print "Moi, numero",StA.num_plante,"J'ai fini l'initialisation"
    StA.sumtemp = 0
    StA.time = 0
    initialization_Flag[StA.num_plante] = False
    #lstring_gp3 = open("./WALTer_Lstring_group3.txt", "w")
    #lstring_gp3.close()
  if not np.any(initialization_Flag.values()):
    Tempcum = 0
    date_current_day = sowing_date + datetime.timedelta(elapsed_time)
    DOY = int(date_current_day.strftime('%j'))
    elapsed_time = 0
    useGroup(4)

Bud_primord(StBu_p):
  StBu_p.sumtemp += max(Tbase,Temperature)
  
  if StBu_p.sumtemp >= Delta_b * Pls[StBu_p.geno] and StBu_p.competent_flag == False:
    StBu_p.competent_flag = True
    new_tiller_name = StBu_p.tiller + (StBu_p.n,)
    StBu = Bud(StBu_p.num_plante, StBu_p.geno, new_tiller_name, 0, StBu_p.sumtemp%Pls[StBu_p.geno]) #On discr�tise proprement l'accumulation des temp�ratures en transmettant le surplus de temp�rature stock�e � l'Bud n�oform�
    StBu.sumtemp = StBu_p.sumtemp%Pls[StBu_p.geno]
    StBu.time = StBu_p.sumtemp%Pls[StBu_p.geno]
    
    # TODO : virer cette ligne si inutile ?
    # Formatting dictionnaries
    ## 
    date_emission[StBu.num_plante][new_tiller_name] = Tempcum
    Hcol_max[StBu.num_plante][new_tiller_name] = 0
    Hcol_dead[StBu.num_plante][new_tiller_name] = 0
    delta_H[StBu.num_plante][new_tiller_name] = 0
    tiller_surface[(StBu.num_plante,new_tiller_name)] = 0.0
    dico_cut_dead_blades[StBu.num_plante][new_tiller_name] = []
    
    hazard_dict_organ[StBu.num_plante][new_tiller_name] = {}
    hazard_dict_axis[StBu.num_plante][new_tiller_name] = {}
    hazard_dict_axis[StBu.num_plante][new_tiller_name]["tiller_azimuth"] = Phi_azi_T + random.uniform(-till_azi_hazard, till_azi_hazard)
    hazard_dict_axis[StBu.num_plante][new_tiller_name]["tiller_zenith"] = Phi_zen_T + random.uniform(-till_zen_hazard, till_zen_hazard)
    dico_stades[StBu.num_plante][new_tiller_name] = {"Age" : 0 ,"Blade_Transiflo" : False, "Transiflo" : [False,10000,0], "Montaison" : [False,10000,0],"Ear_emergence" : False, "Epiaison" : [False,10000,0], "Flo" : [False,10000,0], "Maturite" : [False,10000,0], "Ln_final":"undefined", "End_internode_elongation" : False, "Senescence_flag_leaf" : [False, 10000, 0]}
    
    ## Phytomer scaled dictionnaries
    current_internode_length[StBu.num_plante][StBu.tiller] = {}
    Sh_max[StBu.num_plante][StBu.tiller] = {0: 0.0}
    final_blade_length[StBu.num_plante][StBu.tiller] = {}
    current_sheath_length[StBu.num_plante][StBu.tiller] = {0: l_c}
    dead_sheath_length[StBu.num_plante][StBu.tiller] = {0:0.0}
    leaf_emergence[StBu.num_plante][StBu.tiller] = {1: (0,0)}
    
    ### END OF DICTIONNARIES FORMATAGE ###
    
    StCPB = CutPointBud(StBu.num_plante, StBu.geno, StBu.tiller)
    StCPB.tiller = StBu.tiller
    StCPB.tiller_zen = hazard_dict_axis[StCPB.num_plante][StCPB.tiller]["tiller_zenith"]
    
    dico_cut_fantom_axes[StBu.num_plante][StBu.tiller] = False
    produce CutPointBud(StCPB)[Bud(StBu)]

#remettre elapsed_time � 0
# TODO : exporter la lstring produite � la fin du group 3 pour l'importer?

Bud(StBu):
  StBu.nb_emerg_leaves = nb_emerged_leaves(Tempcum, StBu.tiller, StBu.geno, StBu.Ln_final)
  
  StBu.sumtemp += max(Tbase,Temperature)
  StBu.nb_j += time_step
  StBu.age += max(Tbase,Temperature)
  StBu.time += max(Tbase,Temperature)
  
  #Production de phytom�res
  if StBu.time >= Pls[StBu.geno]:
    if GAI_prox[StBu.num_plante] <= GAI_c[StBu.geno] or cohort_number(StBu.tiller) < 8: #TODO peut �tre � enlever sui on est encore dans la graine?
      StL = Leaf(StBu.num_plante, StBu.geno, StBu.tiller, StBu.n + 1)
      StBu_p = Bud_primord(StBu.num_plante, StBu.geno, StBu.tiller, StBu.n + 1)
      StBu_p.sumtemp = StBu.time%Pls[StBu.geno]
      StI = Internode(StBu.num_plante, StBu.geno, StBu.tiller, StBu.n + 1)
      StBu.time = StBu.time % Pls[StBu.geno]
      StL.date_emerg = leaf_emerg_date(StL.n, StL.tiller, StL.geno, StL.num_plante)
      
      # Formatting phytomer scaled dictionnaries
      current_internode_length[StL.num_plante][StL.tiller][StL.n] = 0 
      Sh_max[StL.num_plante][StL.tiller][StL.n] = 0.0
      final_blade_length[StL.num_plante][StL.tiller][StL.n] = 0        # Formater le dico des longueurs finales
      final_blade_length[StL.num_plante][StL.tiller][StL.n] = 0
      current_sheath_length[StL.num_plante][StL.tiller][StL.n] = 0
      dead_sheath_length[StL.num_plante][StL.tiller][StL.n] = 0
      
      hazard_dict_organ[StL.num_plante][StL.tiller][StL.n] = {}
      hazard_dict_organ[StL.num_plante][StL.tiller][StL.n]["blade_inclination"] = Phi_zen_B[StL.geno] + random.uniform(-blade_incl_hazard, blade_incl_hazard)
      
      ### End of dictionnaries formatting ###
      
      blade_phyllotaxy(StL.n, StL.tiller, StL.num_plante, N_I_el[StL.geno], Phi_azi_B, blade_azi_hazard)
      StL.azimuth = hazard_dict_organ[StL.num_plante][StL.tiller][StL.n]["blade_azimuth"]
      nproduce [Bud_primord(StBu_p)]Internode(StI)Leaf(StL)Bud(StBu)
      StBu.n += 1
    else:
      dico_cut_fantom_axes[StBu.num_plante][StBu.tiller] = True
  else:
    nproduce Bud(StBu)

Leaf(StL):
  StL.sumtemp += max(Tbase,Temperature)
  StL.age += time_step
  produce Leaf(StL)
  

Internode(StI):
  StI.diameter = d_I[StI.geno]
  StI.age += time_step
  StI.sumtemp += max(Tbase,Temperature)
  produce Internode(StI)

group 4:

Apex(StA):
  
  
  #Il ne se passe rien avant emergence
  if Tempcum >= Dse_heterogeneous[StA.num_plante]:
    # Tant que l'axe n'a pas �t� d�sign� pour r�gresser, tout fonctionne normalement
    if StA.tiller in axis_census[StA.num_plante] and axis_census[StA.num_plante][StA.tiller]["Stop_growth_flag"] == True:
      pass
    else:
      StA.age += time_step
      StA.sumtemp += max(Tbase,Temperature)
      StA.time += max(Tbase,Temperature)
      
      # Transition florale du brin-ma�tre
      # TODO possible de d�finir les dimensions des limbes ici?
      if StA.tiller == (1,):
        if StA.n >= StA.Ln_final and StA.transiflo == False: #Si brin-maitre ET nombre final de feuilles atteint on d�clenche la transiflo
          StA.transiflo = True
          dico_stades[StA.num_plante][StA.tiller]["Transiflo"] = [True, Tempcum, DOY]
          for axis in dico_stades[StA.num_plante].keys():
            if axis != (1,):
              dico_stades[StA.num_plante][axis]["Transiflo"][1] = dico_stades[StA.num_plante][(1,)]["Transiflo"][1] + round(transiflo_shift(axis, StA.geno), 2)
          StA.date_de_flo = leaf_emerg_date((StA.Ln_final), StA.tiller, StA.geno, StA.num_plante) + (ED_FB + ED_S + Delta_lflf) * phyll_adjust(StA.geno)
          dico_stades[StA.num_plante][StA.tiller]["Flo"][1] = StA.date_de_flo
          StA.date_epi = StA.date_de_flo - Delta_hf * phyll_adjust(StA.geno)
          dico_stades[StA.num_plante][StA.tiller]["Epiaison"][1] = dico_stades[StA.num_plante][StA.tiller]["Flo"][1] - Delta_hf * phyll_adjust(StA.geno)
          StA.date_mat = dico_stades[StA.num_plante][StA.tiller]["Epiaison"][1] + Delta_hm
          dico_stades[StA.num_plante][StA.tiller]["Maturite"][1] = dico_stades[StA.num_plante][StA.tiller]["Epiaison"][1] + Delta_hm
          StE = Ear(StA.num_plante, StA.geno, StA.tiller, StA.n)
          StE.emerged = True
          StP = Peduncle(StA.num_plante, StA.geno, StA.tiller, StA.n)
          StP.final_length = L_P[StP.geno]
          StAR = Apex_R(StA.num_plante, StA.geno, StA.tiller, StA.n)
          StAR.sumtemp = StA.sumtemp
          StAR.Ln_final = StA.Ln_final
          produce Peduncle(StP)Ear(StE)Apex_R(StAR)
          
      # Transition florale des talles
      elif StA.tiller != (1,) and StA.transiflo == False:
        if Tempcum >= dico_stades[StA.num_plante][StA.tiller]["Transiflo"][1]:
          StA.transiflo = True
          dico_stades[StA.num_plante][StA.tiller]["Transiflo"][0] = True
          dico_stades[StA.num_plante][StA.tiller]["Transiflo"][2] = DOY
          StA.Ln_final = StA.n
          dico_stades[StA.num_plante][StA.tiller]["Ln_final"] = StA.Ln_final
          StA.date_de_flo = leaf_emerg_date((StA.Ln_final), StA.tiller, StA.geno,StA.num_plante) + (ED_FB + ED_S + Delta_lflf) * phyll_adjust(StA.geno)
          dico_stades[StA.num_plante][StA.tiller]["Flo"][1] = StA.date_de_flo
          StA.date_epi = StA.date_de_flo - Delta_hf * phyll_adjust(StA.geno)
          dico_stades[StA.num_plante][StA.tiller]["Epiaison"][1] = dico_stades[StA.num_plante][StA.tiller]["Flo"][1] - Delta_hf * phyll_adjust(StA.geno)
          #if StA.tiller in liste_talles:
            #print StA.tiller , dico_stades[StA.num_plante][StA.tiller]["Epiaison"]
          StA.date_mat = dico_stades[StA.num_plante][StA.tiller]["Epiaison"][1] + Delta_hm
          dico_stades[StA.num_plante][StA.tiller]["Maturite"][1] = dico_stades[StA.num_plante][StA.tiller]["Epiaison"][1] + Delta_hm
          StE = Ear(StA.num_plante, StA.geno, StA.tiller, StA.n)
          StE.emerged = True
          StP = Peduncle(StA.num_plante, StA.geno, StA.tiller, StA.n)
          StP.final_length = L_P[StP.geno]
          StAR = Apex_R(StA.num_plante, StA.geno, StA.tiller, StA.n)
          StAR.sumtemp = StA.sumtemp
          StAR.Ln_final = StA.Ln_final
          produce Peduncle(StP)Ear(StE)Apex_R(StAR)
      
      # Production de primordia
      if StA.transiflo == False and StA.time >= Pls[StA.geno]  :
        StL = Leaf(StA.num_plante, StA.geno, StA.tiller, StA.n + 1)
        StBu_p = Bud_primord(StA.num_plante, StA.geno, StA.tiller, StA.n + 1)
        StBu_p.sumtemp = StA.time % Pls[StA.geno]
        #StBu_p.tiller_incl = StA.tiller_incl
        StI = Internode(StA.num_plante, StA.geno, StA.tiller, StA.n + 1)
        StA.time = StA.time % Pls[StA.geno]
        StL.date_emerg = leaf_emerg_date(StL.n, StL.tiller, StL.geno, StL.num_plante)
        
        # Formatting phytomer scaled dictionnaries
        current_internode_length[StL.num_plante][StL.tiller][StL.n] = 0 
        Sh_max[StA.num_plante][StL.tiller][StL.n] = 0.0
        final_blade_length[StL.num_plante][StL.tiller][StL.n] = 0        # Formater le dico des longueurs finales
        final_blade_length[StL.num_plante][StL.tiller][StL.n] = 0
        current_sheath_length[StL.num_plante][StL.tiller][StL.n] = 0
        dead_sheath_length[StL.num_plante][StL.tiller][StL.n] = 0
        
        hazard_dict_organ[StL.num_plante][StL.tiller][StL.n] = {}
        hazard_dict_organ[StL.num_plante][StL.tiller][StL.n]["blade_inclination"] = Phi_zen_B[StL.geno] + random.uniform(-blade_incl_hazard, blade_incl_hazard)
        
        ### End of dictionnaries formatting ###
        
        blade_phyllotaxy(StL.n, StL.tiller, StL.num_plante, N_I_el[StL.geno], Phi_azi_B, blade_azi_hazard)
        
        StL.azimuth = hazard_dict_organ[StL.num_plante][StL.tiller][StL.n]["blade_azimuth"]
        nproduce [Bud_primord(StBu_p)]Internode(StI)Leaf(StL)Apex(StA)
        
        StA.n += 1
      else:
        #Ecriture dans fichiers
        Apex_dico_df['Elapsed_time'].append(elapsed_time)
        Apex_dico_df['Temperature'].append(Temperature)
        Apex_dico_df['Temp_cum'].append(Tempcum)
        Apex_dico_df['Time_count'].append(StA.time)
        Apex_dico_df['Sum_temp'].append(StA.sumtemp)
        Apex_dico_df['Current_PAR'].append(current_PAR)
        Apex_dico_df['Num_plante'].append(StA.num_plante)
        Apex_dico_df['Genotype'].append(StA.geno)
        Apex_dico_df['Num_talle'].append(str(StA.tiller))
        Apex_dico_df['Num_cohorte'].append(cohort_number(StA.tiller))
        Apex_dico_df['Nb_phyto_emi'].append(StA.n)
        if Tempcum  >= Dse_heterogeneous[StA.num_plante]:
          Apex_dico_df['Nb_emerged_leaf'].append(max(leaf_emergence[StA.num_plante][StA.tiller].keys()))
        else:
          Apex_dico_df['Nb_emerged_leaf'].append(0)
        Apex_dico_df['Transiflo_flag'].append(StA.transiflo)
        Apex_dico_df['STOP_init_flag'].append(StA.STOP_init)
        Apex_dico_df['Transiflo_DOY'].append(dico_stades[StA.num_plante][StA.tiller]["Transiflo"][2])
        Apex_dico_df['Ln_final'].append(StA.Ln_final)
        produce Apex(StA)
        
  #Ecriture dans fichiers
  Apex_dico_df['Elapsed_time'].append(elapsed_time)
  Apex_dico_df['Temperature'].append(Temperature)
  Apex_dico_df['Temp_cum'].append(Tempcum)
  Apex_dico_df['Time_count'].append(StA.time)
  Apex_dico_df['Sum_temp'].append(StA.sumtemp)
  Apex_dico_df['Current_PAR'].append(current_PAR)
  Apex_dico_df['Num_plante'].append(StA.num_plante)
  Apex_dico_df['Genotype'].append(StA.geno)
  Apex_dico_df['Num_talle'].append(str(StA.tiller))
  Apex_dico_df['Num_cohorte'].append(cohort_number(StA.tiller))
  Apex_dico_df['Nb_phyto_emi'].append(StA.n)
  if Tempcum  >= Dse_heterogeneous[StA.num_plante]:
    Apex_dico_df['Nb_emerged_leaf'].append(max(leaf_emergence[StA.num_plante][StA.tiller].keys()))
  else:
    Apex_dico_df['Nb_emerged_leaf'].append(0)
  Apex_dico_df['Transiflo_flag'].append(StA.transiflo)
  Apex_dico_df['STOP_init_flag'].append(StA.STOP_init)
  Apex_dico_df['Transiflo_DOY'].append(dico_stades[StA.num_plante][StA.tiller]["Transiflo"][2])
  Apex_dico_df['Ln_final'].append(StA.Ln_final)


Apex_R(StAR):
  
  if StAR.tiller in axis_census[StAR.num_plante] and axis_census[StAR.num_plante][StAR.tiller]["Stop_growth_flag"] == True:
    pass
  else:
    StAR.sumtemp += max(Tbase,Temperature)
    
    #Passage � Montaison
    if StAR.mont == False:
      # TODO : pourquoi ces tests en deux etapes?
      if max(leaf_emergence[StAR.num_plante][StAR.tiller].keys()) >= StAR.Ln_final - 4:
        if Tempcum >= leaf_emerg_date(StAR.Ln_final - 4, StAR.tiller, StAR.geno, StAR.num_plante) + (ED_B + ED_S) * phyll_adjust(StAR.geno): #Test pour savoir si on est � montaison (ligulation de feuille n-4)
          
          # Identification des talles destin�es � mourir
          # TODO : regression � la josette masle, obsolete � enlever
          for axis in leaf_emergence[StAR.num_plante].keys():
            if max(leaf_emergence[StAR.num_plante][axis].keys()) < 4:    # Si le nombre de feuilles sur l'axe est inf�rieur � 3
              tiller_death[StAR.num_plante][dico_stades[StAR.num_plante][axis]["Age"]] = []
              
          for axis in leaf_emergence[StAR.num_plante].keys():
            if max(leaf_emergence[StAR.num_plante][axis].keys()) < 4:    # Si le nombre de feuilles sur l'axe est inf�rieur � 3
              tiller_death[StAR.num_plante][dico_stades[StAR.num_plante][axis]["Age"]].append(axis)
          
          #### Fin de suppression ####
          
          dico_stades[StAR.num_plante][StAR.tiller]["Montaison"] = (True,Tempcum, DOY)
          StAR.mont = True
        
    # Passage � �piaison
    if Tempcum >= dico_stades[StAR.num_plante][StAR.tiller]["Epiaison"][1] and StAR.epi == False:
      dico_stades[StAR.num_plante][StAR.tiller]["Epiaison"][0] = True
      dico_stades[StAR.num_plante][StAR.tiller]["Epiaison"][2] = DOY
      StAR.epi = True
    
    # Passage � floraison
    if Tempcum >= dico_stades[StAR.num_plante][StAR.tiller]["Flo"][1] and StAR.flo == False:
      dico_stades[StAR.num_plante][StAR.tiller]["Flo"][0] = True
      dico_stades[StAR.num_plante][StAR.tiller]["Flo"][2] = DOY
      StAR.flo = True
    
    #Passage � maturit�
    if Tempcum >= dico_stades[StAR.num_plante][StAR.tiller]["Maturite"][1] and StAR.mat == False:
      dico_stades[StAR.num_plante][StAR.tiller]["Maturite"][0] = True
      dico_stades[StAR.num_plante][StAR.tiller]["Maturite"][2] = DOY
      StAR.mat = True
      
    if write_output_file["Apex_R"]:
      Apex_R_dico_df['Elapsed_time'].append(elapsed_time)
      Apex_R_dico_df['DOY'].append(DOY)
      Apex_R_dico_df['Temperature'].append(Temperature)
      Apex_R_dico_df['Temp_cum'].append(Tempcum)
      Apex_R_dico_df['Sum_temp'].append(StAR.sumtemp)
      Apex_R_dico_df['Num_cohorte'].append(cohort_number(StAR.tiller))
      Apex_R_dico_df['Ln_final'].append(StAR.Ln_final)
      Apex_R_dico_df['Num_plante'].append(StAR.num_plante)
      Apex_R_dico_df['Genotype'].append(StAR.geno)
      Apex_R_dico_df['Num_talle'].append(StAR.tiller)
      Apex_R_dico_df['Mont_flag'].append(StAR.mont)
      Apex_R_dico_df['Mont_DOY'].append(dico_stades[StAR.num_plante][StAR.tiller]["Montaison"][2])
      Apex_R_dico_df['Flo_flag'].append(StAR.flo)
      Apex_R_dico_df['Flo_DOY'].append(dico_stades[StAR.num_plante][StAR.tiller]["Flo"][2])
      Apex_R_dico_df['Death_flag'].append(StAR.death_flag)
      Apex_R_dico_df['Date_epiaison'].append(dico_stades[StAR.num_plante][StAR.tiller]["Epiaison"][1])
      Apex_R_dico_df['Epi_DOY'].append(dico_stades[StAR.num_plante][StAR.tiller]["Epiaison"][2])
      Apex_R_dico_df['Date_de_flo'].append(dico_stades[StAR.num_plante][StAR.tiller]["Flo"][1])
      Apex_R_dico_df['Mat_DOY'].append(dico_stades[StAR.num_plante][StAR.tiller]["Maturite"][2])
      Apex_R_dico_df['Date_de_maturite'].append(dico_stades[StAR.num_plante][StAR.tiller]["Maturite"][1])
    produce Apex_R(StAR)

Bud_primord(StBu_p):
  if Tempcum >= Dse_heterogeneous[StBu_p.num_plante]:
    # Tant que l'axe n'a pas �t� d�sign� pour r�gresser, tout fonctionne normalement
    if StBu_p.tiller in axis_census[StBu_p.num_plante] and axis_census[StBu_p.num_plante][StBu_p.tiller]["Stop_growth_flag"] == True:
      pass
    else:
      StBu_p.sumtemp += max(Tbase, Temperature)
      if StBu_p.sumtemp >= Delta_b * Pls[StBu_p.geno] and StBu_p.competent_flag == False:
        StBu_p.competent_flag = True
        new_tiller_name = StBu_p.tiller + (StBu_p.n,)
        StBu = Bud(StBu_p.num_plante, StBu_p.geno, new_tiller_name, 0, StBu_p.sumtemp % Pls[StBu_p.geno]) #On discr�tise proprement l'accumulation des temp�ratures en transmettant le surplus de temp�rature stock�e � l'Bud n�oform�
        StBu.sumtemp = StBu_p.sumtemp % Pls[StBu_p.geno]
        StBu.time = StBu_p.sumtemp % Pls[StBu_p.geno]
        
        # Etape de formatage des dictionnaire (on cr�� un nouveau sous-dico avec le nouvel embanchement)
        #if StBu.n == 0:
        
        # Formatting dictionnaries
        ##
        date_emission[StBu.num_plante][new_tiller_name] = Tempcum
        Hcol_max[StBu.num_plante][new_tiller_name] = 0
        Hcol_dead[StBu.num_plante][new_tiller_name] = 0
        delta_H[StBu.num_plante][new_tiller_name] = 0
        tiller_surface[(StBu.num_plante,new_tiller_name)] = 0.0
        leaf_emergence[StBu.num_plante][StBu.tiller] = {1: (0,0)}
        
        hazard_dict_organ[StBu.num_plante][new_tiller_name] = {}
        hazard_dict_axis[StBu.num_plante][new_tiller_name] = {}
        hazard_dict_axis[StBu.num_plante][new_tiller_name]["tiller_azimuth"] = Phi_azi_T + random.uniform(-till_azi_hazard, till_azi_hazard)
        hazard_dict_axis[StBu.num_plante][new_tiller_name]["tiller_zenith"] = Phi_zen_T + random.uniform(-till_zen_hazard, till_zen_hazard)
        
        dico_cut_dead_blades[StBu.num_plante][new_tiller_name] = []
        
        dico_stades[StBu.num_plante][new_tiller_name] = {"Age" : 0 ,"Blade_Transiflo" : False, "Transiflo" : [False,10000,0], "Montaison" : [False,10000,0],"Ear_emergence" : False, "Epiaison" : [False,10000,0], "Flo" : [False,10000,0], "Maturite" : [False,10000,0], "Ln_final":"undefined", "End_internode_elongation" : False, "Senescence_flag_leaf" : [False, 10000, 0]}
        
        ## Phytomer scaled dictionnaries
        current_internode_length[StBu.num_plante][StBu.tiller] = {}
        Sh_max[StBu.num_plante][StBu.tiller] = {0: 0.0}
        final_blade_length[StBu.num_plante][StBu.tiller] = {}
        current_sheath_length[StBu.num_plante][StBu.tiller] = {0: l_c}
        dead_sheath_length[StBu.num_plante][StBu.tiller] = {0:0.0}
        
        leaf_emergence[StBu.num_plante][StBu.tiller] = {1: (0,0)}
        
        ### END OF DICTIONNARIES FORMATAGE ###
        
        StCPB = CutPointBud(StBu.num_plante, StBu.geno, StBu.tiller)
        StCPB.tiller = StBu.tiller
        StCPB.tiller_zen = hazard_dict_axis[StCPB.num_plante][StCPB.tiller]["tiller_zenith"]
        dico_cut_fantom_axes[StBu.num_plante][StBu.tiller] = False
        produce CutPointBud(StCPB)[Bud(StBu)]

Bud(StBu):
  
  # Tout est inactif jusqu'� l'�mergence de la premi�re feuille de la plante
  if Tempcum >= Dse_heterogeneous[StBu.num_plante]:
    # Tant que l'axe n'a pas �t� d�sign� pour r�gresser, tout fonctionne normalement
    if StBu.tiller in axis_census[StBu.num_plante] and axis_census[StBu.num_plante][StBu.tiller]["Stop_growth_flag"] == True:
      pass
    else:
      StBu.sumtemp += max(Tbase,Temperature)
      StBu.nb_j += time_step
      StBu.age += max(Tbase,Temperature)
      StBu.time += max(Tbase,Temperature)
      
      #Transition florale du bourgeon
      if Tempcum >= dico_stades[StBu.num_plante][StBu.tiller]["Transiflo"][1] and StBu.transiflo == False:
        StBu.transiflo = True
        dico_stades[StBu.num_plante][StBu.tiller]["Transiflo"][0] = True
        dico_stades[StBu.num_plante][StBu.tiller]["Transiflo"][2] = DOY
        StBuR = Bud_R(StBu.num_plante, StBu.geno, StBu.tiller, StBu.n)
        StBuR.nb_j = StBu.nb_j
        StBuR.sumtemp = StBu.sumtemp # TODO on aurait pu le concat�ner en une ligne
        StBu.Ln_final = StBu.n
        StBuR.Ln_final = StBu.Ln_final
        StBuR.emerg = StBu.emerg  # .emerg est un bool�en
        
        # Calcul et stockage des dates de stade
        dico_stades[StBu.num_plante][StBu.tiller]["Ln_final"] = StBu.Ln_final
        StBuR.date_de_flo = leaf_emerg_date((StBu.Ln_final), StBu.tiller, StBu.geno, StBu.num_plante) + (ED_FB + ED_S + Delta_lflf) * phyll_adjust(StBu.geno)
        dico_stades[StBu.num_plante][StBu.tiller]["Flo"][1] = StBuR.date_de_flo
        StBuR.date_epi = StBuR.date_de_flo - (Delta_hf * phyll_adjust(StBuR.geno))
        dico_stades[StBu.num_plante][StBu.tiller]["Epiaison"][1] = StBuR.date_epi
        StE = Ear(StBu.num_plante, StBu.geno, StBu.tiller, StBu.n)
        StP = Peduncle(StBu.num_plante, StBu.geno, StBu.tiller, StBu.n)
        StP.final_length = L_P[StP.geno]
        produce Peduncle(StP)Ear(StE)Bud_R(StBuR)
        
      # Producting vegetative phytomers
      if StBu.time > Pls[StBu.geno] and StBu.transiflo == False:
        if GAI_prox[StBu.num_plante] <= GAI_c[StBu.geno] and cohort_number(StBu.tiller) < cohorte_max:
          StL = Leaf(StBu.num_plante, StBu.geno, StBu.tiller, StBu.n + 1)
          StBu_p = Bud_primord(StBu.num_plante, StBu.geno, StBu.tiller, StBu.n + 1)
          StBu_p.sumtemp = StBu.time % Pls[StBu.geno]
          StI = Internode(StBu.num_plante, StBu.geno, StBu.tiller, StBu.n + 1)
          StBu.time = StBu.time % Pls[StBu.geno]
          StL.date_emerg = leaf_emerg_date(StL.n, StL.tiller, StL.geno, StL.num_plante)
          
          # Formatting phytomer scaled dictionnaries
          current_internode_length[StL.num_plante][StL.tiller][StL.n] = 0
          Sh_max[StL.num_plante][StL.tiller][StL.n] = 0.0
          final_blade_length[StL.num_plante][StL.tiller][StL.n] = 0
          current_sheath_length[StL.num_plante][StL.tiller][StL.n] = 0
          dead_sheath_length[StL.num_plante][StL.tiller][StL.n] = 0
          
          hazard_dict_organ[StL.num_plante][StL.tiller][StL.n] = {}
          hazard_dict_organ[StL.num_plante][StL.tiller][StL.n]["blade_inclination"] = Phi_zen_B[StL.geno] + random.uniform(-blade_incl_hazard, blade_incl_hazard)
          hazard_dict_organ[StL.num_plante][StL.tiller][StL.n]["blade_azimuth"] = Phi_azi_B + random.uniform(-blade_azi_hazard, blade_azi_hazard)
          
          ### End of dictionnaries formatting ###
          
          blade_phyllotaxy(StL.n, StL.tiller, StL.num_plante, N_I_el[StL.geno], Phi_azi_B, blade_azi_hazard)
          
          StL.azimuth = hazard_dict_organ[StL.num_plante][StL.tiller][StL.n]["blade_azimuth"]
          nproduce [Bud_primord(StBu_p)]Internode(StI)Leaf(StL)
          StBu.n += 1
        
        else:
          dico_cut_fantom_axes[StBu.num_plante][StBu.tiller] = True  
        
        #C'est aussi le moment de potentiellement �merger
        if Tempcum >= leaf_emerg_date(StBu.tiller[len(StBu.tiller)-1] + 2,StBu.tiller[0:len(StBu.tiller)-1] , StBu.geno, StBu.num_plante) and StBu.emerg == False: #TODO am�liorer la m�thode de calcul comme dans la fonction de synchrone correspondance (n=StBu.tiller[-1], )
          StBu.emerg = True
          StBu.Tmoy = StBu.sumtemp / StBu.nb_j #TODO : OBSOLETE
          
          #if StBu.tiller in liste_talles:
            #StBu.p_debourr = 1
          #else:
            #StBu.p_debourr = 0
          
          StBu.p_debourr = proba_debourr(StBu.tiller, GAI_prox[StBu.num_plante], StBu.geno, StBu.tiller[-1], tiller_ln_final(cohort_number(StBu.tiller[0:len(StBu.tiller)-1]), dico_stades[StBu.num_plante][(1,)]["Ln_final"])) #On consulte le nombre final de feuilles de la talle m�re
          
          # Enregistrement des informations
          if write_output_file["Proba"]:
            Proba_dico_df["Elapsed_time"].append(elapsed_time)
            Proba_dico_df["Temperature"].append(Temperature)
            Proba_dico_df["Temp_cum"].append(Tempcum)
            Proba_dico_df["Num_plante"].append(StBu.num_plante)
            Proba_dico_df["Genotype"].append(StBu.geno)
            Proba_dico_df["Num_talle"].append(str(StBu.tiller[0:len(StBu.tiller)-1]))
            Proba_dico_df["Num_rang"].append(StBu.tiller[-1])
            Proba_dico_df["Sumtemp"].append(StBu.sumtemp)
            Proba_dico_df["GAI_prox"].append(GAI_prox[StBu.num_plante])
            Proba_dico_df["P_debourr"].append(StBu.p_debourr)
          
          if random.random() <= StBu.p_debourr:
            # Formatting dictionnaries
            ## Dictionnaries including datas about emerged organs
            ### Axis scale dictionnaries
            first_leaf_phase2[StBu.num_plante][StBu.tiller] = {"num_first_leaf_phase_2" : 0, "length_first_leaf_phase_2" : 0}
            LNfinal[StBu.num_plante][StBu.tiller] = 0
            
            axis_census[StBu.num_plante][StBu.tiller] = {"emerg_date" : Tempcum, "Stop_growth_flag" : False, "Regression_flag" : False}
            
            dico_PAR["Blade"][StBu.num_plante][StBu.tiller] = {}
            dico_PAR["Internode"][StBu.num_plante][StBu.tiller] = {}
            dico_PAR["Sheath"][StBu.num_plante][StBu.tiller] = {}
            dico_PAR["Peduncle"][StBu.num_plante][StBu.tiller] = {}
            dico_PAR["Ear"][StBu.num_plante][StBu.tiller] = {}
            dico_PAR_per_axis[StBu.num_plante][StBu.tiller] = {}
            
            ### End of dictionnaries formatting ###
            StA = Apex(StBu.num_plante, StBu.geno,StBu.tiller,StBu.n,StBu.time)
            StA.nb_emerg_leaves = StBu.nb_emerg_leaves # TODO : pourquoi ?
            #StA.tiller_incl = StBu.tiller_incl
            StA.date_sortie = Tempcum
            StA.time = StBu.time
            nproduce Apex(StA)
          else:
            dico_cut_fantom_axes[StBu.num_plante][StBu.tiller] = True
            
            #TODO habituellement, on ne met pas � jour la cha�ne, � virer?
            nproduce Bud(StBu)
        else:
          nproduce Bud(StBu)
        
      else:
        # Si c'est le moment d'emerger
        if Tempcum >= leaf_emerg_date(StBu.tiller[len(StBu.tiller)-1] + 2,StBu.tiller[0:len(StBu.tiller)-1] , StBu.geno, StBu.num_plante) and StBu.emerg == False:
          StBu.emerg = True
          StBu.Tmoy = StBu.sumtemp / StBu.nb_j #TODO : inutile
          #if StBu.tiller in liste_talles:
            #StBu.p_debourr = 1
          #else:
            #StBu.p_debourr = 0
          StBu.p_debourr = proba_debourr(StBu.tiller, GAI_prox[StBu.num_plante], StBu.geno, StBu.tiller[-1], tiller_ln_final(cohort_number(StBu.tiller[0:len(StBu.tiller)-1]), dico_stades[StBu.num_plante][(1,)]["Ln_final"])) #On consulte le nombre final de feuilles de la talle m�re
          # Enregistrement des informations
          if write_output_file["Proba"]:
            Proba_dico_df["Elapsed_time"].append(elapsed_time)
            Proba_dico_df["Temperature"].append(Temperature)
            Proba_dico_df["Temp_cum"].append(Tempcum)
            Proba_dico_df["Num_plante"].append(StBu.num_plante)
            Proba_dico_df["Genotype"].append(StBu.geno)
            Proba_dico_df["Num_talle"].append(str(StBu.tiller[0:len(StBu.tiller)-1]))
            Proba_dico_df["Num_rang"].append(StBu.tiller[-1])
            Proba_dico_df["Sumtemp"].append(StBu.sumtemp)
            Proba_dico_df["GAI_prox"].append(GAI_prox[StBu.num_plante])
            Proba_dico_df["P_debourr"].append(StBu.p_debourr)
            
          if random.random() <= StBu.p_debourr:
            # Formatting dictionnaries
            ## Dictionnaries including datas about emerged organs
            ### Axis scale dictionnaries
            first_leaf_phase2[StBu.num_plante][StBu.tiller] = {"num_first_leaf_phase_2" : 0, "length_first_leaf_phase_2" : 0}
            LNfinal[StBu.num_plante][StBu.tiller] = 0
            
            axis_census[StBu.num_plante][StBu.tiller] = {"emerg_date" : Tempcum, "Stop_growth_flag" : False, "Regression_flag" : False}
            
            dico_PAR["Blade"][StBu.num_plante][StBu.tiller] = {}
            dico_PAR["Internode"][StBu.num_plante][StBu.tiller] = {}
            dico_PAR["Sheath"][StBu.num_plante][StBu.tiller] = {}
            dico_PAR["Peduncle"][StBu.num_plante][StBu.tiller] = {}
            dico_PAR["Ear"][StBu.num_plante][StBu.tiller] = {}
            dico_PAR_per_axis[StBu.num_plante][StBu.tiller] = {}
            
            ### End of dictionnaries formatting ###
            StA = Apex(StBu.num_plante, StBu.geno,StBu.tiller,StBu.n,StBu.time)
            StA.time = StBu.time
            StA.nb_emerg_leaves = StBu.nb_emerg_leaves
            #StA.tiller_incl = StBu.tiller_incl
            StA.date_sortie = Tempcum
            nproduce Apex(StA)
          else:
            dico_cut_fantom_axes[StBu.num_plante][StBu.tiller] = True
            nproduce Bud(StBu)
        else:
          nproduce Bud(StBu)


Bud_R(StBuR):
  # Tant que l'axe n'a pas ete designe pour regresser, tout fonctionne normalement
  if StBuR.tiller in axis_census[StBuR.num_plante] and axis_census[StBuR.num_plante][StBuR.tiller]["Stop_growth_flag"] == True:
    pass
  else:
    StBuR.sumtemp += max(Tbase,Temperature)
    
    # C'est le moment ou le bourgeon a la possibilitu d'emerger
    if Tempcum >= leaf_emerg_date(StBuR.tiller[len(StBuR.tiller)-1] + 2,StBuR.tiller[0:len(StBuR.tiller)-1] , StBuR.geno, StBuR.num_plante) and StBuR.emerg == False:
      StBuR.emerg = True
      StBuR.Tmoy = StBuR.sumtemp / StBuR.nb_j # TODO inutile
      StBuR.p_debourr = proba_debourr(StBuR.tiller, GAI_prox[StBuR.num_plante], StBuR.geno, StBuR.tiller[-1], tiller_ln_final(cohort_number(StBuR.tiller[0:len(StBuR.tiller)-1]), dico_stades[StBuR.num_plante][(1,)]["Ln_final"])) # Only tillers on short internodes can emerge. Testing if the internode is elongated using the final number of leaves on the bearing tiller
      
      # Enregistrement des informations
      if write_output_file["Proba"]:
        Proba_dico_df["Elapsed_time"].append(elapsed_time)
        Proba_dico_df["Temperature"].append(Temperature)
        Proba_dico_df["Temp_cum"].append(Tempcum)
        Proba_dico_df["Num_plante"].append(StBuR.num_plante)
        Proba_dico_df["Genotype"].append(StBuR.geno)
        Proba_dico_df["Num_talle"].append(str(StBuR.tiller[0:len(StBuR.tiller)-1]))
        Proba_dico_df["Num_rang"].append(StBuR.tiller[-1])
        Proba_dico_df["Sumtemp"].append(StBuR.sumtemp)
        Proba_dico_df["GAI_prox"].append(GAI_prox[StBuR.num_plante])
        Proba_dico_df["P_debourr"].append(StBuR.p_debourr)
        
      # Si le bourgeon �merge
      if random.random() <= StBuR.p_debourr:
        # Formatting dictionnaries
        ## Dictionnaries including datas about emerged organs
        ### Axis scale dictionnaries
        first_leaf_phase2[StBuR.num_plante][StBuR.tiller] = {"num_first_leaf_phase_2" : 0, "length_first_leaf_phase_2" : 0}
        LNfinal[StBuR.num_plante][StBuR.tiller] = 0
        
        axis_census[StBuR.num_plante][StBuR.tiller] = {"emerg_date" : Tempcum, "Stop_growth_flag" : False, "Regression_flag" : False}
        
        dico_PAR["Blade"][StBuR.num_plante][StBuR.tiller] = {}
        dico_PAR["Internode"][StBuR.num_plante][StBuR.tiller] = {}
        dico_PAR["Sheath"][StBuR.num_plante][StBuR.tiller] = {}
        dico_PAR["Peduncle"][StBuR.num_plante][StBuR.tiller] = {}
        dico_PAR["Ear"][StBuR.num_plante][StBuR.tiller] = {}
        dico_PAR_per_axis[StBuR.num_plante][StBuR.tiller] = {}
        dico_cut_dead_blades[StBuR.num_plante][StBuR.tiller] = []
        
        ### End of dictionnaries formatting ###
        
        # The previously produced ear emerges
        dico_stades[StBuR.num_plante][StBuR.tiller]["Ear_emergence"] = True
        StP = Peduncle(StBuR.num_plante, StBuR.geno, StBuR.tiller, StBuR.n)
        StAR = Apex_R(StBuR.num_plante, StBuR.geno, StBuR.tiller, StBuR.n)
        StAR.Ln_final = StBuR.Ln_final
        dico_stades[StBuR.num_plante][StBuR.tiller]["Ln_final"] = StBuR.Ln_final
        StAR.date_epi = dico_stades[StBuR.num_plante][StBuR.tiller]["Epiaison"][1]
        StAR.date_de_flo = dico_stades[StBuR.num_plante][StBuR.tiller]["Flo"][1]
        StAR.date_mat = dico_stades[StBuR.num_plante][StBuR.tiller]["Maturite"][1]
        produce Apex_R(StAR)
      else:
        dico_cut_fantom_axes[StBuR.num_plante][StBuR.tiller] = True
      
    else:
      produce Bud_R(StBuR)

CutPointBud(StCPB):
  
  ### On Coupe toutes les structures produites par un Bud qui n'emergera jamais!
  #Des qu'on franchit le GAIcritique, on coupe toutes les structures qui n'ont pas emergee
  if GAI_prox[StCPB.num_plante] >= GAI_c[StCPB.geno] and StCPB.tiller not in axis_census[StCPB.num_plante]:
    dico_cut_fantom_axes[StCPB.num_plante][StCPB.tiller] = True
  if StCPB.tiller != (1,):
    if dico_cut_fantom_axes[StCPB.num_plante][StCPB.tiller] == True:
      produce % CutPointBud(StCPB)
  
  ### On coupe les structures pr�sentes sur les talles qui r�gressent par manque de rayonnement
  if Tempcum > leaf_emerg_date(dico_stades[StCPB.num_plante][(1,)]["Ln_final"]-t_beg_reg[StCPB.geno], (1,), genotype_map[StCPB.num_plante], StCPB.num_plante) + 1.6*phyll_adjust(StCPB.geno):
    #Gestion de la mort des talles
    if StCPB.tiller in axis_census[StCPB.num_plante].keys():
      if axis_census[StCPB.num_plante][StCPB.tiller]['Stop_growth_flag'] == True:
        StCPB.reg_count += Temperature
        #TODO : enlever une etape
        if Delta_SGtC > StCPB.reg_count > Delta_SGtR:
          axis_census[StCPB.num_plante][StCPB.tiller]['Regression_flag'] = True
        elif StCPB.reg_count > Delta_SGtC:
          #print StCPB.num_plante, "i will cut this mozeurfockeur : ", StCPB.tiller
          del axis_census[StCPB.num_plante][StCPB.tiller]
          produce % CutPointBud(StCPB)

Leaf(StL):
  if Tempcum >= Dse_heterogeneous[StL.num_plante]:
    # Tant que l'axe n'a pas ete designe pour regresser, tout fonctionne normalement
    if StL.tiller in axis_census[StL.num_plante] and axis_census[StL.num_plante][StL.tiller]["Stop_growth_flag"] == True:
      pass
    else:
      StL.sumtemp += max(Tbase,Temperature)
      StL.age += time_step
      if Tempcum >= StL.date_emerg:
        leaf_emergence[StL.num_plante][StL.tiller][StL.n] = (Tempcum,StL.sumtemp)
        StBl = Blade(StL.num_plante, StL.geno, StL.tiller, StL.n)
        StBl.tiller = StL.tiller # TODO inutile?
        StS = Sheath(StL.num_plante, StL.geno, StL.tiller, StL.n)  # On considere qu'a ce moment la longueur gaine est initialis�e � 0
        StS.tiller = StL.tiller  # TODO inutile?
        
        #Calcul de la taille finale que va avoir le limbe
        if StBl.n == 1:
          StBl.final_length = L_B_1[StBl.geno]
          StBl.width = blade_width(StBl.final_length, a_B_w[StBl.geno], b_B_w[StBl.geno])
          StS.final_length = sheath_length(StBl.final_length, a_S_L[StS.geno], b_S_L[StS.geno])
        else:
          previous_length = final_blade_length[StBl.num_plante][StBl.tiller][StBl.n-1]
          
          #La transition florale n'est pas passee
          if dico_stades[StBl.num_plante][StBl.tiller]["Transiflo"][0] == False:
            StBl.final_length = previous_length + s_B_1[StBl.geno]
            StBl.width = blade_width(StBl.final_length, a_B_w[StBl.geno], b_B_w[StBl.geno])
            StS.final_length = sheath_length(StBl.final_length, a_S_L[StS.geno], b_S_L[StS.geno])
            
          #La transition florale est passee !
          else:
            if dico_stades[StBl.num_plante][StBl.tiller]["Blade_Transiflo"] == False:
              first_leaf_phase2[StBl.num_plante][StBl.tiller]["num_first_leaf_phase_2"] =  StBl.n -1
              first_leaf_phase2[StBl.num_plante][StBl.tiller]["length_first_leaf_phase_2"] = final_blade_length[StBl.num_plante][StBl.tiller][StBl.n-1]
              StBl.final_length = previous_length + incr_repro_penlt_leaf(first_leaf_phase2[StBl.num_plante][StBl.tiller]["length_first_leaf_phase_2"], L_B_max[StBl.geno], (dico_stades[StL.num_plante][StL.tiller]["Ln_final"] - N_B_r[StBl.geno]) - first_leaf_phase2[StBl.num_plante][StBl.tiller]["num_first_leaf_phase_2"])
              StBl.width = blade_width(StBl.final_length, a_B_w[StBl.geno], b_B_w[StBl.geno])
              StS.final_length = sheath_length(StBl.final_length, a_S_L[StS.geno], b_S_L[StS.geno])
              dico_stades[StBl.num_plante][StBl.tiller]["Blade_Transiflo"] = True
            else:
              if StBl.n in range(dico_stades[StBl.num_plante][StBl.tiller]["Ln_final"] - N_B_r[StBl.geno] + 1, dico_stades[StBl.num_plante][StBl.tiller]["Ln_final"]+1):
                StBl.final_length = flag_leaf_blade_length(StBl.geno,final_blade_length[StBl.num_plante][StBl.tiller][StBl.n-1] , s_B_f[StBl.geno])
                #StBl.width = blade_width(StBl.final_length)
                nmax = dico_stades[StBl.num_plante][StBl.tiller]["Ln_final"] - N_B_r[StBl.geno]
                StBl.width = blade_width(L_B_max[StBl.geno] + (StBl.n - nmax) * incr_repro_penlt_leaf(first_leaf_phase2[StBl.num_plante][StBl.tiller]["length_first_leaf_phase_2"], L_B_max[StBl.geno], (dico_stades[StL.num_plante][StL.tiller]["Ln_final"] - N_B_r[StBl.geno]) - first_leaf_phase2[StBl.num_plante][StBl.tiller]["num_first_leaf_phase_2"]), a_B_w[StBl.geno], b_B_w[StBl.geno])
                StS.final_length = sheath_length(L_B_max[StBl.geno] + (StS.n - nmax) * incr_repro_penlt_leaf(first_leaf_phase2[StBl.num_plante][StBl.tiller]["length_first_leaf_phase_2"], L_B_max[StBl.geno], (dico_stades[StL.num_plante][StL.tiller]["Ln_final"] - N_B_r[StBl.geno]) - first_leaf_phase2[StBl.num_plante][StBl.tiller]["num_first_leaf_phase_2"]), a_S_L[StS.geno], b_S_L[StS.geno])
              else:
                StBl.final_length = previous_length + incr_repro_penlt_leaf(first_leaf_phase2[StBl.num_plante][StBl.tiller]["length_first_leaf_phase_2"], L_B_max[StBl.geno], (dico_stades[StL.num_plante][StL.tiller]["Ln_final"] - N_B_r[StBl.geno]) - first_leaf_phase2[StBl.num_plante][StBl.tiller]["num_first_leaf_phase_2"])
                StBl.width = blade_width(StBl.final_length, a_B_w[StBl.geno], b_B_w[StBl.geno])
                StS.final_length = sheath_length(StBl.final_length, a_S_L[StS.geno], b_S_L[StS.geno])
        final_blade_length[StBl.num_plante][StBl.tiller][StBl.n] = StBl.final_length
        
        #Initialisation de la longueur
        ## L'axe en question n'a pas encore de gaine
        if StBl.n <= 2:
          ## Sur le brin-ma�tre la longueur du limbe est initialis�e � la longueur du coleoptile
          if StBl.tiller == (1,):
            StBl.length = l_c
            StS.length = 0.0
          ## Sur les talles, la longueur du limbe est initialis�e � la longueur de la plus longue gaine pr�sente sur l'axe parent
          else:
            try:
              StBl.length = max([current_sheath_length[StBl.num_plante][StBl.tiller[0:len(StBl.tiller)-1]][x] for x in range(1, StBl.n + 4)])
            except KeyError:
              StBl.length = max([current_sheath_length[StBl.num_plante][StBl.tiller[0:len(StBl.tiller)-1]][x] for x in range(1, StBl.n + 3)])
            StS.length = 0.0
        elif current_sheath_length[StL.num_plante][StL.tiller][StL.n-2] > StBl.final_length:
          StBl.length = StBl.final_length
          StS.length = current_sheath_length[StL.num_plante][StL.tiller][StL.n-2] - StBl.final_length
        #cas classique : la longueur du limbe est initialis�e � la longueur de la gaine n-2 (qui vient de finir sa croissance)
        else:
          StBl.length = current_sheath_length[StL.num_plante][StL.tiller][StL.n-2]  #On recherche la gaine la plus longue sur toute la talle
          StS.length = 0.0
        
        #Calcul de la vitesse de croissance du limbe et de la gaine
        if StBl.n == dico_stades[StBl.num_plante][StBl.tiller]["Ln_final"]:
          StBl.gr_blade = (StBl.final_length - StBl.length) / (phyll_adjust(StL.geno) * ED_FB)
        else:
          StBl.gr_blade = (StBl.final_length - StBl.length) / (phyll_adjust(StL.geno) * ED_B)      
        
        StS.gr_sheath = StS.final_length / (ED_S * phyll_adjust(StL.geno)) #TODO correction
        
        # Shape of the blades
        ln_final = tiller_ln_final(cohort_number(StL.tiller), dico_stades[StL.num_plante][(1,)]["Ln_final"])
        rank_j = (ln_final - N_I_el[StL.geno]) + 1
        rank_max = ln_final - N_B_r[StL.geno]
        rank_flag = ln_final
        StBl.leaf_shape = walter_leaf(nb_segment=leaf_nb_segments, rank=StL.n, rank_j=rank_j, rank_max=rank_max,
                                      rank_flag=rank_flag, scurv=scurv[StL.geno], curvature=curvature[StL.geno])
        StBl.form_factor = form_factor(StBl.leaf_shape)
        # Adding a cutting point to represent the senescence of the blades
        StCPBl = CutPointBlade(StL.num_plante, StL.geno, StL.tiller, StL.n)
        produce \(StL.azimuth)Sheath(StS)[CutPointBlade(StCPBl)Blade(StBl)]
      else:
        produce Leaf(StL)

CutPointBlade(StCPBl):
  if type(dico_stades[StCPBl.num_plante][StCPBl.tiller]["Ln_final"]) == str:
    if StCPBl.n in dico_cut_dead_blades[StCPBl.num_plante][StCPBl.tiller]:
      produce % CutPointBlade(StCPBl)
  elif type(dico_stades[StCPBl.num_plante][StCPBl.tiller]["Ln_final"]) == int:
    if StCPBl.n <= dico_stades[StCPBl.num_plante][StCPBl.tiller]["Ln_final"] - N_I_el[StCPBl.geno]:
      if StCPBl.n in dico_cut_dead_blades[StCPBl.num_plante][StCPBl.tiller]:
        produce % CutPointBlade(StCPBl)

Blade(StBl):
  
  if Tempcum >= Dse_heterogeneous[StBl.num_plante]:
    # Tant que l'axe n'a pas �t� d�sign� pour r�gresser, tout fonctionne normalement
    if StBl.tiller in axis_census[StBl.num_plante] and axis_census[StBl.num_plante][StBl.tiller]["Stop_growth_flag"] == True:
      pass
      if StBl.tiller in axis_census[StBl.num_plante].keys() and axis_census[StBl.num_plante][StBl.tiller]['Regression_flag'] == False:
        StBl.reverse_incr = StBl.visible_length/Delta_Reg
      elif StBl.tiller in axis_census[StBl.num_plante].keys() and axis_census[StBl.num_plante][StBl.tiller]['Regression_flag'] == True:
        StBl.reg_count += max(0,Temperature)
        if StBl.reg_count <= Delta_Reg:
          StBl.visible_length -= StBl.reverse_incr * max(0,Temperature)
    
    else:
      StBl.sumtemp += max(Tbase,Temperature) #lui mettre un nom (a max) et r�utiliser
      StBl.age += time_step
      
      if StBl.sumtemp/phyll_adjust(StBl.geno) <= ED_B:
        StBl.length += min(max(Tbase,StBl.gr_blade * Temperature),StBl.final_length - StBl.length) #gr_blade * max(T_base, Temperature)
      else:
        StBl.length = StBl.final_length   ##TODO superflu ?
      
    #Si on a pas fait la transiflo encore
    if dico_stades[StBl.num_plante][StBl.tiller]["Ln_final"] == "undefined":
      if Tempcum >= date_senescence_fake(StBl.n, t0_sen[StBl.geno]) and StBl.photosynthetic == True:
        StBl.photosynthetic = False
        dico_cut_dead_blades[StBl.num_plante][StBl.tiller].append(StBl.n)
    else:
      if StBl.tiller == (1,):
        if Tempcum >= leaves_senesc_date_main_stem(StBl.n, dico_stades[StBl.num_plante][StBl.tiller]["Ln_final"], phyll_adjust(StBl.geno), n0_sen[StBl.geno], n1_sen[StBl.geno], n3_sen[StBl.geno], t1_sen[StBl.geno], t3_sen[StBl.geno], Dse_heterogeneous[StBl.num_plante], DelayTipToHS[StBl.geno]) and StBl.photosynthetic == True:
          StBl.photosynthetic = False
          dico_cut_dead_blades[StBl.num_plante][StBl.tiller].append(StBl.n)
          if StBl.n == dico_stades[StBl.num_plante][StBl.tiller]["Ln_final"]:
            dico_stades[StBl.num_plante][StBl.tiller]["Senescence_flag_leaf"][0] = True
            dico_stades[StBl.num_plante][StBl.tiller]["Senescence_flag_leaf"][1] = Tempcum
      else:
        if Tempcum >= leaves_senesc_date_tiller(StBl.n, StBl.tiller, dico_stades[StBl.num_plante][StBl.tiller]["Ln_final"], phyll_adjust(StBl.geno), n0_sen[StBl.geno], n1_sen[StBl.geno], n2_sen[StBl.geno], n3_sen[StBl.geno], t1_sen[StBl.geno], t2_sen[StBl.geno], t3_sen[StBl.geno], Dse_heterogeneous[StBl.num_plante], DelayTipToHS[StBl.geno]) and StBl.photosynthetic == True:
          StBl.photosynthetic = False
          dico_cut_dead_blades[StBl.num_plante][StBl.tiller].append(StBl.n)
          if StBl.n == dico_stades[StBl.num_plante][StBl.tiller]["Ln_final"]:
            dico_stades[StBl.num_plante][StBl.tiller]["Senescence_flag_leaf"][0] = True
            dico_stades[StBl.num_plante][StBl.tiller]["Senescence_flag_leaf"][1] = Tempcum
    
    StBl.visible_length = min(StBl.final_length, (StBl.length + current_sheath_length[StBl.num_plante][StBl.tiller][StBl.n]) - (Sh_max[StBl.num_plante][StBl.tiller][StBl.n])) #TODO a optimiser par incr�mentation
    StBl.area = leaf_area(StBl.leaf_shape, StBl.length, StBl.final_length, StBl.width, StBl.form_factor)
    StBl.visible_area = leaf_area(StBl.leaf_shape, StBl.visible_length, StBl.final_length, StBl.width, StBl.form_factor) #TODO a optimiser par incr�mentation
    
    produce Blade(StBl)


Sheath(StS):
  StS.diameter = d_S[StS.geno]
  
  if Tempcum >= Dse_heterogeneous[StS.num_plante]:
    # Tant que l'axe n'a pas �t� d�sign� pour r�gresser, tout fonctionne normalement
    if StS.tiller in axis_census[StS.num_plante] and axis_census[StS.num_plante][StS.tiller]["Stop_growth_flag"] == True:
      pass
    else:
      StS.sumtemp += max(Tbase,Temperature)
      StS.age += time_step
      if StS.sumtemp/phyll_adjust(StS.geno) > ED_B and StS.sumtemp/phyll_adjust(StS.geno) < ED_B + ED_S: # Le limbe a fini sa croissance mais pas la gaine
        #StS.length += max(Tbase,StS.gr_sheath * Temperature)
        StS.length += min(max(Tbase,StS.gr_sheath * Temperature),StS.final_length - StS.length)
      elif StS.sumtemp/phyll_adjust(StS.geno) >  ED_B + ED_S:
        StS.length = StS.final_length
      current_sheath_length[StS.num_plante][StS.tiller][StS.n] = StS.length
      
    if dico_stades[StS.num_plante][StS.tiller]["Ln_final"] == "undefined":
      if Tempcum >= date_senescence_fake(StS.n + 1, t0_sen[StS.geno]) and StS.photosynthetic == True:
        StS.photosynthetic = False
        dead_sheath_length[StS.num_plante][StS.tiller][StS.n] = StS.length
          
    else:
      #Senescence of sheaths
      if StS.tiller == (1,):
        if Tempcum >= leaves_senesc_date_main_stem(min(StS.n +1, dico_stades[StS.num_plante][StS.tiller]["Ln_final"]), dico_stades[StS.num_plante][StS.tiller]["Ln_final"], phyll_adjust(StS.geno), n0_sen[StS.geno], n1_sen[StS.geno], n3_sen[StS.geno], t1_sen[StS.geno], t3_sen[StS.geno], Dse_heterogeneous[StS.num_plante], DelayTipToHS[StS.geno]) and StS.photosynthetic == True:
          StS.photosynthetic = False
          dead_sheath_length[StS.num_plante][StS.tiller][StS.n] = StS.length
      else:
        if Tempcum >= leaves_senesc_date_tiller(min(StS.n +1, dico_stades[StS.num_plante][StS.tiller]["Ln_final"]), StS.tiller, dico_stades[StS.num_plante][StS.tiller]["Ln_final"], Phl[StS.geno], n0_sen[StS.geno], n1_sen[StS.geno], n2_sen[StS.geno], n3_sen[StS.geno], t1_sen[StS.geno], t2_sen[StS.geno], t3_sen[StS.geno], Dse_heterogeneous[StS.num_plante], DelayTipToHS[StS.geno]) and StS.photosynthetic == True:
          StS.photosynthetic = False
          dead_sheath_length[StS.num_plante][StS.tiller][StS.n] = StS.length
    
    #Estimate the max length of sheath (between previous of the axis and on the parent axis)
    if StS.tiller == (1,):
      Sh_max[StS.num_plante][StS.tiller][StS.n] = max(map(current_sheath_length[StS.num_plante][StS.tiller].get, range(0, StS.n+1)))
    else:
      if 2 in current_sheath_length[StS.num_plante][StS.tiller].keys() and current_sheath_length[StS.num_plante][StS.tiller][2] > 0: #WARNING : To avoid key error when axis with less than 2 sheaths
        Sh_max[StS.num_plante][StS.tiller][StS.n] = max(map(current_sheath_length[StS.num_plante][StS.tiller].get, range(0, StS.n+1)))
      else:
        Sh_max[StS.num_plante][StS.tiller][StS.n] = 0
    
    h_whorl = Sh_max[StS.num_plante][StS.tiller][StS.n - 1]
    internode = current_internode_length[StS.num_plante][StS.tiller][StS.n]
    StS.visible_length = min(StS.length, max(0, StS.length + internode - h_whorl))
    StS.area = StS.diameter * pi * StS.length
    #if StS.tiller == (1,):
      #print "gaine : ", StS.n, StS.length
    
    if write_output_file["Sheath"]:
      Sheath_dico_df['Elapsed_time'].append(elapsed_time)
      Sheath_dico_df['Temp_cum'].append(Tempcum)
      Sheath_dico_df['Temperature'].append(Temperature)
      Sheath_dico_df['Num_plante'].append(StS.num_plante)
      Sheath_dico_df['Genotype'].append(StS.geno )
      Sheath_dico_df['Num_talle'].append(str(StS.tiller))
      Sheath_dico_df['Num_cohorte'].append(cohort_number(StS.tiller))
      Sheath_dico_df['Num_rang'].append(StS.n)
      Sheath_dico_df['Sheath_sumtemp'].append(StS.sumtemp)
      Sheath_dico_df['Sheath_diameter'].append(StS.diameter)
      Sheath_dico_df['Sheath_length'].append(StS.length)
      Sheath_dico_df['Sheath_final_length'].append(StS.final_length)
      Sheath_dico_df['Sheath_surface'].append(pi * (StS.diameter/2) * StS.length)
      Sheath_dico_df['Sheath_PAR'].append(StS.PAR)
      Sheath_dico_df['Photosynthetic'].append(StS.photosynthetic)
      
    produce Sheath(StS)

Internode(StI):
  StI.diameter = d_I[StI.geno]
  
  if Tempcum >= Dse_heterogeneous[StI.num_plante]:
    # Tant que l'axe n'a pas �t� d�sign� pour r�gresser, tout fonctionne normalement
    if StI.tiller in axis_census[StI.num_plante] and axis_census[StI.num_plante][StI.tiller]["Stop_growth_flag"] == True:
      StI.area = StI.diameter * pi * StI.length
      current_internode_length[StI.num_plante][StI.tiller][StI.n] = StI.length
      if dico_stades[StI.num_plante][StI.tiller]["Transiflo"][0] == True:
        StI.Ln_final = dico_stades[StI.num_plante][StI.tiller]["Ln_final"]
        #Senescence of internodes
        if StI.tiller == (1,):
          if Tempcum >= leaves_senesc_date_main_stem(min(StI.n +1, StI.Ln_final), StI.Ln_final, phyll_adjust(StI.geno), n0_sen[StI.geno], n1_sen[StI.geno], n3_sen[StI.geno], t1_sen[StI.geno], t3_sen[StI.geno], Dse_heterogeneous[StI.num_plante], DelayTipToHS[StI.geno]) and StI.photosynthetic == True:
            StI.photosynthetic = False
        else:
          if Tempcum >= leaves_senesc_date_tiller(min(StI.n +1, StI.Ln_final), StI.tiller,  StI.Ln_final, phyll_adjust(StI.geno), n0_sen[StI.geno], n1_sen[StI.geno], n2_sen[StI.geno], n3_sen[StI.geno], t1_sen[StI.geno], t2_sen[StI.geno], t3_sen[StI.geno], Dse_heterogeneous[StI.num_plante], DelayTipToHS[StI.geno]) and StI.photosynthetic == True:
            StI.photosynthetic = False
      if write_output_file["Internode"]:
        Internode_dico_df['Elapsed_time'].append(elapsed_time)
        Internode_dico_df['Temp_cum'].append(Tempcum)
        Internode_dico_df['Temperature'].append(Temperature)
        Internode_dico_df['Num_plante'].append(StI.num_plante)
        Internode_dico_df['Genotype'].append(StI.geno )
        Internode_dico_df['Num_talle'].append(str(StI.tiller))
        Internode_dico_df['Num_cohorte'].append(cohort_number(StI.tiller))
        Internode_dico_df['Num_rang'].append(StI.n)
        Internode_dico_df['Internode_length'].append(StI.length)
        Internode_dico_df['Internode_final_length'].append(StI.final_length)
        Internode_dico_df['Internode_surface'].append(StI.area)
        Internode_dico_df['Internode_PAR'].append(StI.PAR)
        Internode_dico_df['Photosynthetic'].append(StI.photosynthetic)
      
    else:
      StI.age += time_step
      StI.sumtemp += max(Tbase,Temperature)
      
      if dico_stades[StI.num_plante][StI.tiller]["Transiflo"][0] == True:
        StI.Ln_final = dico_stades[StI.num_plante][StI.tiller]["Ln_final"]
        StI.final_length = EN_fin_length(n=StI.n, Ln_final=StI.Ln_final, geno=StI.geno, shape=shp_I[StI.geno], PlHeight=Param_PlHeight[StI.geno])
        
        if Tempcum >= dico_stades[StI.num_plante][StI.tiller]["Montaison"][1]:
          if leaf_emerg_date(StI.n, StI.tiller, StI.geno, StI.num_plante) + (ED_B + ED_S) * phyll_adjust(StI.geno) <= Tempcum <= leaf_emerg_date(StI.n, StI.tiller, StI.geno, StI.num_plante) + (ED_B + ED_S + ED_I) * phyll_adjust(StI.geno):
            StI.gr = StI.final_length/(ED_I * phyll_adjust(StI.geno))
            StI.length += min(max(Tbase, StI.gr * Temperature), StI.final_length - StI.length)
            
            if StI.n == StI.Ln_final and dico_stades[StI.num_plante][StI.tiller]["End_internode_elongation"] == False:
              dico_stades[StI.num_plante][StI.tiller]["End_internode_elongation"] = True
            
          StI.area = StI.diameter * pi * StI.length
          current_internode_length[StI.num_plante][StI.tiller][StI.n] = StI.length
        
        #Senescence of internodes
        if StI.tiller == (1,):
          if Tempcum >= leaves_senesc_date_main_stem(min(StI.n +1, StI.Ln_final), StI.Ln_final, phyll_adjust(StI.geno), n0_sen[StI.geno], n1_sen[StI.geno], n3_sen[StI.geno], t1_sen[StI.geno], t3_sen[StI.geno], Dse_heterogeneous[StI.num_plante], DelayTipToHS[StI.geno]) and StI.photosynthetic == True:
            StI.photosynthetic = False
        else:
          if Tempcum >= leaves_senesc_date_tiller(min(StI.n +1, StI.Ln_final), StI.tiller,  StI.Ln_final, phyll_adjust(StI.geno), n0_sen[StI.geno], n1_sen[StI.geno], n2_sen[StI.geno], n3_sen[StI.geno], t1_sen[StI.geno], t2_sen[StI.geno], t3_sen[StI.geno], Dse_heterogeneous[StI.num_plante], DelayTipToHS[StI.geno]) and StI.photosynthetic == True:
            StI.photosynthetic = False
      h_whorl = Sh_max[StI.num_plante][StI.tiller][StI.n - 1]
      StI.visible_length = max(0, StI.length - h_whorl)
      if write_output_file["Internode"]:
        Internode_dico_df['Elapsed_time'].append(elapsed_time)
        Internode_dico_df['Temp_cum'].append(Tempcum)
        Internode_dico_df['Temperature'].append(Temperature)
        Internode_dico_df['Num_plante'].append(StI.num_plante)
        Internode_dico_df['Genotype'].append(StI.geno )
        Internode_dico_df['Num_talle'].append(str(StI.tiller))
        Internode_dico_df['Num_cohorte'].append(cohort_number(StI.tiller))
        Internode_dico_df['Num_rang'].append(StI.n)
        Internode_dico_df['Internode_length'].append(StI.length)
        Internode_dico_df['Internode_final_length'].append(StI.final_length)
        Internode_dico_df['Internode_surface'].append(StI.area)
        Internode_dico_df['Internode_PAR'].append(StI.PAR)
        Internode_dico_df['Photosynthetic'].append(StI.photosynthetic)
        
      nproduce Internode(StI)

Peduncle(StP):
  StP.diameter = d_P[StP.geno]
  # Tant que l'axe n'a pas �t� d�sign� pour r�gresser, tout fonctionne normalement
  if StP.tiller in axis_census[StP.num_plante] and axis_census[StP.num_plante][StP.tiller]["Stop_growth_flag"] == True:
    pass
  else:
    StP.sumtemp += max(Tbase,Temperature)
    StP.final_length = EN_fin_length(n=dico_stades[StP.num_plante][StP.tiller]["Ln_final"]+1, Ln_final=dico_stades[StP.num_plante][StP.tiller]["Ln_final"], geno=StP.geno, shape=shp_I[StP.geno], PlHeight=Param_PlHeight[StP.geno])
    StP.gr = StP.final_length/(ED_P * phyll_adjust(StP.geno))
    if dico_stades[StP.num_plante][StP.tiller]["End_internode_elongation"] == True : #TODO ce n'est pas sur que ce soit tres vrai, mais ce n'est probablement pas catastrophique
      if StP.length < StP.final_length:
        StP.length += min(max(Tbase,StP.gr * Temperature), StP.final_length - StP.length)
      else:
        StP.length = StP.final_length
  StP.area = StP.diameter * pi * StP.length
  h_whorl = max([Sh_max[StP.num_plante][StP.tiller][x] for x in range(0,max(Sh_max[StP.num_plante][StP.tiller].keys()) + 1)])
  StP.visible_length = max(0, StP.length - h_whorl)
  if Tempcum >= dico_stades[StP.num_plante][StP.tiller]["Senescence_flag_leaf"][1] + Delta_flsp and StP.photosynthetic == True:
    StP.photosynthetic = False
  
  if write_output_file["Peduncle"]:
    Peduncle_dico_df['Elapsed_time'].append(elapsed_time)
    Peduncle_dico_df['Temp_cum'].append(Tempcum)
    Peduncle_dico_df['Temperature'].append(Temperature)
    Peduncle_dico_df['Num_plante'].append(StP.num_plante)
    Peduncle_dico_df['Genotype'].append(StP.geno)
    Peduncle_dico_df['Num_talle'].append(str(StP.tiller))
    Peduncle_dico_df['Num_cohorte'].append(cohort_number(StP.tiller))
    Peduncle_dico_df['Num_rang'].append(StP.n)
    Peduncle_dico_df['Sum_temp'].append(StP.sumtemp)
    Peduncle_dico_df['Peduncle_length'].append(StP.length)
    Peduncle_dico_df['Peduncle_final_length'].append(StP.final_length)
    Peduncle_dico_df['Peduncle_surface'].append(StP.area)
    Peduncle_dico_df['Peduncle_PAR'].append(StP.PAR)
    Peduncle_dico_df['Photosynthetic'].append(StP.photosynthetic)
    
  produce Peduncle(StP)

Peduncle(StP) < Ear(StE):
  # Tant que l'axe n'a pas �t� d�sign� pour r�gresser, tout fonctionne normalement
  if StE.tiller in axis_census[StE.num_plante] and axis_census[StE.num_plante][StE.tiller]["Stop_growth_flag"] == True:
    pass
  else:
    if dico_stades[StE.num_plante][StE.tiller]["Ear_emergence"] == True and StE.emerged == False:
      StE.emerged = True
    StE.sumtemp += max(Tbase,Temperature)
    StE.age += time_step
    StE.diameter = d_E[StE.geno]
    StE.final_length = L_E[StE.geno]
    if Tempcum >= 1300:#dico_stades[StE.num_plante][StE.tiller]["Epiaison"][1]:
      StE.length = StE.final_length
  
  StE.area = StE.length * pi * StE.diameter
  h_whorl = max([Sh_max[StE.num_plante][StE.tiller][x] for x in range(0,max(Sh_max[StE.num_plante][StE.tiller].keys()) + 1)])
  StE.visible_length = min(StE.length, max(0, StP.length + StE.length - h_whorl))
  
  if Tempcum >= dico_stades[StE.num_plante][StE.tiller]["Senescence_flag_leaf"][1] + Delta_flsp and StE.photosynthetic == True:
    StE.photosynthetic = False
  
  if write_output_file["Ear"]:
    Ear_dico_df["Elapsed_time"].append(elapsed_time)
    Ear_dico_df["Temp_cum"].append(Tempcum)
    Ear_dico_df["Num_plante"].append(StE.num_plante)
    Ear_dico_df["Genotype"].append(StE.geno)
    Ear_dico_df["Num_talle"].append(str(StE.tiller))
    Ear_dico_df["Ear_sumtemp"].append(StE.sumtemp)
    Ear_dico_df["Ear_length"].append(StE.length)
    Ear_dico_df["Ear_surface"].append(StE.area)
    Ear_dico_df["Emerged"].append(StE.emerged)
    Ear_dico_df["Ear_PAR"].append(StE.PAR)
    Ear_dico_df["Photosynthetic"].append(StE.photosynthetic)
  
  produce Ear(StE)


#######INTERPRETATION##########

interpretation:

#Apex(StA):
#  produce ;(7)^(45)@O(0.01)


#Leaf(StL):
#  produce ;(4)lorient@g(Scaled(Vector3(1,1,StL.length),Leaf))

Sheath(StS):
  my_color = 5
  if StS.photosynthetic == True:
    my_color = 1
  if StS.visible_length > epsilonL:
    # To represent only the longest blade and thus to avoid nested cylinders
    produce ;(my_color)_(StS.diameter/2)F(StS.visible_length)



Blade(StBl):
  if StBl.visible_length > epsilonL:
    if StBl.num_plante in plant_census: # for color between centyre and border plant
      couleur = 1
      if StBl.n <=2 and StBl.tiller == (1,): #Les deux premi�res feuilles tester sur la taille des gaines
        if StBl.sumtemp < (ED_B + ED_S) * phyll_adjust(StBl.geno): # no inclinaison avant ligulation
          StBl.incl = 1
          width = d_S[StBl.geno]-0.05
        else:
          StBl.incl = hazard_dict_organ[StBl.num_plante][StBl.tiller][StBl.n]["blade_inclination"]
          width = StBl.width
      else:
        if axis_census[StBl.num_plante].has_key(StBl.tiller):
          #print StBl.num_plante, StBl.tiller, axis_census[StBl.num_plante][StBl.tiller]["Stop_growth_flag"]
          if axis_census[StBl.num_plante][StBl.tiller]["Stop_growth_flag"] == True:
            couleur = 11
        #Si le limbe n'a pas fini de sortir de la grande gaine
        if StBl.sumtemp < (ED_B + ED_S) * phyll_adjust(StBl.geno):
          StBl.incl = 1
          if StBl.sumtemp < ED_B * phyll_adjust(StBl.geno):
            width = d_S[StBl.geno]
          else:
            width = d_S[StBl.geno]-0.05
        # Si la ligule du limbe est apparente
        else:
          StBl.incl = hazard_dict_organ[StBl.num_plante][StBl.tiller][StBl.n]["blade_inclination"]
          width = StBl.width
          if StBl.photosynthetic == False:
            couleur = 5
    else:
      # Pour les plantes de bordures
      couleur = 4
      if StBl.n <=2 and StBl.tiller == (1,): #Les deux premi�res feuilles tester sur la taille des gaines
        if StBl.sumtemp < (ED_B + ED_S) * phyll_adjust(StBl.geno):
          StBl.incl = 1
          width = d_S[StBl.geno]-0.05
        else:
          StBl.incl = hazard_dict_organ[StBl.num_plante][StBl.tiller][StBl.n]["blade_inclination"]
          width = StBl.width
      else:
        #Si le limbe n'a pas fini de sortir de la grande gaine
        if StBl.sumtemp < (ED_B + ED_S) * phyll_adjust(StBl.geno):
          StBl.incl = 1
          if StBl.sumtemp < ED_B * phyll_adjust(StBl.geno):
            width = d_S[StBl.geno]
          else:
            width = d_S[StBl.geno]-0.05
        # Si la ligule du limbe est apparente
        else:
          StBl.incl = hazard_dict_organ[StBl.num_plante][StBl.tiller][StBl.n]["blade_inclination"]
          width = StBl.width
          if StBl.photosynthetic == False:
            couleur = 5
    mesh = walter_leaf_mesh(StBl.leaf_shape, StBl.final_length, width, StBl.visible_length, StBl.incl)
    produce ;(couleur) @g(mesh)

#Blade(StBl):
#  if StBl.n <=2:
#    if StBl.tiller == (1,):
#      if StBl.sumtemp < (ED_B + ED_S) * phyll_adjust(StBl.geno):
#        StBl.incl = 1
#        width = sheath_diameter-0.05
#      else:
#        StBl.incl = hazard_dict_organ[StBl.num_plante][StBl.tiller][StBl.n]["blade_inclination"]
#        width = StBl.width
#      produce ;(4)+(StBl.incl)@g(Scaled(Vector3(width,0.25,StBl.length),Blade_geo))
#    else:
#      if StBl.sumtemp < (ED_B + ED_S) * phyll_adjust(StBl.geno):
#        StBl.incl = 1
#        if StBl.sumtemp < ED_B * phyll_adjust(StBl.geno):
#          #if StBl.tiller == (1,2) and StBl.n == 1:
#            #print StBl.tiller, StBl.n, "incl : ",StBl.incl
#          produce ;(14)+(StBl.incl)f(Sh_max[StBl.num_plante][StBl.tiller][StBl.n])@g(Scaled(Vector3(sheath_diameter,0.25,StBl.visible_length),Blade_geo))
#        else:
#          produce ;(11)+(StBl.incl)@g(Scaled(Vector3(sheath_diameter,0.25,StBl.length),Blade_geo))
#      
#  else:
#    #Si le limbe n'a pas fini de sortir de la grande gaine
#    if StBl.sumtemp < (ED_B + ED_S) * phyll_adjust(StBl.geno):
#      StBl.incl = 1
#      if StBl.sumtemp < ED_B * phyll_adjust(StBl.geno):
#        produce ;(4)+(StBl.incl)f(Sh_max[StBl.num_plante][StBl.tiller][StBl.n])@g(Scaled(Vector3(sheath_diameter,0.25,StBl.visible_length),Blade_geo))
#      else:
#        produce ;(4)+(StBl.incl)@g(Scaled(Vector3(sheath_diameter-0.05,0.25,StBl.length),Blade_geo))
#    # Si la ligule du limbe est apparente
#    else:
#      StBl.incl = hazard_dict_organ[StBl.num_plante][StBl.tiller][StBl.n]["blade_inclination"]
#      if StBl.photosynthetic == False:
#        produce ;(5)+(StBl.incl)@g(Scaled(Vector3(StBl.width,0.25,StBl.length),Blade_geo))
#      else:
#        produce ;(4)+(StBl.incl)@g(Scaled(Vector3(StBl.width,0.25,StBl.length),Blade_geo))
#
Ear(StE):
  StE.zenith = Phi_zen_E
  #if dico_stades[StE.num_plante][StE.tiller]["End_internode_elongation"] == True and Tempcum < dico_stades[StE.num_plante][StE.tiller]["Flo"][1]:
  if StE.photosynthetic == True:
    if StE.geno == 1:
      ear_color = 2
    else:
      ear_color = 4
  else:
    if StE.geno == 1:
      ear_color = 6
    else:
      ear_color = 7
  if StE.visible_length > epsilonL:
    produce ;(ear_color)&(StE.zenith)_(StE.diameter/2)F(StE.visible_length)

Peduncle(StP):
  color = 5
  if StP.photosynthetic == True:
    color = 7
  if StP.visible_length > epsilonL:
    produce ;(color)_(StP.diameter/2)F(StP.visible_length)
    


Internode(StI):
  if StI.photosynthetic == True:
    my_color = 1
  else:
    my_color = 5
  
  if StI.visible_length > epsilonL:
    produce ;(my_color)_(StI.diameter/2)F(StI.visible_length)


CutPointBud(StCPB):
  if Tempcum < leaf_emerg_date(1, StCPB.tiller, StCPB.geno, StCPB.num_plante) + (ED_B + ED_S) * phyll_adjust(StCPB.geno):
    StCPB.zenith = 0
  else:
    StCPB.zenith = hazard_dict_axis[StCPB.num_plante][StCPB.tiller]["tiller_zenith"]
  #StCPB.zenith = hazard_dict_axis[StCPB.num_plante][StCPB.tiller]["tiller_zenith"]
  StCPB.azimuth = hazard_dict_axis[StCPB.num_plante][StCPB.tiller]["tiller_azimuth"]
  if StCPB.tiller == (1,):
    produce @R/(StCPB.azimuth)+(StCPB.zenith)
  else:
    produce /(StCPB.azimuth)+(StCPB.zenith)

endlsystem
###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
	import openalea.plantgl.all as pgl
	Color_1 = pgl.Material("Color_1" , ambient = (0,0,0) , diffuse = 0 , specular = (8,120,15) , emission = (21,135,38) , )
	Color_1.name = "Color_1"
	context.turtle.setMaterial(1,Color_1)
	Color_2 = pgl.Material("Color_2" , ambient = (0,0,0) , diffuse = 0 , specular = (44,44,44) , emission = (0,143,0) , shininess = 0.69 , )
	Color_2.name = "Color_2"
	context.turtle.setMaterial(2,Color_2)
	Color_3 = pgl.Material("Color_3" , ambient = (0,0,0) , diffuse = 0 , specular = (0,0,0) , emission = (11,111,0) , shininess = 0 , )
	Color_3.name = "Color_3"
	context.turtle.setMaterial(3,Color_3)
	Color_4 = pgl.Material("Color_4" , ambient = (131,0,0) , diffuse = 0.793893 , specular = (0,0,0) , emission = (39,0,0) , shininess = 0 , )
	Color_4.name = "Color_4"
	context.turtle.setMaterial(4,Color_4)
	Color_5 = pgl.Material("Color_5" , ambient = (195,189,16) , diffuse = 0.169231 , specular = (0,0,0) , emission = (14,14,3) , shininess = 0 , )
	Color_5.name = "Color_5"
	context.turtle.setMaterial(5,Color_5)
	Color_6 = pgl.Material("Color_6" , ambient = (36,37,0) , diffuse = 1.83784 , specular = (0,0,0) , emission = (226,152,24) , shininess = 0 , )
	Color_6.name = "Color_6"
	context.turtle.setMaterial(6,Color_6)
	Color_7 = pgl.Material("Color_7" , ambient = (0,0,0) , diffuse = 0 , specular = (0,0,0) , emission = (115,58,20) , )
	Color_7.name = "Color_7"
	context.turtle.setMaterial(7,Color_7)
	Color_8 = pgl.Material("Color_8" , ambient = (5,253,245) , diffuse = 1.00791 , emission = (28,237,255) , )
	Color_8.name = "Color_8"
	context.turtle.setMaterial(8,Color_8)
	Color_9 = pgl.Material("Color_9" , ambient = (170,85,255) , diffuse = 0 , specular = (0,0,0) , )
	Color_9.name = "Color_9"
	context.turtle.setMaterial(9,Color_9)
	Color_10 = pgl.Material("Color_10" , ambient = (0,0,0) , diffuse = 26.6667 , specular = (0,0,0) , )
	Color_10.name = "Color_10"
	context.turtle.setMaterial(10,Color_10)
	Color_11 = pgl.Material("Color_11" , ambient = (0,0,255) , diffuse = 0 , specular = (0,0,0) , )
	Color_11.name = "Color_11"
	context.turtle.setMaterial(11,Color_11)
	Color_12 = pgl.Material("Color_12" , ambient = (0,0,0) , diffuse = 0 , specular = (0,0,0) , emission = (255,42,14) , shininess = 0 , )
	Color_12.name = "Color_12"
	context.turtle.setMaterial(12,Color_12)
	Color_13 = pgl.Material("Color_13" , ambient = (0,0,0) , diffuse = 30 , specular = (0,0,0) , emission = (236,255,19) , )
	Color_13.name = "Color_13"
	context.turtle.setMaterial(13,Color_13)
	Color_14 = pgl.Material("Color_14" , ambient = (248,44,255) , diffuse = 0.627451 , )
	Color_14.name = "Color_14"
	context.turtle.setMaterial(14,Color_14)
